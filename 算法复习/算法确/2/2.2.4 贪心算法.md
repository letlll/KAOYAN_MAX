---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-09T18:29:00
modification: 2024-11-08T18:30:00
description: 
review-frequency: low
---
---

```
path:"算法复习/算法确/2/" 贪心
```

>[!question] 
>**提示**：
>1. **问题或概念**：  
>   - 请分析**贪心算法的两个重要要素**，并通过**最优装载问题**来说明。
>2. **分析框架**：  
>   - 请分解成具体的步骤，并嵌入**贪心算法的两个要素**。对于每个步骤，说明如何体现这两个要素，并用具体的例子来帮助理解。
>3. **要素强调**：  
>   - 在解释过程中，请重点讲解**贪心选择性质**和**最优子结构**，并通过最优装载问题中的每个阶段体现出来。
>4. **举例**：  
>   - 请提供**最优装载问题的背景和算法**，展示如何通过贪心选择的每一步逐渐达到最优解。




#### 9．贪心算法的两个重要要素是什么？举例说明一些可以用贪心算法解决的问题。

>[!important] 答案
**两个重要要素**：
>
>1. **贪心选择性质**：所求问题的整体最优解可以通过一系列的局部最优**选择**得到。
>2. **最优子结构性质**：问题的最优解包含子问题的**最优解**。

- **问题分析**：理解贪心算法的核心属性及应用场景。
- **知识点拓展**：
  - **局部最优**与**全局最优**的关系。
- **理解与记忆**：
  - 贪心算法如贪吃的小鸟，每次选择眼前最美的种子。
- **关键点**：
  1. **贪心选择性质**。
  2. **最优子结构性质**。
- **示例问题**：
  - 活动安排问题
  - 最优装载问题
  - 单源最短路径问题（如 Dijkstra 算法）


#### 10．什么叫贪心选择性质？

>[!important] 答案
**贪心选择性质**：所求问题的整体最优解可以通过一系列的局部最优**选择**得到。

- **问题分析**：深入理解贪心选择的机制。
- **知识点拓展**：
  - **无后效性**：选择当前最优不影响未来选择。
- **理解与记忆**：
  - 每次选择眼前最好的，不考虑未来。
- **关键点**：
  - 整体最优解可通过一系列局部最优选择得到。

>[!important]  贪心算法与动态规划算法

[2.2.2 动态规划](2.2.2%20动态规划.md)

#### 11．贪心算法与动态规划算法的相同点和不同之处？

>[!important] 答案
**相同点**：
>
>- 都具有最优子结构性质。
>- 都用于求解最优化问题。
>
>**不同点**：
>
>- **贪心算法**：具有贪心选择性质，通过局部最优解得到整体最优解。
>- **动态规划**：具有重叠子问题性质，通过保存中间结果避免重复计算。

- **问题分析**：比较贪心算法与动态规划的异同。
- **知识点拓展**：
  - **适用场景**：何时选择贪心，何时选择动态规划。
- **理解与记忆**：
  - 贪心如短跑，动态规划如长跑。
- **关键点**：
  - **相同点**：都具有最优子结构，解决最优化问题。
  - **不同点**：
    - 贪心具有贪心选择性质，依赖局部最优。
    - 动态规划具有重叠子问题性质，需保存中间结果。


---

贪心算法（Greedy Algorithm）是一种通过选择当前状态下最优的方案来逐步逼近全局最优解的算法。它通常依赖于两个重要要素：

### 1. **贪心选择性（Greedy Choice Property）**
   - 这一特性表示在每一步的选择中，我们只关注当前最优的选择，而不考虑整体的全局最优解。这种策略假定每一步的局部最优解可以带来全局最优解。
   
   **举例**：在**最小生成树问题**中，使用贪心算法的**Prim 算法**或**Kruskal 算法**，它们通过选择当前最小的边来逐步构建最小生成树，局部选择当前最小的边并不会影响全局最优解。

### 2. **最优子结构**
   - 这意味着一个问题的全局最优解包含了其子问题的最优解。换句话说，问题的最优解可以通过对子问题的最优解的选择来构建。
   
   **举例**：在**活动选择问题**中，我们选择一个开始时间最早的活动，假设该活动的选择没有影响其他活动的最优性。对于活动选择问题，子问题的最优解是能容纳更多活动的子集，因此最终的全局解就是子问题解的组合。

好的，我将贪心算法的两个重要要素嵌入到**最优装载问题**的分析中，帮助你在不同阶段理解贪心算法的核心思想。

---
### 最优装载问题

**问题描述：**
给定一辆卡车和若干个物品，每个物品有一定的重量和价值，卡车有一个固定的最大承载能力。目标是将尽可能多的物品装入卡车，最大化装载价值，同时不超过卡车的最大承载能力。

#### 贪心算法的两个重要要素

1. **贪心选择性质（Greedy Choice Property）**：
   - 贪心算法的关键在于每一步选择最优的局部解，希望通过这些局部最优解来得到全局最优解。在最优装载问题中，我们通过局部选择每个物品的“价值比”来作出最优选择。

2. **最优子结构（Optimal Substructure）**：
   - 最优解可以通过已解决的小问题的最优解来构建。在最优装载问题中，问题的最优解是通过递归地选择最优物品来逐步构建的。如果某些物品已经被选择到卡车上，我们可以继续选择剩余物品的最优解。

### 贪心算法步骤分析：最优装载问题

假设卡车的最大承载能力是 50，物品列表如下：

| 物品 | 重量 | 价值 | 价值比（价值/重量） |
|------|------|------|-------------------|
| 物品 1 | 10   | 60   | 6                 |
| 物品 2 | 20   | 100  | 5                 |
| 物品 3 | 30   | 120  | 4                 |

### 步骤 1：选择每次局部最优解（贪心选择性质）

**贪心选择性质**要求我们从当前剩余的物品中选择一个最优的物品，这个选择通常是通过某种排序策略来做的。在最优装载问题中，我们选择**价值比（每单位重量的价值）最大的物品**。这就是贪心选择。

- 计算每个物品的价值比：
  - 物品 1 的价值比 = 60 / 10 = 6
  - 物品 2 的价值比 = 100 / 20 = 5
  - 物品 3 的价值比 = 120 / 30 = 4

根据**贪心选择性质**，我们首先选择价值比最大的物品，即物品 1。

#### 选择物品 1（重量 10，价值 60），当前载重 10，剩余容量 40。

### 步骤 2：继续选择下一个局部最优解

在选择物品 1 后，我们继续选择剩余物品中价值比最大的物品。此时剩余容量为 40。

- 物品 1 已经选择过了，所以我们继续选择剩余的物品，计算其价值比：
  - 物品 2 的价值比 = 5
  - 物品 3 的价值比 = 4

根据贪心选择性质，选择价值比最大的物品，即物品 2。

#### 选择物品 2（重量 20，价值 100），当前载重 30，剩余容量 20。

### 步骤 3：继续选择

接下来，剩余容量为 20，继续选择剩余物品中价值比最大的物品。

- 现在只剩下物品 3：
  - 物品 3 的价值比 = 4

我们选择物品 3，但它的重量为 30，超出了卡车剩余的 20 单位容量，因此无法选择。

### 最终解

我们已经选择了物品 1 和物品 2，总重量为 30，价值为 160。由于卡车剩余容量不足以装下物品 3，因此最终解是装载物品 1 和物品 2，最大化了价值。

### 贪心算法的两个重要要素嵌入分析

1. **贪心选择性质：**
   - 在每一步，我们都做出当前最优的选择。每次选择“价值比”最大的物品，这确保了局部最优的选择。通过这种局部最优的选择，我们期望能够得到全局最优解。
   - 在本例中，物品 1 被首先选择，因为它具有最高的价值比，然后选择物品 2，最终得到了总价值为 160 的解。

2. **最优子结构：**
   - 贪心算法通过递归地选择子问题的最优解来构建全局最优解。在本问题中，最优解是逐步选择物品来装载卡车，并且每个选择都是基于当前剩余容量下的最优选择。每次选择都依赖于前一步的选择，构建出最优解。

### 总结

1. **贪心算法的基本要素**：
   - **贪心选择性质**：每一步做出局部最优选择，期望得到全局最优解。在最优装载问题中，我们选择价值比最大的物品。
   - **最优子结构**：问题的最优解可以通过子问题的最优解构建。每一步选择物品时，都是在构建全局最优解的过程中，依赖于先前的选择。

2. **最优装载问题的贪心算法**：
   - 通过贪心选择性质，按物品的价值比选择物品，并逐步构建最优装载解。