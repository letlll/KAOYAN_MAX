---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-09T18:29:00
modification: 2024-11-08T18:30:00
description: 
review-frequency: low
---
---

```
path:"算法复习/算法确/2/" 回溯
```


>[!question] 
>**提示**：
>1. **问题或概念**：  
>   - 请分析**什么是回溯法？**，并通过**N-Queens Problem**来说明，使用中文。
>2. **分析框架**：  
>   - 请分解成具体的步骤，并嵌入**回溯法的基本思想**。对于每个步骤，说明如何体现回溯法的基本思想，并用具体的例子来帮助理解。
>3. **要素强调**：  
>   - 在解释过程中，请重点讲解**回溯法的基本思想**，并通过**N-Queens Problem**中的每个阶段体现出来。
>4. **举例**：  
>   - 请提供**N-Queens Problem的背景和算法**，展示如何通过回溯法的每一步逐渐达到最优解。

>[!important]  回溯法与分支限界法


[2.2.6 分支限界法](2.2.6%20分支限界法.md)
#### 13. **回溯法与分支限界法之间的相同点是什么？不同之处在哪些方面？**

- **问题分析**：回溯法与分支限界法都用于解决组合优化问题，具有一些相似的结构，但在解法和策略上有显著不同。
  - **相同点**：两者都构造出解空间树，并在该树上进行搜索，以寻找最优解。
  - **不同点**：
    - **回溯法**：采用深度优先搜索策略，逐步探查各分支并在不满足条件时返回（称为“回溯”），以避免不必要的计算。
    - **分支限界法**：采用广度优先搜索或优先级策略，选择最有潜力的分支继续探索，并用剪枝技术去除无潜力的分支。

- **知识点拓展**：
  - **剪枝策略**：回溯法和分支限界法都可以通过剪枝优化搜索效率，但在分支限界法中，更依赖优先级和限界函数来判断哪些分支更有潜力。

- **理解与记忆**：
  - 回溯法如深潜，需要对每条路径进行探索，发现行不通的路便折返；而分支限界法像广域搜索，优先寻找看起来更有潜力的路径。

---
### 1. **回溯法的基本思想**

回溯法的基本思想可以分为以下几个步骤：

- **选择**：在当前的状态下，做出一个选择，尝试将一个元素放入某个位置。
- **约束检查**：每次做出选择后，检查当前状态是否满足问题的约束条件。如果满足，继续进行下一步；如果不满足，回退到上一步进行新的尝试。
- **递归探索**：在符合约束条件的状态下，递归地继续选择下一个元素并进入下一层决策。
- **回溯**：如果在某一状态下无法继续探索或没有合法解时，回溯到上一步，重新做出选择，直到找到一个合法解或所有路径都已探索完。

### 2. **4-Queens 问题应用回溯法**

#### 2.1 **选择步骤**：
在回溯法中，**选择步骤**是在当前状态下，做出一个选择，尝试将一个元素放入某个位置。 **4-Queens** 问题中，我们的目标是在 4×4 的棋盘上放置四个皇后。三个约束条件：**多个皇后不能在同一行、同一列、同一条对角线上**。

>[!attention] 
>对角线分为主对角线 `\` 和次对角线 `/` 两种。

![](../../../assets/Pasted%20image%2020241110220618.png)
- 初始时，我们从 **第一行** 开始放置第一个皇后。例如，我们选择将第一个皇后放置在第 **2 列**。此时棋盘状态为 `[ 2, _, _, _]`。
![](../../../assets/Pasted%20image%2020241110220553.png)
#### 2.2 **约束检查**：
回溯法的关键在于对每一步做 **约束检查**。每次放置一个皇后后，我们需要检查：
- 当前列是否已经被其他皇后占用。
- 当前放置的皇后是否和之前的皇后在同一**对角线**上。

假设我们将第一个皇后放置在第 **2列** 后，接下来我们需要放置第二个皇后，检查是否与第一个皇后冲突。

- 在 **第二行**，尝试将第二个皇后放在第 **4 列**，状态为 `[ 2, 4, _, _]`。此时我们需要检查第 2 列是否已被占用，是否与第 **2列**的皇后处于对角线冲突。如果没有冲突，我们继续。

#### 2.3 **递归探索**：
在每个阶段，回溯法会递归地放置下一个皇后。如果当前的状态有效（即满足约束条件），我们进入下一行，继续尝试。

- 在 **第三行**，我们继续放置第三个皇后。例如，我们尝试将第三个皇后放在第 **1 列**，状态为 
`[ 2, 4, 1, _]`。再次进行约束检查，确保没有冲突。
- 如果没有问题，我们递归进入 **第四行**，尝试放置第四个皇后。

#### 2.4 **回溯**：
回溯的核心是当我们遇到无法继续的情况时，撤销当前的选择并返回上一层重新选择。在 4-Queens 问题中，可能会在某一行放置皇后后，发现后续放置无解，例如两个皇后在同一列或对角线。

- 假设在第四行我们放置第四个皇后时，发现它与前面放置的皇后发生了冲突。此时我们会回溯到第三行，重新选择其他位置放置第三个皇后。
- 每次回溯时，我们会撤销当前的选择，返回到上一层，重新探索其他可能的路径。

#### 2.5 **剪枝**：
剪枝是回溯法中优化的重要部分。在回溯过程中，一旦发现某个路径不可能得到解，立即终止该路径的继续探索，回溯到上一步。

- 例如，在某一列或对角线出现冲突时，我们直接剪枝，不再继续当前路径，节省计算资源。

>[!info] 
>如图所示，4 皇后问题的逐行放置过程。仅展开了第一行的其中一个搜索分支，并且将不满足列约束和对角线约束的方案都进行了剪枝。

![](../../../assets/Pasted%20image%2020241110222457.png)
### 3. **回溯法求解 4-Queens 问题**

通过回溯法解决 4-Queens 问题时，我们会按照以下步骤进行：

- **第一步**：在第一行选择放置第一个皇后，并尝试放置在第一个位置。假设我们选择将其放在第 **2列**。
- **第二步**：递归进入第二行，尝试放置第二个皇后。检查该位置是否和第一个皇后冲突。如果没有冲突，继续放置第三个皇后。
- **第三步**：在第三行尝试放置第三个皇后。此时检查是否与前面的皇后发生冲突。如果没有冲突，继续进入第四行，放置第四个皇后。
- **回溯**：如果在任何一步中我们遇到冲突（例如皇后放置在同一列或同一对角线），我们会回溯到上一行，重新选择其他位置。

通过这种方式，我们能够遍历所有可能的皇后放置方案，并找到所有合法的解。

#### 3.1 **找到解**：
通过回溯法的逐步探索，我们最终找到了两个解：
- 解 1：[2, 4, 1, 3]
- 解 2：[3, 1, 4, 2]

**解 1**：[2, 4, 1, 3]  
- 第一行 (1, 2)：第一行的皇后放在第 2 列。
- 第二行 (2, 4)：第二行的皇后放在第 4 列。
- 第三行 (3, 1)：第三行的皇后放在第 1 列。
- 第四行 (4, 3)：第四行的皇后放在第 3 列。

**解 2**：[3, 1, 4, 2]  
- 第一行 (1, 3)：第一行的皇后放在第 3 列。
- 第二行 (2, 1)：第二行的皇后放在第 1 列。
- 第三行 (3, 4)：第三行的皇后放在第 4 列。
- 第四行 (4, 2)：第四行的皇后放在第 2 列。

![](../../../assets/Pasted%20image%2020241110223027.png)
#### 3.2 **对称解法**：
通过镜像变换，我们可以找到另一个解。例如，解 1 的镜像就是解 2，进一步验证了回溯法能够有效遍历解空间并找到所有解。

### 4. **总结**
回溯法通过系统地探索所有可能的解，并在发现无效解时回溯，最终找到 4-Queens 问题的所有合法解。通过选择、约束检查、递归探索和回溯等步骤，回溯法高效地解决了问题，并且通过剪枝避免了不必要的计算，显著提高了求解效率。

---
---
### 什么是回溯法？——以 N-Queens 问题为例

>[!important] 
**回溯法**（Backtracking）是一种通过穷举法系统地遍历所有可能的解空间，逐步构建解并在发现不符合条件的路径时回退到上一步，继续探索其他可能路径的算法。

**回溯法**（Backtracking）是一种算法，用于系统地遍历所有可能的解空间，逐步构建解，并在发现不符合条件的路径时回退到上一步，继续探索其他可能的路径。回溯法通常用于解决组合优化、排列组合等问题，尤其是对于那些有约束条件的优化问题。其核心思想是从一个初始状态出发，逐步向前扩展可能的解，一旦发现某个路径不再可能得到一个合法解时，就回溯到上一步，尝试另一条路径。

### 回溯法的基本思想

回溯法的基本思想可以分为以下几个步骤：

1. **选择**：在当前的状态下，做出一个选择，尝试将一个元素放入某个位置。
2. **约束检查**：每次做出选择后，检查当前状态是否满足问题的约束条件。如果满足，继续进行下一步；如果不满足，回退到上一步进行新的尝试。
3. **递归探索**：在符合约束条件的状态下，递归地继续选择下一个元素并进入下一层决策。
4. **回溯**：如果在某一状态下无法继续探索或没有合法解时，回溯到上一步，重新做出选择，直到找到一个合法解或所有路径都已探索完。

### 具体步骤分析——N-Queens 问题

#### 第一步：初始化

- **问题设定**：给定一个 N×N 的棋盘，我们需要放置 N 个皇后，每个皇后的位置是棋盘上的一行，目标是使得没有两个皇后互相攻击。
- **状态表示**：每个解的状态可以用一个数组来表示，数组的每个位置代表皇后所在的列。例如，数组[2, 4, 1, 3]表示第一个皇后放在第一行第二列，第二个皇后放在第二行第四列，以此类推。

#### 第二步：选择和递归

- **选择**：从第 1 行开始，选择一个位置放置第一个皇后。此时可以将皇后放在第一行的任意一个列（例如，第 1 列、第 2 列等）。选择放置后，我们进入下一行。
  
  - 例如，假设在第一行放置皇后在第 1 列，我们进入第二行，开始选择第二个皇后的位置。

- **约束检查**：在放置第二个皇后时，我们检查它是否和第一个皇后冲突。冲突的情况包括：
  - 同一列（在数组中，第 i 行和第 j 行的皇后放在同一列即代表冲突）。
  - 同一对角线（可以通过差值检查来验证两个皇后是否在同一对角线）。 
  - 如果发生冲突，我们会回退到上一步，重新选择其他列。
  
  - 例如，如果第二个皇后放在第 2 列，则它与第一个皇后在同一对角线上，冲突，因此需要回溯，重新尝试其他列的位置。

#### 第三步：递归深入，剪枝与回溯

- **递归深入**：如果某一行的皇后放置位置合法（即没有冲突），我们递归地在下一行放置皇后，直到所有皇后都被放置完毕。如果所有皇后都合法放置，那么就找到了一个解。

  - 例如，在第一行放置皇后在第 1 列后，第二行尝试放在第 3 列，第三行尝试放在第 4 列，最终所有皇后合法放置，我们得到了一个解。

- **剪枝**：通过回溯法，剪枝的关键是及时终止那些不可能得到合法解的路径。例如，如果在第二行放置了皇后后，已经发现与第一个皇后存在冲突，则不再继续在该路径下做进一步的尝试，直接回退到上一行重新选择。

#### 第四步：回溯

- **回溯**：当发现某一选择路径无法继续时（例如，放置的皇后不合法），回溯到上一步，撤销当前选择，重新尝试其他可能的选择。

  - 例如，若在第三行放置皇后时，所有列都与前面的皇后发生冲突，我们就回溯到第二行，尝试第二行的其他列，直到找到合法的放置方案。


### 示例过程——4 皇后问题

1. **第一步**：尝试在第一行放置皇后，首先选择第 1 列（即数组[1, _, _, _]）。
2. **第二步**：进入第二行，尝试在第 2 列放置第二个皇后，发现与第一个皇后冲突，因此回溯到第一行，重新选择其他列。
3. **第三步**：在第一行选择第 2 列（即数组[2, _, _, _]），进入第二行，放置第二个皇后在第 4 列（即数组[2, 4, _, _]）。
4. **第四步**：进入第三行，尝试在第 1 列放置第三个皇后，发现合法（即数组[2, 4, 1, _]）。
5. **第五步**：进入第四行，尝试在第 3 列放置第四个皇后，发现合法，得到一个解[2, 4, 1, 3]。

通过回溯法，我们逐步尝试所有可能的放置方案，经过剪枝和回溯，最终找到了合法的解。如果继续探索，还可以找到第二个解[3, 1, 4, 2]，这是第一个解的镜像对称。

![逐行放置策略](assets/Pasted%20image%2020241110212639.png)
### 结论

通过 N-Queens 问题的求解，我们展示了回溯法的基本思想：

- **选择与递归**：从第一行开始逐步选择放置皇后的列，递归到下一行。
- **约束检查与剪枝**：每次放置皇后后，检查当前状态是否合法，不合法时回溯并重新选择。
- **回溯与深入**：当发现当前路径不可行时，回到上一步重新选择，直到找到所有解。

回溯法通过对解空间的全面探索和剪枝，大大提高了解决问题的效率，尤其是在约束条件较多的情况下。

---

下列是将第一个皇后选择在第一列，再根据约束条件尝试放置第二个皇后在：

- 第一列的第一行
- 第一列的第二行
- 第一列的第三行
- 第一列的第四行

![回溯法递归树](assets/Pasted%20image%2020241110155231.png)
