---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-09T14:10:00
modification: 2024-11-08T18:30:00
description: 基本思想
review-frequency: low
---
---

```
path:"算法复习/算法确/2/" 递归
```

>[!question] 
>请帮我详细解释 1. 什么是递归算法？什么是递归函数？2. 递归函数的二要素是什么？，并通过例子或公式加以说明。我想要去记忆这两个问题的答案，请你帮助我快速理解他们。研究生
#### 2. **什么是递归算法？什么是递归函数？**

>[!important] 答案
>- **递归**：一种在定义中包含自身的过程。
>- **递归算法**：直接或间接地调用自身来解决问题的算法。
>- **递归函数**：在其定义中调用自身实现递归的函数。

- **问题分析**：递归是一种在定义中包含自身的过程。递归算法是指一个算法通过调用自身来解决问题，递归函数是一个通过调用自身来实现递归的函数。

- **理解与记忆**：
  - 递归就像俄罗斯套娃，一层又一层，每层套娃都是一个更小的版本。递归的过程就是在分解问题，每次处理一个更小的同类问题。
  
- **递归算法和递归函数的区别**：
  - **递归算法**：一种通过调用自身来解决问题的算法，可以直接或间接调用自己。
  - **递归函数**：一个调用自身的函数，通过重复调用来实现递归。

#### 3. **递归函数的二要素是什么？**

>[!important] 答案
>- **边界条件**
>- **递归方程**

- **问题分析**：递归函数有两个关键组成部分：
  - **基准情况**（边界条件）：确保递归能在某一条件下停止，否则递归将无限循环。
  - **递归步**（递归方程）：解决一个比当前问题稍小的子问题，将问题逐步缩小。

- **理解与记忆**：
  - 边界条件是递归的终点，相当于当我们把俄罗斯套娃拆到最小的那个娃时停止。
  - 递归步是我们不断缩小的问题规模，每次只处理比当前情况稍小的情况，直到触及边界条件。

- **关键点总结**：
  - **边界条件**：停止递归的条件，防止无限递归。
  - **递归方程**：通过递归调用逐步解决更小的子问题。

---

>[!important]  斐波那契数列 [4. 毕波那契](../4.%20毕波那契.md)

### 什么是递归算法？

**递归算法**是一种通过将问题分解成更小的相同类型的子问题来解决问题的算法。递归算法的核心思想是：一个问题的解决方案可以通过调用该问题本身的更小规模的子问题来得到，直到达到一个基准条件（通常是最简单的情况，直接返回结果）。

### 斐波那契数列中的递归思想
我们用斐波那契数列作为示例来解释递归算法。斐波那契数列的定义是：
$$
F(n) = 
\begin{cases} 
1 & \text{if } n = 0 \\ 
1 & \text{if } n = 1 \\ 
F(n - 1) + F(n - 2) & \text{if } n > 1 
\end{cases}
$$

这个递归公式表示，每个数是前两个数之和，直到达到基本情况 $f (0) = 0$ 和 $f (1) = 1$。

例如，要计算第 5 个斐波那契数 $f (5)$：
$$
F (5) = f (4) + f (3)
$$
继续展开：
$$
F (4) = f (3) + f (2)
$$
$$
F (3) = f (2) + f (1)
$$
$$
F (2) = f (1) + f (0)
$$
这个过程会递归地调用自己，直到达到基准条件。

### 什么是递归函数？


**递归函数**是一个在其定义中调用自身的函数。递归函数通常包括两部分：
1. **基准情况（Base case）：** 每个递归函数都必须有一个基准情况，这是最简单的场景，不需要进一步的递归。基准情况是一个终止条件，防止函数无限递归。如果没有适当的基准情况，递归函数可能会导致无限递归。

2. **递归情况（Recursive case）：** 在递归情况下，函数会使用修改后的参数调用自身。这是递归的本质——通过将更大的问题分解为更小的相同问题来解决问题。递归情况应随着每次迭代逐渐接近基准情况，最终触发基准情况，从而结束递归。

在斐波那契数列的递归实现中，递归函数的基准条件是 $f (0) = 0$ 和 $f (1) = 1$，其他情况下通过递归调用 $f (n-1)$ 和 $f (n-2)$ 来分解问题。

### 斐波那契数列的递归函数实现（Java 示例）

```java
public class Fibonacci {

    // 递归计算第n个斐波那契数
    public static long fibonacci(int n) {
        // Base case
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        }
        // Recursive case
        else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    public static void main(String[] args) {
        int n = 5; // 计算第5个斐波那契数
        System.out.println("Fibonacci of " + n + " is: " + fibonacci(n));
    }
}
```

### 递归算法的工作原理

1. **分解问题**：通过递归，问题被分解成越来越小的子问题。比如 $f (5) = f (4) + f (3)$，然后继续将 $f (4)$ 和 $f (3)$ 分解为更小的子问题。
2. **达到基准条件**：当递归到达基准条件（即 $f (0)$ 或 $f (1)$），停止进一步的递归调用，返回已知的结果。
3. **回溯计算**：当递归函数返回到上一层时，继续计算并返回最终结果。

### 总结
- **递归算法**通过分解问题的方式，调用相同的问题的子问题来解决，直到达到基准条件。
- **递归函数**是调用自身的函数，包含基准条件和递归调用。在斐波那契数列的例子中，递归函数根据斐波那契定义进行调用，直到计算到最基本的 $f (0)$ 和 $f (1)$。


