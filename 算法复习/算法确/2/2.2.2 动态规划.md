---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-09T18:29:00
modification: 2024-11-08T18:30:00
description: 
review-frequency: low
---
---

```
path:"算法复习/算法确/2/" 动态规划
```


>[!question] 
>请帮我详细解释 1. 动态规划基本步骤是什么2. 动态规划算法的基本要素是什么？3.说明分治法与动态规划法的相同点和不同之处？4. 贪心算法与动态规划算法的相同点和不同之处？举例说明一些可以用动态规划算法解决的问题，并通过例子或公式加以说明。我想要去记忆这两个问题的答案，请你帮助我快速理解他们。研究生

#### 6．动态规划基本步骤是什么？

>[!important] 答案
>1. **分解**：将原问题分解为若干个相同的小问题。
>2. **递归定义最优值**：通过状态转移方程定义最优解。
>3. **自底向上计算最优值**。
>4. **构造最优解**：通过回溯的方式获取最终的解。

- **关键点**：
  1. 分解问题。
  2. 递归定义最优值。
  3. 自底向上计算。
  4. 构造最优解。


#### 7．动态规划算法的基本要素是什么？举例说明一些可以用动态规划算法解决的问题。

>[!important] 答案
>**基本要素**：
>
>- **最优子结构**：问题的最优解包含子问题的最优解。
>- **重叠子问题**：子问题重复出现，需避免重复计算。
>
**示例问题**：
>
>- 矩阵连乘
>- 最长公共子序列（LCS）
>- 0-1 背包问题

- **问题分析**：识别动态规划的核心属性及应用场景。
- **知识点拓展**：
  - **记忆化**与**表格填充**。
- **理解与记忆**：
  - 动态规划如搭积木，利用已完成的小块构建大块。
- **关键点**：
  - **最优子结构**。
  - **重叠子问题**。
- **示例问题**：
  - 矩阵连乘
  - 最长公共子序列（LCS）
  - 0-1 背包问题

---

>[!important]  分治法与动态规划法

[2.2.3 分治法](2.2.3%20分治法.md)
#### 8．说明分治法与动态规划法的相同点和不同之处？

- **问题分析**：比较分治法与动态规划法的异同。
- **知识点拓展**：
  - **Memoization**：动态规划的记忆化技术。
- **理解与记忆**：
  - 分治是切披萨，动态规划是记住每一块的味道，避免重复切割。
- **关键点**：
  - **相同点**：都将问题分解为更小的子问题。
  - **不同点**：动态规划处理有重叠的子问题，分治处理独立的子问题。

>[!important]  贪心算法与动态规划算法

[2.2.4 贪心算法](2.2.4%20贪心算法.md)
#### 11．贪心算法与动态规划算法的相同点和不同之处？

- **问题分析**：比较贪心算法与动态规划的异同。
- **知识点拓展**：
  - **适用场景**：何时选择贪心，何时选择动态规划。
- **理解与记忆**：
  - 贪心如短跑，动态规划如长跑。
- **关键点**：
  - **相同点**：都具有最优子结构，解决最优化问题。
  - **不同点**：
    - 贪心具有贪心选择性质，依赖局部最优。
    - 动态规划具有重叠子问题性质，需保存中间结果。


---

通过 **最长公共子序列（LCS）** 问题来详细讲解 **动态规划的基本步骤** 和 **基本要素**。

### 1. 动态规划基本步骤是什么？

动态规划的基本步骤可以通过以下四个关键步骤来概括，下面用**最长公共子序列（LCS）**的例子来详细说明每一个步骤：

### 1. **分解**
   - 将原问题分解成若干个规模较小的相同问题。在动态规划中，这些子问题是通过状态来表示的。例如，在 LCS 问题中，我们将问题分解为不同长度的子字符串之间的 LCS 问题。

   **LCS 示例**：
   - 给定两个字符串 `s1 = "ABCBDAB"` 和 `s2 = "BDCABB"`，我们要计算 `s1` 和 `s2` 的 LCS。
   - 我们将原问题分解为子问题 `dp[i][j]`，表示 `s1[0..i-1]` 和 `s2[0..j-1]` 的 LCS 长度。

### 2. **递归地定义最优值**
   - 对每个子问题，递归地定义其最优解。这个递归定义通常由**状态转移方程**表示，即如何通过较小的子问题来求解当前子问题。

   **LCS 示例**：
   - 递归定义最优值：如果 `s1[i-1] == s2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`；否则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

### 3. **自底向上计算最优值**
   - 从最小的子问题开始，逐步向更大的子问题扩展，直到最终解决原问题。这个过程是“自底向上”的，意味着我们会从基础的边界条件开始填充表格。

   **LCS 示例**：
   - 初始化边界条件：`dp[0][j] = 0` 和 `dp[i][0] = 0`，表示当一个字符串为空时，LCS 的长度为 0。
   - 然后，逐步计算从 `dp[1][1]` 开始到 `dp[m][n]`，使用前面提到的状态转移方程填表。

### 4. **构造最优解**
   - 一旦计算出最优值（如 `dp[m][n]`），就可以通过回溯的方式构造出实际的最优解（例如，最长公共子序列的内容）。

   **LCS 示例**：
   - 从 `dp[m][n]` 开始回溯，若 `s1[i-1] == s2[j-1]`，则该字符属于 LCS；否则，沿着最大值方向回溯，直到回溯到 `dp[0][0]`。

### 总结

1. **分解**：将原问题分解为若干个相同的小问题。
2. **递归定义最优值**：通过状态转移方程定义最优解。
3. **自底向上计算最优值**。
4. **构造最优解**：通过回溯的方式获取最终的解。

---
### 2. 动态规划算法的基本要素是什么？

动态规划算法的基本要素包括：

#### 要素 1: **重叠子问题**

- 在动态规划中，问题可以分解为多个子问题，这些子问题会被多次计算。LCS 问题中，`dp[i][j]` 的值会基于 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 来计算。如果不使用动态规划来保存这些中间计算结果，会导致大量重复计算。

#### 要素 2: **最优子结构**

- 问题的最优解可以通过其子问题的最优解来构建。LCS 问题中的最优解（即两个字符串的最长公共子序列）是通过已计算出的较小子问题（即较短的字符串的 LCS）逐步构建的。例如，`dp[i][j]` 是由 `dp[i-1][j-1]`（如果 `s1[i-1] == s2[j-1]`）或者 `dp[i-1][j]` 和 `dp[i][j-1]`（如果字符不相等）来得到的。

### 示例：计算字符串 "ABCBDAB" 和 "BDCABB" 的 LCS

#### 输入：
- `s1 = "ABCBDAB"`
- `s2 = "BDCABB"`

#### 初始化 `dp` 表格：
构建一个 `(m+1) x (n+1)` 的二维数组 `dp`，其中 `m` 是 `s1` 的长度，`n` 是 `s2` 的长度。初始时，所有 `dp[i][0] = 0` 和 `dp[0][j] = 0`。

|     |   B |   D |   C |   A |   B |   B |
|-----|-----|-----|-----|-----|-----|-----|
| **A** |  0  |  0  |  0  |  1  |  1  |  1  |
| **B** |  1  |  1  |  1  |  1  |  2  |  2  |
| **C** |  1  |  1  |  2  |  2  |  2  |  2  |
| **B** |  1  |  1  |  2  |  2  |  3  |  3  |
| **D** |  1  |  2  |  2  |  2  |  3  |  3  |
| **A** |  1  |  2  |  2  |  3  |  3  |  3  |
| **B** |  1  |  2  |  2  |  3  |  4  |  4  |

#### 填表过程：
1. 从 `dp[1][1]` 开始，逐行逐列填充表格。
2. 根据状态转移方程，逐步更新每个 `dp[i][j]` 的值：
   - 如果 `s1[i-1] == s2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 如果 `s1[i-1] != s2[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

#### 结果：
- 最终的 LCS 长度为 `dp[7][6] = 4`，即字符串 "ABCBDAB" 和 "BDCABB" 的最长公共子序列的长度为 4。
- **LCS 结果**：通过回溯，我们可以得到最长公共子序列是 "BCAB"。

### 总结

1. **动态规划的基本步骤**：
   1. **定义状态**：`dp[i][j]` 表示 `s1[0..i-1]` 和 `s2[0..j-1]` 的 LCS 长度。
   2. **状态转移方程**：`dp[i][j] = dp[i-1][j-1] + 1` （字符相等时），`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（字符不等时）。
   3. **初始化边界条件**：`dp[0][j] = 0` 和 `dp[i][0] = 0`。
   4. **填表计算**：按照状态转移方程逐步填表。
   5. **返回结果**：最终的答案是 `dp[m][n]`。

2. **动态规划的基本要素**：
   - **重叠子问题**：LCS 问题的解通过计算多个子问题获得，且这些子问题的解会被多次使用。
   - **最优子结构**：LCS 的最优解是通过其子问题的最优解构建的，即通过已计算出的较小问题的解逐步构建全局解。

---

### 3. 说明分治法与动态规划法的相同点和不同之处？

#### 相同点：
- **分治法**和**动态规划法**都采用将大问题分解为小问题的策略。
- 两者都通过递归来解决子问题。
- 两者都可能利用子问题的解来组合成更大问题的解。

#### 不同之处：
- **重叠子问题**：动态规划法适用于子问题重叠的情况，即相同的子问题会被多次计算；而分治法没有这种重叠子问题，通常每个子问题只会被计算一次。
- **存储子问题的解**：动态规划通过使用一个表（如数组、矩阵）来存储子问题的解，避免重复计算；而分治法通常不存储子问题的解，每次递归都会重新计算。
- **状态转移**：动态规划有明确的状态转移方程，通常从小到大依次计算；分治法通常是通过递归分解问题，合并子问题的解来得到最终结果。

#### 例子：
- **分治法**：归并排序、快速排序等。
- **动态规划法**：最长公共子序列、背包问题等。

### 4. 贪心算法与动态规划算法的相同点和不同之处？

#### 相同点：
- **局部最优解**：两者的核心思想都是通过选择局部最优解来逐步逼近全局最优解。
- **优化问题**：都用于解决最优化问题。

#### 不同之处：
- **最优性保证**：动态规划通过考虑所有可能的子问题解来确保全局最优解，通常是通过“最优子结构”来保证；而贪心算法只关心当前的局部最优解，不一定能够得到全局最优解。
- **问题类型**：贪心算法适用于可以通过局部最优选择来构造全局最优解的问题；而动态规划适用于具有重叠子问题和最优子结构的复杂问题。

#### 例子：
- **贪心算法**：活动选择问题、霍夫曼编码。
- **动态规划算法**：背包问题、最长公共子序列问题。

### 动态规划算法解决的问题

1. **背包问题**：
   给定一组物品，每个物品有一个重量和价值，在给定容量的背包中选择物品，使得总价值最大。

   动态规划的状态转移方程：  
   $dp[i][w]$表示前 $i$个物品在重量限制 $w$下的最大价值。  
   状态转移方程：
$$
   Dp[i][w] = \max (dp[i-1][w], dp[i-1][w-w_i] + v_i)
$$
   其中，$w_i$ 和$v_i$分别是第$i$个物品的重量和价值。

2. **最长公共子序列问题**：
   给定两个字符串，求它们的最长公共子序列。

   动态规划的状态转移方程：  
   $dp[i][j]$表示第一个字符串前 $i$个字符与第二个字符串前 $j$个字符的最长公共子序列长度。  
   状态转移方程：
$$
   Dp[i][j] = \begin{cases} 
   Dp[i-1][j-1] + 1 & \text{if } s 1[i-1] = s 2[j-1] \\
   \max (dp[i-1][j], dp[i][j-1]) & \text{if } s 1[i-1] \neq s 2[j-1]
   \end{cases}
$$





---

## 状态转移方程

要理解 **状态转移方程**，最好的方式是通过实际的代码来直观地讲解。我们用 **LCS（最长公共子序列）** 的 C 语言代码来示范如何通过状态转移方程来递归定义最优值。

### **LCS 问题简述**

给定两个字符串 `s1` 和 `s2`，我们希望找到它们的最长公共子序列（LCS）。例如：

- `s1 = "ABCBDAB"`
- `s2 = "BDCABB"`

最长公共子序列是 `BCAB`，它的长度为 4。

### **状态转移方程**

在动态规划中，我们需要为每个子问题定义一个**状态**，并且使用一个**状态转移方程**来描述如何从已经计算出的子问题的解推导出当前问题的解。

**状态转移方程**对于 LCS 问题可以这样理解：

- 定义 `dp[i][j]` 为 `s1[0..i-1]` 和 `s2[0..j-1]` 的 LCS 的长度。
- 如果 `s1[i-1] == s2[j-1]`，那么 `dp[i][j] = dp[i-1][j-1] + 1`，即这两个字符可以加入 LCS。
- 如果 `s1[i-1] != s2[j-1]`，那么 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`，即我们选择忽略 `s1[i-1]` 或 `s2[j-1]`，取其中较大的 LCS 长度。

这就是 **状态转移方程**，它告诉我们如何通过更小的子问题来求解当前的 LCS 问题。

### **C 语言代码实现**

下面是 LCS 问题的 C 语言代码，演示如何使用状态转移方程来填充 `dp` 表。

```c
#include <stdio.h>
#include <string.h>

#define MAX 100

int lcs(char *s1, char *s2, int m, int n) {
    int dp[MAX][MAX];  // dp[i][j] 表示 s1[0..i-1] 和 s2[0..j-1] 的 LCS 长度

    // 初始化 dp 表
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;  // 当任一字符串为空时，LCS 长度为 0
            }
        }
    }

    // 填充 dp 表
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;  // 如果字符相等，LCS 长度加 1
            } else {
                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ? dp[i - 1][j] : dp[i][j - 1];  // 否则取较大的值
            }
        }
    }

    // 返回最终的 LCS 长度
    return dp[m][n];
}

int main() {
    char s1[] = "ABCBDAB";
    char s2[] = "BDCABB";
    int m = strlen(s1);
    int n = strlen(s2);
    
    int result = lcs(s1, s2, m, n);
    printf("The length of LCS is %d\n", result);
    return 0;
}
```

### **代码解析**

1. **初始化**：
   - 我们定义一个二维数组 `dp`，大小为 `(m+1) x (n+1)`，用来存储不同子问题的解。
   - 如果 `i == 0` 或 `j == 0`，表示其中一个字符串为空，因此其 LCS 长度为 0。
   
2. **填表过程（状态转移方程的应用）**：
   - 从 `dp[1][1]` 开始，逐步填充 `dp` 表。对于每个 `dp[i][j]`，我们根据 `s1[i-1]` 和 `s2[j-1]` 是否相等来决定：
     - 如果相等，说明当前字符可以加入到 LCS 中，因此 `dp[i][j] = dp[i-1][j-1] + 1`。
     - 如果不相等，说明当前字符不能加入 LCS，我们从前面的子问题中选择较大的解：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
   
3. **输出结果**：
   - 最终，`dp[m][n]` 就是字符串 `s1` 和 `s2` 的最长公共子序列的长度。

### **状态转移方程的数学表示**

- **当 `s1[i-1] == s2[j-1]`** 时：
$$
  Dp[i][j] = dp[i-1][j-1] + 1
$$
  这意味着如果当前字符相同，我们就可以将其包含在 LCS 中，LCS 长度加 1。
  
- **当 `s1[i-1] != s2[j-1]`** 时：
$$
  Dp[i][j] = \max (dp[i-1][j], dp[i][j-1])
$$
  这意味着我们选择不包含当前字符，而是选择去掉 `s1[i-1]` 或 `s2[j-1]` 中的一个字符，取两种情况中的较大值。

### **总结**

- **状态转移方程** 是动态规划中非常关键的部分，它帮助我们定义了如何通过较小的子问题来计算当前问题的解。在 LCS 问题中，我们使用 `dp[i][j]` 来表示 `s1[0..i-1]` 和 `s2[0..j-1]` 的 LCS 长度，然后根据字符是否相等来递归地定义最优值。
- 通过这种方式，动态规划避免了重复计算，并且最终获得最优解。