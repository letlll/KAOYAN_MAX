---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-10T12:18:00
description: 
review-frequency: normal
reviewed: 2024年-11月-10日
---
---

- [ ] 1. 01 背包问题
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [x] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [ ] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [ ] 9. O 的性质

---

## 二分搜索技术

给定已按升序排序好的 \( n \) 个元素 \( a[0: n-1] \)，现要在这 \( n \) 个元素中找出一个特定元素 \( x \)。

### 分析
- 该问题的规模缩小到一定的程度就可以容易地解决；
- 该问题可以分解为若干个规模较小的相同问题；
- 分解出的子问题的解可以合并为原问题的解；
- 分解出的各个子问题是相互独立的。

#### 进一步分析
很显然，此问题分解出的子问题相互独立，即在 \( a[i] \) 的前面或后面查找 \( x \) 是独立的子问题，因此满足分治法的条件。

### 二分搜索算法实现

根据以上分析，以下是二分搜索的算法实现：

```java
public static int binarySearch(int[] a, int x, int n) {
    // 在 a[0] <= a[1] <= ... <= a[n-1] 中搜索 x
    // 找到 x 时返回其在数组中的位置，否则返回 -1
    int left = 0;
    int right = n - 1;

    while (left <= right) {
        int middle = (left + right) / 2;
        
        if (x == a[middle]) return middle;
        if (x > a[middle]) left = middle + 1;
        else right = middle - 1;
    }
    
    return -1; // 未找到 x
}
```

### 算法复杂度分析
每执行一次算法的 `while` 循环，待搜索数组的大小减少一半。

- **最坏情况**：在最坏情况下，`while` 循环被执行了 \( O (\log n) \) 次。
- **时间复杂度**：循环体内运算需要 \( O (1) \) 时间，因此整个算法在最坏情况下的计算时间复杂度为 \( O (\log n) \)。

### 思考题
给定数组 \( a \)，用二分法设计出求 \( a^n \) 的算法。

## 快速排序

**概述**:
快速排序是对冒泡排序的一种改进，由 C.A.R. Hoare 于 1962 年提出。

**算法步骤**:
1. 选择一个基准元素。
2. 分区：将数组分为两部分，左边部分小于等于基准，右边部分大于等于基准。
3. 递归地对左右两部分进行排序。

**代码实现**:
```java
private static void qSort(int p, int r) {
    if (p < r) {
        int q = partition(p, r); // 划分数组
        qSort(p, q - 1);         // 排序左半部分
        qSort(q + 1, r);         // 排序右半部分
    }
}

private static int partition(int p, int r) {
    int i = p;
    int j = r + 1;
    Comparable x = a[p];
    while (true) {
        while (a[++i].compareTo(x) < 0) if (i == r) break;
        while (a[--j].compareTo(x) > 0) if (j == p) break;
        if (i >= j) break;
        swap(a, i, j);
    }
    swap(a, p, j);
    return j;
}
```

**复杂度分析**:
- **最坏时间复杂度**: `O(n²)`
- **平均时间复杂度**: `O(n log n)`
- **空间复杂度**: `O(log n)`（递归调用栈）

**优化方法**:
- 随机选择基准元素，避免最坏情况发生。
```java
private static int randomizedPartition(int p, int r) {
    int i = random(p, r);
    swap(a, i, p);
    return partition(p, r);
}
```

**稳定性**:
- 快速排序是不稳定的。

---
## 3.9 流水作业调度

### 3.9.1 问题描述

有 `n` 个作业 `{1, 2, …, n}` 要在由两台机器 `M1` 和 `M2` 组成的流水线上完成加工。每个作业的加工顺序都是先在 `M1` 上加工，然后在 `M2` 上加工。机器 `M1` 和 `M2` 加工作业 `i` 所需的时间分别为 `ai` 和 `bi`。

**目标**: 确定作业的最优加工顺序，使得从第一个作业在 `M1` 上开始加工，到最后一个作业在 `M2` 上加工完成所需的时间最少。

### 3.9.2 最优性原理

设 `π` 是作业集 `S` 在机器 `M2` 的等待时间为 `t` 时的一个最优调度，所需的加工时间为 `ai + T(S - {i}, bi)`。则动态规划递归关系如下：

```
T(S, t) = min { ai + T(S - {i}, bi + max{ t - ai, 0 }) } for all i ∈ S
```

**最优子结构**: `T(n, c) = min { a_i + T(n - {i}, b_i) }`


---
### 4.10.2 贪心算法实现

**贪心策略**：采用最长处理时间作业优先的贪心选择策略。

**算法步骤**：

1. **排序**：将所有作业按其处理时间从大到小排序。
2. **分配**：依次将作业分配给当前最空闲的机器。
3. **重复**：直到所有作业都被分配完毕。

**代码实现**：

```java
import java.util.Arrays;
import java.util.Comparator;

public class MultiMachineScheduling {
    /**
     * 多机调度的贪心算法：最长处理时间优先
     * @param m 机器数量
     * @param jobs 作业处理时间数组
     * @return 最短完成时间
     */
    public static int schedule(int m, int[] jobs) {
        // 将作业按处理时间从大到小排序
        Integer[] sortedJobs = new Integer[jobs.length];
        for(int i = 0; i < jobs.length; i++) {
            sortedJobs[i] = jobs[i];
        }
        Arrays.sort(sortedJobs, Comparator.reverseOrder());

        int[] machineTime = new int[m];
        for(int job : sortedJobs){
            // 找到当前最空闲的机器
            int minMachine = 0;
            for(int i = 1; i < m; i++) {
                if(machineTime[i] < machineTime[minMachine]){
                    minMachine = i;
                }
            }
            // 将作业分配给最空闲的机器
            machineTime[minMachine] += job;
        }

        // 找到最慢的机器完成时间
        int makespan = machineTime[0];
        for(int i = 1; i < m; i++) {
            if(machineTime[i] > makespan){
                makespan = machineTime[i];
            }
        }
        return makespan;
    }

    public static void main(String[] args){
        int m = 3; // 机器数量
        int[] jobs = {2, 14, 4, 16, 6, 5, 3}; // 作业处理时间
        int makespan = schedule(m, jobs);
        System.out.println("最短完成时间为: " + makespan);
    }
}
```

**示例输出**：

```
最短完成时间为: 17
```

**算法分析**

| **属性**           | **说明**                                                                                                 |
|--------------------|----------------------------------------------------------------------------------------------------------|
| **贪心选择性质**   | 选择最长处理时间的作业优先分配，可以有效地减少机器的空闲时间，从而缩短总完成时间。                           |
| **时间复杂度**     | `O(n log n)`，主要耗时在排序步骤。                                                                       |
| **空间复杂度**     | `O(m)`，用于存储每台机器的当前处理时间。                                                                 |

**示例说明**

**作业与机器信息**

- **作业**：{1, 2, 3, 4, 5, 6, 7}
- **机器**：M 1, M 2, M 3
- **处理时间**：{2, 14, 4, 16, 6, 5, 3}

**作业排序**

按照贪心算法排序后的作业顺序为：{16, 14, 6, 5, 4, 3, 2}

**分配步骤**

| **步骤** | **作业** | **处理时间** | **分配给机器** | **机器负载**       |
|----------|----------|--------------|----------------|--------------------|
| 1        | 作业 4    | 16           | M 1             | M 1: 16             |
| 2        | 作业 2    | 14           | M 2             | M 2: 14             |
| 3        | 作业 5    | 6            | M 3             | M 3: 6              |
| 4        | 作业 6    | 5            | M 3             | M 3: 11 (6 + 5)     |
| 5        | 作业 3    | 4            | M 3             | M 3: 15 (11 + 4)    |
| 6        | 作业 7    | 3            | M 2             | M 2: 17 (14 + 3)    |
| 7        | 作业 1    | 2            | M 1             | M 1: 18 (16 + 2)    |

**最终完成时间:** **18**

*注：通过其他调度策略，可能达到更优的完成时间 **17**。*

---
### 5.4.2 解空间的排序

在回溯法中，可以通过合理地排序解空间中的选择顺序，优先探索可能性更大的分支，从而更快地找到最优解，并在早期阶段进行剪枝。

**示例：n 后问题中的排序**

在解决 n 后问题时，先尝试将皇后放置在可能性较高的位置，可以减少无效搜索。

### 5.7.2 解空间排序

通过合理地排序解空间中的选择顺序，优先探索可能性更大的分支，可以更快地找到最优解，并在早期阶段进行剪枝。

**示例**：

在解决 n 后问题时，先尝试将皇后放置在可能性较高的位置，如边缘或中心位置，减少无效搜索。

---


