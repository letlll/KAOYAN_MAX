---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-08T22:24:00
description: O(log n)
review-frequency: normal
reviewed: 2024年-11月-08日
---
---

- [ ] 1. 01 背包问题
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [ ] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [ ] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [x] 9. O 的性质

---
### 解释 `O(log n)` —— 对数时间复杂度

`O(log n)` 代表 **对数时间复杂度**，它是一种非常高效的算法复杂度类型。当算法的执行时间与输入规模 `n` 的对数成正比时，算法的执行步骤会随着数据量增大而逐渐减少。
### 代码：
```cpp
int i = 1;
while(i < n) {
    i = i * 2;
}
```

### 分析：

#### 1. **循环条件**：
- 初始时，`i` 的值为 1。
- 在每次迭代中，`i` 会乘以 2，即 `i = i * 2`。
- 每次循环后，`i` 的值是上次值的两倍，这意味着 `i` 是以指数级的速度增长的。

#### 2. **迭代次数**：
我们来具体分析 `i` 需要多少次乘以 2 才能大于或等于 `n`。

- 初始时 `i = 1`，第一次循环后 `i = 2`，第二次循环后 `i = 4`，依此类推。
- 也就是说，每次循环后，`i` 的值是前一个值的 2 倍，形成了一个几何序列：
  - 第 1 次迭代后，`i = 2^1 = 2`
  - 第 2 次迭代后，`i = 2^2 = 4`
  - 第 3 次迭代后，`i = 2^3 = 8`
  - ……
  - 第 k 次迭代后，`i = 2^k`

我们希望找到一个 `k`，使得 `i >= n`。也就是说，我们想要找到 `k` 满足：
$$
2^k \geq n
$$
为了找到最小的 `k`，我们两边同时取对数（以 2 为底）：
$$
K \geq \log_2 (n)
$$
因此，循环会执行大约 `\log_2(n)` 次。

#### 3. **时间复杂度**：
- 每次迭代中，`i` 的值翻倍，因此迭代次数是 `log_2(n)` 次。
- 由于每次迭代中的操作（即 `i = i * 2`）是常数时间操作，因此每次迭代的时间复杂度是 `O(1)`。
- 综上所述，整个 `while` 循环的时间复杂度是 `O(log n)`，其中的 `log` 通常默认为以 2 为底，尽管不同的底数只会产生常数倍的差异。

### 总结：
- 由于 `i` 的增长是指数级的，每次迭代 `i` 的值翻倍，从 `1` 变到 `n` 需要 `log_2(n)` 次。
- 因此，整个循环的时间复杂度是 `O(log n)`。

### 数学公式推导：
1. 初始值：`i = 1`
2. 每次迭代，`i` 变为 `2 * i`，即 `i = i * 2`
3. 经过 `k` 次迭代后，`i = 2^k`。
4. 需要满足 `2^k ≥ n`，因此 `k ≥ log_2(n)`。
5. 所以，`while` 循环会执行大约 `log_2(n)` 次。

最终，时间复杂度是 `O(log n)`。