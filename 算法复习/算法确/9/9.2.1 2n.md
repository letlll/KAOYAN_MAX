---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-08T22:24:00
description: O(2^n)
review-frequency: normal
reviewed: 2024年-11月-08日
---
---

- [ ] 1. 01 背包问题
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [ ] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [ ] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [x] 9. O 的性质

---
### 解释 `O(2^n)` —— 指数复杂度

在计算机科学中，`O(2^n)` 代表的是 **指数复杂度**，即随着输入数据规模 `n` 的增加，算法的执行时间会呈 **指数级增长**。这意味着每增加一单位的输入，程序的运行时间就会翻倍。

让我们从头开始拆解这个概念，帮助你理解为什么指数复杂度的增长会这么快，并通过一个实际例子来具体说明。

### 指数增长的直观类比

首先，我们来看一下指数增长是什么样的。假设你在种一棵树，这棵树每年会长出 **两倍** 的枝条（例如，每年树的枝条数量翻倍）。如果一开始树只有一个枝条，那么：

- 第一年：$1$ 个枝条
- 第二年：$2$ 个枝条
- 第三年：$4$ 个枝条
- 第四年：$8$ 个枝条
- 第五年：$16$ 个枝条

你可以看到，枝条的数量在每一年都以指数级的速度增加。如果你继续下去，第 10 年可能会有 **1024** 个枝条，而第 20 年就可能有 **1048576** 个枝条。这个增长速度非常快，跟线性增长（例如每年增加固定数量的枝条）完全不同。

在算法中，当我们遇到 `O(2^n)` 的时间复杂度时，它表示的是一种类似的**快速增长**，每增加一个输入，算法的运行时间都会翻倍。

### 你的代码示例解析

看你提供的代码：

```cpp
int func(int n)
{
    if(n == 0) return 1;
    return func(n) + func(n-1);
}
```

让我们详细分析这段代码的运行方式，理解为什么它会导致指数复杂度。

#### 递归调用的含义

这段代码是一个递归函数，它会不停地调用自身。你可以看到，递归的终止条件是 $n == 0$，然后返回 $1$。否则，函数会做 **两次递归调用**：
- $\text{func}(n)$（当前的递归调用）
- $\text{func}(n-1)$（对 $n-1$ 的递归调用）

注意到，**每次递归都会生成两个子问题**，这意味着递归的调用树将呈现出一个二叉树的结构。在这个树中，每个节点都有两个子节点，直到递归到达 $n == 0$ 作为终止条件。

#### 分析递归树

1. **根节点** 是 $\text{func}(n)$。
2. **第一级递归**：$\text{func}(n)$ 会调用 $\text{func}(n)$ 和 $\text{func}(n-1)$，因此它展开成了两个节点。
3. **第二级递归**：$\text{func}(n-1)$ 会继续调用 $\text{func}(n-1)$ 和 $\text{func}(n-2)$，而 $\text{func}(n)$ 也会继续展开成两个节点。

如此循环下去，每个递归调用会生成两个子调用，直到递归到达 $n == 0$ 为止。这个递归调用的结构看起来就像一棵 **二叉树**。

#### 计算递归树的节点数

每次递归都会生成两个子节点，因此总的调用数是一个指数级的增长。具体来说：

- 在第 0 层（根节点），有 $1$ 个调用 $\text{func}(n)$。
- 在第 1 层，会有 $2$ 个节点（$\text{func}(n)$ 和 $\text{func}(n-1)$）。
- 在第 2 层，会有 $4$ 个节点。
- 在第 3 层，会有 $8$ 个节点。

因此，总的递归调用次数是：

$$
2^0 + 2^1 + 2^2 + \dots + 2^n
$$

这个总和是一个等比数列，其和为：

$$
2^{n+1} - 1
$$

这意味着调用的总次数大约是 $2^n$ 的数量级，因此时间复杂度是 $O (2^n)$。

### 为什么是 `O(2^n)`？

由于递归树的每一层的节点数量是前一层的两倍，而整个树的深度为 $n$，因此总的节点数是 $O (2^n)$。这意味着随着输入 $n$ 的增加，计算的次数会呈指数级增长，从而导致算法的时间复杂度为 $O (2^n)$。

### 类比：如何理解指数增长

我们可以通过一个简单的类比来理解指数增长。

假设你有一个**泡泡机**，每次泡泡机会生成两个泡泡。每生成一个泡泡后，泡泡机再次生成两个泡泡，如此循环。假设你从一个泡泡开始：

- 第一次生成两个泡泡：$2$ 个
- 第二次生成的泡泡是前一次泡泡的两倍：$4$ 个
- 第三次生成的泡泡是前一次的两倍：$8$ 个

随着泡泡机的每一次操作，泡泡的数量翻倍，最后的泡泡数量将呈指数级增长。这和递归的过程非常类似，每次递归都会生成更多的子问题（泡泡），从而导致整个递归树的大小是指数级的。

### 总结

- $O (2^n)$ 表示的是指数复杂度。随着 $n$ 的增加，执行时间增长非常快。
- 递归算法中，特别是当每次递归都有多个子递归时，复杂度往往会是指数级的。
- 你提供的代码中，由于每次递归调用都有两个子调用，因此总的递归调用数是 $O (2^n)$。

### 你需要理解的相关概念：

1. **递归算法**：你需要理解递归是如何工作的，特别是如何分析递归调用的深度和广度。
2. **指数级增长**：理解指数增长的概念，知道每次增加一个单位，结果会成倍增加。
3. **递归树分析**：学会如何通过构建递归树来分析递归算法的时间复杂度。

