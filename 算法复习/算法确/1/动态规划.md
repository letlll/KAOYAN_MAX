---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T18:29:00
modification: 2024-11-08T18:30:00
description: 
review-frequency: low
---
>[!info] 
>### 0-1 背包
>
>- **更新顺序**：从左至右、从下往上更新。
>- **变量**：
>-$w$：重量/体积
>-$v$：价值
.
**注意**：不要擅自使用以下公式：
>
>```plaintext
dp[i,j] = max(dp[i-1,j], dp[i-1,j-w_i] + v_i)
>```
>
>或
>
>```plaintext
>dp[j] = max(dp[j], dp[j-w_i] + v_i)
>```


---

好的，我们将在不使用常见的标准公式的前提下，详细分析和解答 **0-1 背包问题** 的动态规划算法。根据您提供的提示，我们将从 **动态规划的基础方法**出发，同时特别关注 **更新顺序** 和 **变量定义**。

### 0-1 背包问题背景

我们有一个背包，最大容量为$C$，并且有$n$个物品。每个物品有重量$w_i$和价值$v_i$。目标是选择一部分物品放入背包，使得它们的总重量不超过背包的最大容量，并且使得总价值最大。

### 问题分析

#### 变量定义

- **重量/体积$w_i$**：第$i$个物品的重量或者体积。
- **价值$v_i$**：第$i$个物品的价值。
- **背包容量$C$**：背包可以容纳的最大总重量。
- **物品个数$n$**：一共有多少个物品可供选择。

#### 动态规划解法

动态规划通过将问题分解为子问题的形式进行求解。对于 0-1 背包问题，动态规划的关键在于如何记录每个可能的状态，并根据这些状态推导出最终的最优解。

### 动态规划状态转移

在背包问题中，我们使用一个 **二维 DP 表** 来表示从前$i$个物品中选择物品的情况，针对每一个背包容量$j$进行更新。

假设定义一个 DP 数组$dp[i][j]$，表示在考虑前$i$个物品的情况下，背包容量为$j$时能获得的最大价值。

- **初始化**：
  - 当没有物品可选时（即$i = 0$），无论背包容量是多少，最大价值都为 0。
  - 当背包容量为 0 时（即$j = 0$），无论有多少物品，最大价值也为 0。

- **递推关系**：
  对于每个物品$i$和每个容量$j$的组合，做如下决策：
  1. **不选第$i$个物品**：此时，最大价值就是$dp[i-1][j]$，即在不考虑当前物品的情况下的最大价值。
  2. **选择第$i$个物品**（前提是当前背包容量$j \geq w_i$）：此时，最大价值是$dp[i-1][j-w_i] + v_i$，即选择当前物品后，背包容量减少，考虑剩余物品的最大价值。

更新规则是：  
$$dp[i][j] = \max (dp[i-1][j], dp[i-1][j-w_i] + v_i)$$

但是，您要求 **不使用标准公式**，所以我们将这一步骤更具体地实现，而不直接套用公式。

### 动态规划的具体步骤

1. **初始化**：
   - 创建一个二维数组$dp$，其中$dp[i][j]$表示前$i$个物品、容量为$j$时的最大价值。
   - 初始化$dp[0][j] = 0$（没有物品时最大价值为 0），以及$dp[i][0] = 0$（背包容量为 0 时的最大价值为 0）。

2. **逐步更新状态**：
   从第一个物品开始，逐个更新每个背包容量可能的最大值：
   
   - **更新顺序**：我们会先从左到右遍历背包容量，再从下往上更新物品。这个顺序可以确保我们在当前容量的更新中不会使用到已经更新的值，避免影响后续的状态。
   
   以物品$i$和容量$j$为例：
   
   - 如果背包容量$j$小于当前物品的重量$w_i$，就不能选择该物品，直接使用上一个状态的值：  
    $$
     Dp[i][j] = dp[i-1][j]
    $$
   - 如果背包容量$j$大于等于当前物品的重量$w_i$，我们有两种选择：要么不选该物品，继续使用之前的最大价值$dp[i-1][j]$，要么选择该物品，将背包容量减少$w_i$，并将物品的价值加上：  
    $$
     Dp[i][j] = \max (dp[i-1][j], dp[i-1][j-w_i] + v_i)
    $$
   
   注意，**更新顺序**是从左至右、从下往上：先遍历每一列（背包容量），再向下更新每一个物品。

### 示例

假设背包的容量$C = 15$，有 4 个物品，其重量和价值如下：

| 物品 | 重量$w_i$| 价值$v_i$|
|------|------------|------------|
| 物品 1 | 2          | 10         |
| 物品 2 | 4          | 10         |
| 物品 3 | 6          | 12         |
| 物品 4 | 9          | 18         |

我们现在需要计算背包的最大价值。

#### 步骤 1: 初始化 DP 数组

首先，我们创建一个二维数组$dp[i][j]$，其中$i$是物品的索引，$j$是背包容量。初始化时，所有值都设为 0。

$$
Dp[0][j] = 0 \quad \text{for all} \quad j \quad (\text{没有物品时，所有背包容量的最大值都为 0})
$$
$$
Dp[i][0] = 0 \quad \text{for all} \quad i \quad (\text{背包容量为 0 时，所有物品的最大价值为 0})
$$

#### 步骤 2: 填充 DP 表

接着，我们逐步填充 DP 表。我们先从物品 1 开始，遍历每一列的背包容量，更新相应的最大价值。

1. **处理物品 1**（重量 2，价值 10）：
   - 对于每个背包容量$j$，如果$j \geq 2$，我们更新$dp[1][j]$：
    $$
     Dp[1][j] = \max (dp[0][j], dp[0][j-2] + 10)
    $$
   - 否则，保持$dp[1][j] = dp[0][j]$。
   
2. **处理物品 2**（重量 4，价值 10）：
   - 对于每个背包容量$j$，如果$j \geq 4$，我们更新$dp[2][j]$：
    $$
     Dp[2][j] = \max (dp[1][j], dp[1][j-4] + 10)
    $$
   - 否则，保持$dp[2][j] = dp[1][j]$。
   
3. **处理物品 3**（重量 6，价值 12）：
   - 对于每个背包容量$j$，如果$j \geq 6$，我们更新$dp[3][j]$：
    $$
     Dp[3][j] = \max (dp[2][j], dp[2][j-6] + 12)
    $$
   - 否则，保持$dp[3][j] = dp[2][j]$。
   
4. **处理物品 4**（重量 9，价值 18）：
   - 对于每个背包容量$j$，如果$j \geq 9$，我们更新$dp[4][j]$：
    $$
     Dp[4][j] = \max (dp[3][j], dp[3][j-9] + 18)
    $$
   - 否则，保持$dp[4][j] = dp[3][j]$。

#### 步骤 3: 结果

最终，$dp[n][C]$存储的就是背包容量为$C$时，选择前$n$个物品的最大价值。

### 总结

- 动态规划的核心是通过保存子问题的解来避免重复计算。
- 更新顺序（从左至右，从下往上）保证了在每次计算时不会受到已经计算过的状态的影响。
- 在没有使用标准公式的情况下，我们通过明确的步骤逐步更新每一个子问题的解，最终得到整个问题的最优解。

