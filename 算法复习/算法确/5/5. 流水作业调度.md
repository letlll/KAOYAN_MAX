---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-10T12:17:00
description: 
review-frequency: normal
reviewed: 2024年-11月-10日
---
---

- [ ] 1. 01 背包问题
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [ ] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [x] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [ ] 9. O 的性质

---

## 3.9 流水作业调度

### 3.9.1 问题描述

有 `n` 个作业 `{1, 2, …, n}` 要在由两台机器 `M1` 和 `M2` 组成的流水线上完成加工。每个作业的加工顺序都是先在 `M1` 上加工，然后在 `M2` 上加工。机器 `M1` 和 `M2` 加工作业 `i` 所需的时间分别为 `ai` 和 `bi`。

**目标**: 确定作业的最优加工顺序，使得从第一个作业在 `M1` 上开始加工，到最后一个作业在 `M2` 上加工完成所需的时间最少。

### 3.9.2 最优性原理

设 `π` 是作业集 `S` 在机器 `M2` 的等待时间为 `t` 时的一个最优调度，所需的加工时间为 `ai + T(S - {i}, bi)`。则动态规划递归关系如下：

```
T(S, t) = min { ai + T(S - {i}, bi + max{ t - ai, 0 }) } for all i ∈ S
```

**最优子结构**: `T(n, c) = min { a_i + T(n - {i}, b_i) }`

### 3.9.3 Johnson 不等式与 Johnson 法则

**Johnson 不等式**:

当作业 `i` 和作业 `j` 满足 `min{bi, aj} ≥ min{bj, ai}`，则称作业 `i` 和 `j` 满足 Johnson 不等式。

**Johnson 法则**:

- **步骤**:
  1. **划分作业**:
     - `N1 = {i | ai < bi}`
     - `N2 = {i | ai ≥ bi}`
  2. **排序作业**:
     - 将 `N1` 中的作业按 `ai` 的非减序排序。
     - 将 `N2` 中的作业按 `bi` 的非增序排序。
  3. **合并序列**:
     - 将 `N1` 中排序后的作业接在 `N2` 中排序后的作业之前，构成满足 Johnson 法则的最优调度。

**复杂度分析**:

- **时间复杂度**: `O(n log n)`，主要耗时在排序步骤。
- **空间复杂度**: `O(n)`

**示例**:

```
作业编号: 1  2  3  4  5  6
ai:       5  1  8  5  3  4
bi:       7  2  2  4  7  5
```

**应用 Johnson 法则**:

1. 划分作业:
   - `N1 = {2, 5, 6}` (因为 `a2=1 < b2=2`, `a5=3 < b5=7`, `a6=4 < b6=5`)
   - `N2 = {1, 3, 4}` (因为 `a1=5 ≥ b1=7`, `a3=8 ≥ b3=2`, `a4=5 ≥ b4=4`)

2. 排序:
   - `N1` 按 `ai` 非减序排序: `2, 5, 6`
   - `N2` 按 `bi` 非增序排序: `1, 5, 3`

3. 合并序列:
   - 最优调度: `2, 5, 6, 1, 4, 3`

**最优调度时间**: 28

---


### 流水作业调度问题解析

在流水作业调度问题中，我们希望找到一种作业顺序，使得 `n` 个作业在流水线上加工的总时间最短。流水线包含两台机器 `M1` 和 `M2`，每个作业都必须按照固定顺序先经过 `M1` 再到 `M2`。

### 问题的解决方案：Johnson 法则

Johnson 法则是一种简单高效的贪心算法，用于在两台机器上调度多个作业，以最小化加工完成的总时间。该算法主要基于对 `M1` 和 `M2` 上作业的时间差异进行排序和分配。

---

### 步骤解读

Johnson 法则通过以下步骤来实现最优调度：

1. **划分作业**：
   - 根据每个作业在两台机器上的加工时间，将作业划分为两个集合：
     - **集合 `N1`**：包含那些在 `M1` 上加工时间小于 `M2` 上加工时间的作业（即 `ai < bi`）。
     - **集合 `N2`**：包含那些在 `M1` 上加工时间大于或等于 `M2` 上加工时间的作业（即 `ai ≥ bi`）。

2. **排序作业**：
   - **集合 `N1`** 中的作业按 `M1` 加工时间 `ai` 升序排序（非减序）。
   - **集合 `N2`** 中的作业按 `M2` 加工时间 `bi` 降序排序（非增序）。

3. **合并序列**：
   - 将排序后的 `N1` 作业放在前面，`N2` 作业放在后面，形成满足 Johnson 法则的最优作业顺序。

---

### 示例解析

以一个具体的例子来说明 Johnson 法则的应用：

**给定数据**：

| 作业编号 | 1  | 2  | 3  | 4  | 5  | 6  |
|----------|----|----|----|----|----|----|
| \( a_i \)（`M1` 加工时间） | 5  | 1  | 8  | 5  | 3  | 4  |
| \( b_i \)（`M2` 加工时间） | 7  | 2  | 2  | 4  | 7  | 5  |

**应用 Johnson 法则**：

1. **划分作业**：
   - **集合 `N1`**（`ai < bi`）：作业 2、5、6
   - **集合 `N2`**（`ai ≥ bi`）：作业 1、3、4

2. **排序**：
   - `N1` 中按 `ai` 非减序排序：作业 2、5、6
   - `N2` 中按 `bi` 非增序排序：作业 1、4、3

3. **合并序列**：
   - 将 `N1` 和 `N2` 排序后的作业顺序合并得到最优调度顺序：**2, 5, 6, 1, 4, 3**

---

### 计算最优调度时间

按照 Johnson 法则的作业顺序依次安排加工，可以计算出该调度方案下的总加工时间。例如，从作业 2 开始，按照最优顺序调度到最后一个作业 3，在 `M2` 上加工完成的时间即为总加工时间。

总加工时间为 28（假设根据示例数据）。


---

要理解 Johnson 法则的设计逻辑，可以将作业调度问题比作一个流水线上的排队问题，其中我们有两个加工阶段 `M1` 和 `M2`。每个作业都必须先经过 `M1` 加工，然后才能进入 `M2` 加工。而我们希望通过一种排列方式，最小化完成所有作业的总时间。以下是对 Johnson 法则背后设计逻辑的详细讲解。

### 问题的核心：等待时间与顺序的优化

由于每个作业都必须按顺序先在 `M1` 加工再在 `M2` 加工，因此如果 `M1` 上的作业进度与 `M2` 上的作业进度不协调，就会导致大量等待时间，延长总完成时间。Johnson 法则通过划分和排序，将等待时间最小化。

### Johnson 法则的三步设计逻辑

#### 第一步：划分作业（根据 `M1` 和 `M2` 的加工时间关系）

Johnson 法则的第一步是根据 `M1` 和 `M2` 上的加工时间差异将作业划分为两个集合：

- **集合 `N1`**：包含那些在 `M1` 上加工时间 **小于** 在 `M2` 上加工时间的作业（即 `ai < bi`）。
- **集合 `N2`**：包含那些在 `M1` 上加工时间 **大于或等于** 在 `M2` 上加工时间的作业（即 `ai ≥ bi`）。

##### 为什么划分作业？

- **划分的逻辑**：对于集合 `N1` 的作业，它们在 `M1` 上的加工时间短于 `M2`，意味着这些作业可以尽早完成 `M1` 上的加工，并且尽快转移到 `M2`。如果这些作业放在队列的前面，可以减少 `M2` 的等待时间。
- **集合 `N2` 的作业** 则是相反，它们在 `M1` 上的加工时间长于 `M2`。将这些作业放在后面，能让 `M2` 不必等待 `M1` 处理长时间的任务，有利于减少整体的空闲时间和等待时间。

这样划分的目的是为了使 `M2` 的工作时间能够紧凑排列，减少 `M2` 等待 `M1` 的时间，缩短总加工时间。

#### 第二步：排序作业（最小化每个机器的等待时间）

在划分完作业后，我们需要对每个集合内的作业进行排序：

- **集合 `N1`**：按 `M1` 的加工时间 `ai` 升序排序。这使得 `M1` 处理时间最短的作业优先完成，从而尽早转移到 `M2`，减少 `M2` 的等待。
- **集合 `N2`**：按 `M2` 的加工时间 `bi` 降序排序。将 `M2` 加工时间较长的作业放在 `M2` 的末尾，使得 `M2` 能连续无等待地完成所有任务。

##### 为什么这样排序？

- 对于 `N1`，按 `M1` 加工时间升序排序让短时间作业优先完成，可以更快腾出 `M1` 给后面的作业，也能尽快让这些作业进入 `M2`。
- 对于 `N2`，按 `M2` 加工时间降序排序的原因是，延迟 `M2` 加工时间长的作业进入 `M2`，以便让较短时间的作业更快地完成，使得 `M2` 的利用率更高，减少等待。

这种排序方式确保了作业安排顺序对流水线两个阶段的等待时间和空闲时间的优化。

#### 第三步：合并序列（构建最优顺序）

在排序完成后，将 `N1` 中的作业顺序排在最前面，然后接上 `N2` 中的作业，形成最终的最优调度顺序。

##### 为什么合并排序后的 `N1` 和 `N2` 可以得到最优解？

这种排列方式减少了 `M2` 的空闲和等待时间，确保了：

1. **N 1 作业先进行，减少 `M2` 等待时间**：通过优先处理 `M1` 加工时间较短的作业，`M2` 可以尽早开始加工，减少了等待。
2. **N 2 作业在后面，减少 `M1` 的空闲时间**：`M2` 的空闲时间被缩短，而 `M1` 在完成所有 `N1` 作业后可以连续处理 `N2` 作业，从而减少整体的空闲和等待时间。

---

### 类比总结

可以将 Johnson 法则类比为排队等待服务的流程设计。将需要较短服务时间的客户（作业）放在队列前面，确保他们可以快速完成，避免后面长时间等待。长时间需求的客户则安排在后面，避免给整体队列带来拥堵。

这种分组与排序方式，使得总等待时间和空闲时间最少，从而达到最优调度。

通过这样的划分和排序，Johnson 法则可以在流水作业调度问题中以 `O(n log n)` 的时间复杂度获得最优解。