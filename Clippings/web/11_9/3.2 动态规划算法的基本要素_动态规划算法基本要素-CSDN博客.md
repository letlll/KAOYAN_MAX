---
title: "3.2 动态规划算法的基本要素_动态规划算法基本要素-CSDN博客"
source: "https://blog.csdn.net/tang7mj/article/details/130978237"
author:
published:
created: 2024-11-09
description: "文章浏览阅读1.7k次。最优子结构和重叠子问题是动态规划算法的核心要素。综上所述，这个不等式描述了递归函数 T(n) 的下界，即 T(n) 的计算代价至少是所有子问题 T(k) 和 T((n-k)+1) 计算结果之和，并加上一个常数项 1。然后我们考虑函数 T(n) 的计算过程，该过程依赖于两个子问题：T(k) 和 T((n-k)+1)，其中 k 的取值范围是从 1 到 n-1。1. 根据问题的定义和最优解的定义，斐波那契数列的第 n 项 F(n) 是通过计算第 n-1 项 F(n-1) 和第 n-2 项 F(n-2) 得到的。_动态规划算法基本要素"
tags:
  - "clippings"
---
## ![](https://i-blog.csdnimg.cn/blog_migrate/6956468929225490bf5f803a906ded37.gif)

---

- 博主简介：一个爱打游戏的计算机专业学生
- 博主主页： [@夏驰和徐策](https://blog.csdn.net/tang7mj?spm=1011.2266.3001.5343 "@夏驰和徐策")
- 所属专栏：[算法设计与分析](https://blog.csdn.net/tang7mj/category_12214693.html?spm=1001.2014.3001.5482 "算法设计与分析")

---

## 学习目标：

如果我要学习[动态规划算法](https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020)的基本要素，我会采取以下步骤：

1\. 理解概念：首先，我会研究动态规划算法的基本概念，了解[最优子结构](https://so.csdn.net/so/search?q=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020)和重叠子问题的含义，以及它们在动态规划算法中的作用。

2\. 阅读教材或学习资源：我会寻找优质的教材、[学术论文](https://so.csdn.net/so/search?q=%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87&spm=1001.2101.3001.7020)或在线教程，深入了解动态规划算法的基本要素。这些资源通常会提供详细的解释、示例和练习题，帮助我建立起对动态规划的理解。

3\. 学习经典问题：我会选择一些经典的动态规划问题，如背包问题、最长公共子序列、最短路径等，并尝试理解它们的最优子结构和重叠子问题。通过解决这些问题，我可以更好地理解动态规划算法的应用和原理。

4\. 分析算法思路：对于每个动态规划问题，我会仔细分析其解题思路。我会尝试找出问题的递推关系和状态转移方程，并思考如何定义合适的初始条件。这个过程通常需要一定的数学推理和逻辑思维。

5\. 编写代码并调试：一旦我理解了动态规划算法的思路，我会尝试将其转化为代码。我会编写相应的函数或程序来实现状态转移和备忘录等核心操作。然后，我会使用一些样例输入进行测试和调试，确保我的代码能够正确地解决问题。

6\. 练习和实践：学习动态规划算法需要不断的练习和实践。我会寻找更多的问题和练习题，尝试应用动态规划算法解决它们。通过不断的实践，我可以提高自己的理解和熟练度。

总的来说，学习动态规划算法的基本要素需要理论和实践相结合。通过深入学习概念，阅读相关资源，分析问题，编写代码并进行实践，我相信我可以掌握动态规划算法的基本要素，并在解决问题时运用它们。

![](https://i-blog.csdnimg.cn/blog_migrate/acc10505e9817f0bc6f7cea1f7740ee6.jpeg)

## 1.对于两个基本要素我的理解：

在动态规划算法中，最优子结构（Optimal Substructure）和重叠子问题（Overlapping Subproblems）是两个基本要素。

最优子结构是指一个问题的最优解可以通过一系列子问题的最优解来构建。换句话说，一个问题的最优解包含了其子问题的最优解。通过将问题分解为更小的子问题，并利用子问题的最优解来构建原问题的最优解，我们可以使用递归或迭代的方式求解动态规划问题。

重叠子问题是指在求解一个问题的过程中，我们会多次遇到相同的子问题。换句话说，同一个子问题会被多次计算。这种重复计算导致了低效性，因为我们可以利用已经计算过的子问题的解来避免重复计算。为了解决这个问题，动态规划算法使用一种称为"记忆化"的技术，即将已经计算过的子问题的解存储起来，下次需要时直接获取，避免重复计算。

## 2.二者的联系

最优子结构和重叠子问题是动态规划算法的核心要素。最优子结构提供了将问题分解为子问题的基础，而重叠子问题的存在则为我们提供了存储子问题解的机会，从而提高算法的效率。通过合理地定义最优子结构和识别重叠子问题，我们可以设计出高效的动态规划算法来解决各种问题。

 ![](https://i-blog.csdnimg.cn/blog_migrate/b8179deeef97a9d5e6b655412ef66dbe.jpeg)

##  3.如何证明最优子结构——反证法（这在我的思想库中有存储传送门：[夏驰和徐策的解决数学问题思路——反证法](https://blog.csdn.net/tang7mj/article/details/130541881?spm=1001.2014.3001.5501 "夏驰和徐策的解决数学问题思路——反证法")）  

###  基本思路：

要在数学语言中进行严格的证明，我们需要定义问题、引入符号和假设，并使用逻辑推理和数学原理来推导出结论。以下是一个用数学语言证明最优子结构的示例过程：

假设我们要证明问题P具有最优子结构。

1\. 定义问题P：清晰地描述问题P以及问题的输入和输出。

2\. 定义子问题：将问题P分解为更小的子问题，以及描述子问题的输入和输出。

3\. 定义最优解：明确定义问题P的最优解，并用数学符号表示。

4\. 假设最优子结构不成立：假设存在一个最优解，它无法通过子问题的最优解构建出来。

5\. 进行推理：使用逻辑推理和数学原理来推导出矛盾的结论。

   a. 基于问题P的定义和最优解的定义，说明最优解应该由子问题的最优解构建而成。

   b. 基于假设，说明存在一个解优于问题P的最优解，但无法由子问题的最优解构建。

   c. 利用数学原理、等式或不等式来推导出矛盾的结论。

6\. 得出结论：根据推理的结果，得出最优子结构成立的结论。

在这个过程中，关键是明确定义问题、子问题和最优解，并进行严格的逻辑推理。这样可以确保证明过程的准确性和严谨性。具体证明的形式和推理的步骤可能会因问题的具体性质而有所不同，但整体思路是类似的。

### 4.具体例子：

#### 案例1：斐波那契数列

当涉及到具体问题时，我可以给出一个示例来说明最优子结构的证明过程。让我们考虑一个经典的动态规划问题——斐波那契数列。

问题：给定一个正整数 n，求解斐波那契数列的第 n 项。

定义子问题：我们可以将问题分解为计算斐波那契数列的第 n-1 项和第 n-2 项。

定义最优解：令 F(n) 表示斐波那契数列的第 n 项。

假设最优子结构不成立：假设存在某个解 x，它在某些子问题上优于 F(n) 的最优解，但无法通过子问题的最优解构建。

**推理过程：**

1\. 根据问题的定义和最优解的定义，斐波那契数列的第 n 项 F(n) 是通过计算第 n-1 项 F(n-1) 和第 n-2 项 F(n-2) 得到的。

2\. 假设存在解 x，它在某些子问题上优于 F(n) 的最优解。假设 x 不通过计算 F(n-1) 和 F(n-2) 得到，而是通过其他方式获得。

3\. 基于斐波那契数列的递推关系，我们知道 F(n) = F(n-1) + F(n-2)。

4\. 如果解 x 在子问题 F(n-1) 上优于 F(n-1) 的最优解，那么 x 也必须在 F(n) 上优于 F(n) 的最优解。

5\. 同样地，如果解 x 在子问题 F(n-2) 上优于 F(n-2) 的最优解，那么 x 也必须在 F(n) 上优于 F(n) 的最优解。

6\. 由于我们假设 x 是一个优于 F(n) 的最优解，但无法通过子问题的最优解构建，这与斐波那契数列的递推关系和最优子结构的定义相矛盾。

7\. 因此，我们可以得出结论：最优子结构成立，即斐波那契数列的最优解可以通过子问题的最优解构建。

这个证明说明了斐波那契数列具有最优子结构的特性。根据这一特性，我们可以使用动态规划算法来高效地计算斐波那契数列的第 n 项。请注意，实际的证明过程可能更加详细和形式化，包括符号定义、等式推导和更严格的逻辑推理。这里的示例仅用于说明证明最优子结构的思路。

## 5.重叠子问题算法实现

```cpp
int RecurMatrixChain(int i,int j){if(i=j)return 0;int u=RecurMatrixChain(i,i)+RecurMatrixChain(i+1,j)+p[i-1]*p[i]*p[j];	s[i][j]=i;for(int k=i+1;k<j;k++)	{int t=RecurMatrixChain(i,k)+RecurMatrixChain(k+1,j)+p[i-1]*p[k]*p[j];if(t<u)		{			u=t;			s[i][j]=k;		}	}return u;}
```

## 6.我的理解：

这段代码是一个使用递归实现的矩阵链乘法的函数。让我逐行解释它的功能和实现细节：

1\. 函数名：RecurMatrixChain，表示递归求解矩阵链乘法的函数。

2\. 函数参数：i 和 j，表示矩阵链的起始索引和结束索引。

3\. 基本情况检查：如果起始索引 i 和结束索引 j 相等，表示只有一个矩阵，直接返回 0，表示乘法运算的代价为 0。

4\. 定义变量 u，并通过递归调用 RecurMatrixChain 函数来计算子问题 RecurMatrixChain(i, i) 和 RecurMatrixChain(i+1, j) 的解，并加上当前矩阵乘法操作的代价 p\[i-1\] \* p\[i\] \* p\[j\]。其中，p 数组存储了矩阵链中每个矩阵的维度信息。

5\. 更新 s\[i\]\[j\] 的值为 i，表示记录了乘法运算最优的划分位置，即在索引 k 处进行划分。

6\. 使用循环遍历索引 k，从 i+1 到 j-1，计算子问题 RecurMatrixChain(i, k) 和 RecurMatrixChain(k+1, j) 的解，并加上当前划分位置 k 的乘法代价 p\[i-1\] \* p\[k\] \* p\[j\]。将结果保存在变量 t 中。

7\. 检查变量 t 是否比之前的最优解 u 更小，如果是，则更新最优解 u 为 t，并更新 s\[i\]\[j\] 的值为 k，表示记录了更优的划分位置。

8\. 循环结束后，返回最优解 u。

这段代码实现了一个递归的矩阵链乘法算法，并利用动态规划中的最优子结构性质，通过递归求解子问题来得到最终的最优解。同时，通过记录划分位置 s\[i\]\[j\]，可以得到最优的矩阵链乘法划分方案。

##  7.不等式

**我的理解：**

这个不等式描述了递归函数 T(n) 的下界（lower bound），其中 n 表示输入的规模。

在不等式中，我们有 n > 1，表示问题的规模大于 1。然后我们考虑函数 T(n) 的计算过程，该过程依赖于两个子问题：T(k) 和 T((n-k)+1)，其中 k 的取值范围是从 1 到 n-1。

不等式中的求和符号 Σ 表示将 T(k) 和 T((n-k)+1) 的值累加起来，其中 k 的取值范围是 1 到 n-1。这表示我们对于每个 k，都需要计算 T(k) 和 T((n-k)+1) 并将它们相加。

根据不等式，我们知道 n > 1，因此至少有两个子问题需要求解。对于每个 k，我们假设已经计算了 T(k) 和 T((n-k)+1)。然后，我们将它们相加，并加上一个常数项 1，即 T(k) + T((n-k)+1) + 1。这个常数项 1 表示当前问题的计算代价。

最后，我们需要将这个计算过程应用于所有可能的 k 值，并将它们的计算结果相加。因此，不等式中的求和符号 Σ 表示将所有这些结果相加。

综上所述，这个不等式描述了递归函数 T(n) 的下界，即 T(n) 的计算代价至少是所有子问题 T(k) 和 T((n-k)+1) 计算结果之和，并加上一个常数项 1。这个不等式可以用来推导问题的复杂度，例如 O(n) 或 O(n log n)。

**怎么证明这个算法计算时间有指数下界（数学归纳法的具体介绍在这传送门：[夏驰和徐策的解决数学问题思路之——数学归纳法](https://blog.csdn.net/tang7mj/article/details/130733743?spm=1001.2014.3001.5501 "夏驰和徐策的解决数学问题思路之——数学归纳法")）**

要使用数学归纳法证明计算时间 T(n) >= 2^(n-1) = Ω(2^n)，我们需要遵循归纳法的步骤：

**步骤1: 基础情况（Base Case）**  
首先，我们需要证明当 n = 1 时不等式成立。也就是证明 T(1) >= 2^(1-1) = 2^0 = 1。

**步骤2: 归纳假设（Inductive Hypothesis）**  
假设不等式对于所有的 k < n 成立，即 T(k) >= 2^(k-1) 对于所有的 k < n 成立。

**步骤3: 归纳推理（Inductive Step）**  
现在我们需要证明不等式对于 n 也成立，即 T(n) >= 2^(n-1)。

根据给定的递归关系式 T(n) = Σ\[T(k) + T((n-k)+1)\]，其中 k 取值范围是从 1 到 n-1。

我们可以将 T(n) 拆分为两部分：T(n) = Σ\[T(k)\] + Σ\[T((n-k)+1)\]。

第一部分 Σ\[T(k)\] 的取值范围是从 k = 1 到 k = n-1，共有 n-1 个项。根据归纳假设，我们可以得到：  
Σ\[T(k)\] >= Σ\[2^(k-1)\]，其中 k 取值范围是从 k = 1 到 k = n-1。

这个等式的结果是 2^(n-1) - 1。因此，第一部分 Σ\[T(k)\] 的值至少是 2^(n-1) - 1。

第二部分 Σ\[T((n-k)+1)\] 的取值范围是从 k = 1 到 k = n-1，也有 n-1 个项。注意到 T((n-k)+1) 和 T(k) 具有相同的取值范围，只是索引不同。

因此，第二部分 Σ\[T((n-k)+1)\] 的值也至少是 2^(n-1) - 1。

综上所述，我们有 T(n) = Σ\[T(k)\] + Σ\[T((n-k)+1)\] >= (2^(n-1) - 1) + (2^(n-1) - 1) = 2^n - 2 >= 2^(n-1)。

这证明了不等式 T(n) >= 2^(n-1) 对于 n 成立。

因此，根据数学归纳法，我们可以得出结论：计算时间 T(n) >= 2^(n-1) = Ω(2^n)。

请注意，这个证明假设递归函数 T(n) 的定义和递归关系式是正确的，并且归纳假设也成立。在实际应用中，需要仔细验证递归函数和递归关系式的正确性。

![](https://i-blog.csdnimg.cn/blog_migrate/b8b4e41c5c3556b39f906311cbcc715f.jpeg)

##  8.动态规划递归方向——自底向上

当我们说动态规划算法是自底向上时，意味着我们从最小的子问题开始，逐步向上构建解决方案，直到达到原始问题。

具体来说，自底向上的过程通常涉及迭代和循环。我们首先解决最小的子问题，并将其解保存在一个表格或数组中。然后，我们利用这些已解决的子问题的结果来计算规模更大的子问题的解，并将其保存在表格中。通过不断迭代计算更大规模的子问题，我们最终得到了原始问题的解。

自底向上的方法通常以迭代的方式计算子问题的解，而不是使用递归。这是因为在自底向上的过程中，我们能够确保每个子问题的解都依赖于它所依赖的子问题的解。这样，我们可以按照正确的顺序计算和填充表格，而无需重复计算或依赖尚未计算的子问题。

总结起来，自底向上意味着我们从最小的子问题开始，通过迭代计算子问题的解，逐步构建出原始问题的解。这种方法通常比递归更高效，并能够有效地利用最优子结构和重叠子问题的特性。

## ![](https://i-blog.csdnimg.cn/blog_migrate/ac82cdfce6028ab302f996b139527b06.jpeg) 9.备忘录的递归顺序——自顶向下

## 10.备忘录方法

备忘录方法（Memoization）是动态规划算法中的一种优化技术，用于避免重复计算子问题。它通过将子问题的解存储在一个数据结构（通常是一个数组或哈希表）中，以便在需要时进行查找和重用。

备忘录方法的基本思想是将中间计算结果存储起来，以便在后续的计算中直接使用，而不必再次执行相同的计算。通过避免重复计算，备忘录方法可以显著提高算法的效率。

使用备忘录方法的步骤如下：

1\. 定义一个备忘录数据结构：根据问题的特点，选择合适的数据结构来存储子问题的解。通常情况下，可以使用数组或哈希表来存储中间结果。

2\. 初始化备忘录：在开始计算之前，将备忘录数据结构初始化为空，表示所有的子问题都尚未计算过。

3\. 在计算子问题时，首先检查备忘录中是否已经存在该子问题的解。如果已经存在，则直接从备忘录中获取解，避免重复计算。如果不存在，则进行计算，并将计算结果存储到备忘录中。

4\. 在整个计算过程中，每当需要计算一个子问题的解时，都先检查备忘录中是否存在，如果存在则直接返回结果，否则执行计算并将结果存入备忘录。

5\. 最终，当需要求解原始问题时，只需查找备忘录中存储的结果即可。

备忘录方法的核心思想是通过空间换时间，避免重复计算，减少算法的时间复杂度。它适用于具有重叠子问题性质的问题，例如斐波那契数列、图的最短路径等。

希望这个解释对您有所帮助。如有任何进一步的问题，请随时提问。

## 11.动态规划和备忘录时间复杂度

 **都是O(n^3)**

## 总结：

动态规划算法的基本要素包括以下几个方面：

1\. 最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导得出。换句话说，问题的整体最优解可以通过一系列子问题的最优解组合而成。

2\. 重叠子问题（Overlapping Subproblems）：问题可以被分解为若干相互重叠的子问题，这些子问题可以独立求解，并且它们的解可以被重复使用。通过保存子问题的解，可以避免重复计算，提高效率。

3\. 状态转移方程（State Transition Equation）：动态规划问题通常可以通过递推关系来描述。也就是说，问题的解可以通过已知的子问题的解来计算得出。这种递推关系被称为状态转移方程，用于定义问题的子问题之间的关系。

4\. 初始条件（Base Cases）：动态规划算法需要定义初始条件，也称为边界条件。这些条件是问题规模最小或最简单时的解决方法，通常是直接给出的。

5\. 问题的求解方向（Solving Direction）：动态规划算法可以根据问题的特点选择自顶向下（Top-down）或自底向上（Bottom-up）的求解方向。自顶向下的方法使用递归或回溯的方式，从问题的整体开始逐步解决子问题。自底向上的方法从子问题的解开始，逐步计算得到问题的整体解。

这些基本要素共同构成了动态规划算法的核心。通过合理地定义子问题、状态转移方程和初始条件，并选择合适的求解方向，可以高效地解决许多具有重叠子问题性质的问题。
