# 00509

9. 以下进程之间存在相互制约关系吗？若存在，是什么制约关系？为什么？

（1）       几个同学去图书馆借同一本书。

（2）       篮球比赛中两队同学抢篮板球。

（3）       果汁流水线生产中捣碎、消毒、罐装、装箱等各道工序。

（4）       商品的入库和出库。

（5）       工人做工和农民种粮。

（6）       多人（大于两人）来理发店找两个理发师理发。

答：（1）互斥，一本书只能由一人借

（2）       互斥，篮球比赛中篮球只能由一人持球

（3）       同步，流水线上各工序之间是顺序关系

（4）       同步，入库与出库之间是顺序关系

（5）       没关系

（6）       既同步又互斥，顾客来理发店与理发师理发是同步，多个顾客与两个理发师之间是互斥



### 问题分析与解答

我们可以逐一分析每个情况，确定进程之间是否存在制约关系，并给出具体的制约类型。制约关系通常可以分为以下几类：
- **互斥**：指多个进程（或对象）不能同时使用某个共享资源。即在同一时刻，只有一个进程能访问该资源。
- **同步**：指两个或多个进程需要按某种顺序（如先后）执行，通常是由于某个条件或资源的共享。
- **无关**：指进程之间不存在任何制约关系。

### (1) 几个同学去图书馆借同一本书

#### 制约关系：**互斥**

- 这类情况涉及一个共享资源（图书馆中的书），多个进程（同学）争抢同一本书。在同一时刻，书只能由一个同学借走，因此其他同学需要等到书归还才能借到。这是一种**互斥**关系。

### (2) 篮球比赛中两队同学抢篮板球

#### 制约关系：**互斥**

- 在篮球比赛中，篮板球只能由一个队员抢到。尽管两个队的队员都在争抢同一个篮板球，但同一时刻只有一人能够获得它。因此，这也形成了**互斥**关系。

### (3) 果汁流水线生产中捣碎、消毒、罐装、装箱等各道工序

#### 制约关系：**同步**

- 在生产流水线中，各道工序的执行顺序是固定的。例如，捣碎必须在消毒之前完成，消毒必须在罐装之前完成，罐装后才能进行装箱。这些工序之间有明确的顺序要求，属于**同步**关系。

### (4) 商品的入库和出库

#### 制约关系：**同步**

- 商品的入库和出库通常是顺序关系。入库必须先于出库，不能同时进行，因为商品的存储和流动是有顺序要求的。因此，这也是一种**同步**关系。

### (5) 工人做工和农民种粮

#### 制约关系：**无关**

- 工人做工与农民种粮之间通常没有直接的制约关系。工人做工是为了获取工资，而农民种粮则是为了生产粮食，两者互不干扰，也没有时间或资源上的直接依赖，因此这两者之间**无关**。

### (6) 多人（大于两人）来理发店找两个理发师理发

#### 制约关系：**既同步又互斥**

- **同步**：多个顾客到理发店理发时，顾客之间的理发是同步进行的，即需要按顺序轮流理发。
- **互斥**：理发店只有两个理发师，因此多个顾客和两个理发师之间存在互斥关系。只有两个顾客能同时得到理发师服务，其余顾客必须等待。

---

### 总结
- **(1) 同学借书**：互斥
- **(2) 篮球比赛**：互斥
- **(3) 流水线工序**：同步
- **(4) 入库和出库**：同步
- **(5) 工人做工与农民种粮**：无关
- **(6) 理发店理发**：既同步又互斥

这些制约关系帮助我们理解在不同场景下资源的分配和执行的顺序，尤其是在并发控制和系统设计中非常重要。

---

# 00501

### 问题分析

这个问题是一个经典的同步问题，涉及到信号量的使用来控制并发进程之间的同步与互斥。这里描述了一个售票厅的情况，要求在最多能容纳 20 名购票者的前提下进行同步控制。

我们可以通过信号量来管理购票者进入和离开售票厅的过程，保证每次进入的人数不超过 20，且超出的人数需要在外面等待。

### 解答

#### （1）定义信号量

首先，需要定义一个信号量来控制进入售票厅的购票者数量。

- **信号量 `full`**：用来表示售票厅中的空余位置数目。初始时，信号量 `full` 为 20，表示售票厅最多可以容纳 20 名购票者。
  
  - 当 `full` 的值大于 0 时，表示有空位可以让外面的购票者进入。
  - 当 `full` 的值为 0 时，表示售票厅已满，不能再有购票者进入。
  - 当 `full` 的值小于 0 时，表示外面有等候的购票者数量，`|full|` 就是等候的购票者数目。

**信号量的初值：**
```text
Semaphore full = 20;
```

**信号量的取值含义：**
- `0 < full < 20`：售票厅中有 `(20 - full)` 名购票者，剩余 `full` 个空位。
- `full = 0`：售票厅已满，不能再容纳购票者。
- `full < 0`：表示外面有等候的购票者数量，等候者的数量为 `|full|`。

#### （2）P、V 操作管理进程

根据所定义的信号量，我们使用 P（wait）和 V（signal）操作来确保购票者的正确并发执行。

- **P 操作**（wait）：表示尝试进入售票厅，如果售票厅有空位（`full > 0`），则购票者可以进入，并将 `full` 减 1。如果售票厅满了（`full == 0`），购票者需要等待。
  
- **V 操作**（signal）：表示购票者离开售票厅，释放一个空位，使得其他等候的人可以进入，因此将 `full` 加 1。

**进程描述：**
```text
Process Customeri {
    P(full);   // 等待一个空位
    // 进入售票厅
    // 进行购票等操作
    V(full);   // 离开售票厅，释放一个空位
}
```

- 每个购票者尝试进入售票厅时，会执行 `P(full)`，如果有空位，进入售票厅并进行购票。
- 购票结束后，执行 `V(full)`，释放一个空位，允许其他等候的购票者进入。

#### （3）信号量的变化范围

在这种情况下，信号量的最大值和最小值由售票厅的容量和外面等候购票者的数量决定。

- **最大值**：信号量 `full` 的最大值是 20，表示售票厅完全空闲，可以容纳 20 个购票者。
  
- **最小值**：信号量 `full` 的最小值是 `-(n - 20)`，其中 `n` 是外面等候购票者的数量。如果有 `n` 个购票者等候，`full` 将变为负数，且其绝对值等于外面等候的购票者人数。

**信号量的变化范围：**
```text
(20 - n) <= full <= 20
```

这里，`20 - n` 是最小值，表示所有位置都已经被占用，外面有 `n` 名购票者在等候，而 20 是最大值，表示售票厅为空，所有 20 个位置都没有被占用。

### 总结

1. **信号量定义**：  
   `full = 20`，表示售票厅的空位数，`full` 的值变化反映了售票厅的占用情况。

2. **P、V 操作**：  
   进程 `Customeri` 在进入售票厅时执行 `P(full)`，在离开时执行 `V(full)`，以管理售票厅的空位。

3. **信号量变化范围**：  
   信号量 `full` 的取值范围是 `(20 - n) ≤ full ≤ 20`，其中 `n` 是外面等候购票者的数量。

通过这种方式，我们使用信号量和 P、V 操作成功地管理了购票者进入和离开的过程，保证了并发控制的正确性。




1. 某车站售票厅，任何时刻最多可容纳 20 名购票者进入，当售票厅中少于 20 名购票者时，厅外的购票者可立即进入，否则需在外面等待。若把一个购票者看作一个进程，请回答下列问题：

(1) 用 PV 操作管理这些并发进程时，应怎样定义信号量，写出信号量的初值以及信号量各种取值的含义。

(2) 根据所定义的信号量，使用 P、V 操作保证进程能够正确地并发执行。

(3) 若欲购票者最多为 n 个人，写出信号量可能的变化范围 (最大值和最小值)。

答：（1）

>[!question] 
>请你列举一个实例进行说明。

Semaphore full=20;                                    

**信号量的取值含义：**
- `0 < full < 20`：售票厅中有 `(20 - full)` 名购票者，剩余 `full` 个空位。
- `full = 0`：售票厅已满，不能再容纳购票者。
- `full < 0`：表示外面有等候的购票者数量，等候者的数量为 `|full|`。  

（2）

>[!question] 
>不理解这个代码的含义，我需要如何去记忆和理解这个代码，请你使用类比进行说明。

```text
Process Customeri {
    P(full);   // 等待一个空位
    // 进入售票厅
    // 进行购票等操作
    V(full);   // 离开售票厅，释放一个空位
}
```

（3）

(20-n) ≤ full ≤ 20      

>[!question] 
>不理解这个 20-n 的意义，以及这个式子的作用。

---
---

### 回答问题 (1)

#### 信号量的定义与初值

我们将这个问题中的售票厅和购票者类比为一个资源有限的系统，进程（购票者）需要访问共享资源（售票厅的空位）。为了管理并发进程的执行，我们引入信号量来控制“空位”的数量。

**信号量 `full`：**

- `full` 是一个信号量，用来表示售票厅中剩余空位的数量。初始值是 20，表示一开始售票厅是空的，最多可以容纳 20 名购票者。
- **初值：**  
  `Semaphore full = 20;`

**信号量的取值含义：**

- `0 < full < 20`：表示售票厅里有 `(20 - full)` 名购票者，剩余的 `full` 个空位可以让新的购票者进入。
- `full = 0`：表示售票厅已满，不能再有更多的购票者进入。
- `full < 0`：表示有外面等待购票的人数，`|full|` 就是等候的人数。信号量的负值代表外面排队等待的购票者数量。

### 问题 (2) —— 类比与理解代码

这部分代码描述了一个进程（购票者）如何通过信号量来管理进入售票厅的行为。我们可以通过以下类比来帮助理解：

#### 类比：停车场的管理

假设售票厅就是一个停车场，停车场最多可以容纳 20 辆车。每辆车进出停车场时，都需要遵循停车场的管理规则。

- 信号量 `full` 就是“剩余车位”数。
- 每辆车在进入停车场时，首先查看是否有空余车位（通过信号量 `P(full)`）。
  - 如果有空位，车子进入停车场，并减少一个空位（`full` 减 1）。
  - 如果没有空位，车子就停在停车场外面等待。
- 每辆车在离开停车场时，释放一个空位（`V(full)`），表示停车场的车位数增加一个。

#### 对应的代码：

```text
Process Customeri {  // 每个购票者是一个进程
    P(full);   // 等待一个空位，类似车子进入停车场前确认是否有空位
    // 购票操作，类似停车场中停车的过程
    V(full);   // 离开售票厅，释放一个空位，类似车子离开停车场后空出车位
}
```

- `P(full)`：相当于车子进入停车场时，首先检查是否有空位。如果没有空位，车子就得停下来等待。
- `V(full)`：车子离开时，释放一个车位，允许其他等待的车子进入。

### 问题 (3) —— 理解 `20 - n` 的意义

这个式子 `20 - n` 是信号量 `full` 变化的最小值，它描述了外面等待的人数。

#### 解释：

- **`full` 的取值范围：**  
  信号量 `full` 的最大值是 20，表示售票厅完全空闲，没有任何人占用。信号量的最小值是 `20 - n`，表示外面有 `n` 个人等待进场，售票厅已经没有空位。

- **`20 - n` 的意义：**
  - 假设 `n` 是外面等候的人数，那么 `20 - n` 就表示售票厅中空余的位数。
  - **当外面没有等候者时，`n = 0`，所以 `full = 20`**。
  - **当外面有 `n` 名购票者在等候时，`full = 20 - n`**，即售票厅的空位数已经减少，外面等待的购票者数为 `|full|`。

#### 数学意义：

- **最大值 `full = 20`**：表示没有人等待，售票厅是完全空闲的。
- **最小值 `full = 20 - n`**：表示外面有 `n` 个购票者在等待，这时 `full` 为负数，且其绝对值等于等待的购票者数量。

**例子：**
1. 如果 `n = 5`（外面有 5 个购票者在等待），那么 `full = 15`，表示售票厅还有 15 个空位。
2. 如果 `n = 0`（外面没有购票者等待），那么 `full = 20`，表示售票厅完全空闲。

### 总结

- **信号量的初值：** `Semaphore full = 20;`，表示售票厅最多可以容纳 20 人。
- **P、V 操作的类比：** 类似停车场管理车位，进程（购票者）进入时检查是否有空位，离开时释放空位。
- **`20 - n` 的意义：** 表示外面等待的人数，`full` 的取值范围从 `20 - n` 到 20。

---

# 00502

2. 设正在处理器上执行的一个进程的页表如表 4 所示。页表的页号和物理块号是十进制数，起始页号 (块号) 均为 0；所有的地址均是存储器字节地址，页的大小为 1024 字节。（注：状态位表示该页是否在内存，1—在，0—不在；）下列逻辑地址对应什么物理地址：(1) 5499； (2) 2221；表 4

|     |     |     |     |      |
| --- | --- | --- | --- | ---- |
| 页号  | 状态位 | 访问位 | 修改位 | 物理块号 |
| 0   | 1   | 1   | 0   | 4    |
| 1   | 1   | 1   | 1   | 7    |
| 2   | 0   | 0   | 0   | ---  |
| 3   | 1   | 0   | 0   | 2    |
| 4   | 0   | 0   | 0   | ---  |
| 5   | 1   | 0   | 1   | 0    |

答：（1）5499/1024=5 余数为 379，故页号为 5（查页表得对应物理块号为 0，页内地址为

379，物理地址=0*1024+379=379 

（2）2221/1024=2 余数为 173，故页号为 2，页内地址为 173，查页表得 2 号页对应物理块号为空，即 2 号页不在内存中，所以物理地址不存在。



---

# 00503

3. 有一矩阵 int` A[100][100]` ；以行为优先进行存储。计算机采用虚拟存储系统，物理内存共有 3 块，其中一块存放程序，其余两块存放数据。假设程序已在内存中占一块, 其余两块空闲。

|   |   |
|---|---|
|程序 A:<br><br>for（ i=0; i<100;i++） for(j=0；j<100;j++)<br><br>A[i][j]=0;|程序 B:<br><br>for（ j=0; j<100;j++） for(i=0；i<100;i++)<br><br>A[i][j]=0;|

若每块可存放 200 个整数，程序 A 和程序 B 的执行过程各会发生多少次缺页？若每页只能存放 100 个整数呢？以上说明了什么问题？答: (1) 每个主存块的大小可以存放 200 个数组元素，有两个内存块可以用来存放数组信息，数组中的元素按行编址。显然，对于程序 A，数组的存储顺序与访问顺序一致，每访问两行数组遇到一次缺页中断，共产生 50 次缺页中断；对于程序 B，数组的存储顺序（按行的顺序）与访问顺序（按列的顺序）不一致，每访问两个数组元素遇到一次缺页中断，共会产生

5000 次缺页中断。

(2) 若每页只能存放 100 个整数，对于程序 A，数组的存储顺序与访问顺序一致，每访问一行数组遇到一次缺页中断，会产生 100 次缺页中断。对于程序 B，数组的存储顺序（按行的顺序）与访问顺序（按列的顺序）不一致，每访问一个数组元素遇到一次缺页中断，会产生

10000 次缺页中断。

以上结果说明：1. 缺页的次数与内存中数据存放的方式及程序的执行顺序有很大关系。

2. 当缺页中断的次数不多时，减小页面的大小对缺页次数的影响不大；但当缺页中断的次数很多时，减小页面的大小对缺页次数有很严重的影响。



在虚拟存储系统中，缺页中断（Page Fault）发生在程序访问的内存页不在主存时，需要从磁盘中加载对应的页到主存。缺页中断的次数受程序的数据访问模式（顺序）和内存的页面大小等因素的影响。通过本题中的程序 A 和程序 B，我们可以通过不同的页面大小来分析缺页中断次数的变化。

### 问题分析：

- **矩阵 `A[100][100]`** 表示一个 100 x 100 的二维数组，每个元素为 `int` 类型，假设每个 `int` 占 4 字节。
- 该数组有 100 x 100=10,000 个元素，总大小为 `10000 * 4 = 40,000` 字节。
- 在程序 A 和程序 B 中，内存存储顺序和访问顺序对缺页次数的影响是非常大的。

### 情境 1：每块内存可存放 200 个整数

- 每个内存块大小：200 个 `int`，即 `200 * 4 = 800` 字节。
- 数据矩阵 A 中的元素按行优先存储，这意味着 `A[0][0]`, `A[0][1]`, ..., `A[0][99] `被连续存储在内存中。每块可以容纳 200 个整数，所以 A 的每行需要占据两块内存（每行有 100 个整数）。一共需要 100 行，因此共有 50 个内存块用于存放数据。

#### 程序 A：

- **程序 A** 中，访问矩阵时，按行访问，即 `A[i][j]`。因为数组是按行存储的，程序 A 和数据存储顺序一致，所以每访问完两行就会发生一次缺页中断。
- 共有 100 行，每访问 2 行发生一次缺页中断，总共需要进行 50 次缺页中断。

#### 程序 B：

- **程序 B** 中，访问矩阵时，按列访问，即 `A[j][i]`。由于数组是按行存储的，而程序按列访问，这就导致每次访问一个元素都需要加载一个新的页（内存块）。由于每个内存块可以存储 200 个整数，程序 B 每访问 2 个整数（即两个元素在同一列中）就会导致缺页中断。
- 程序 B 总共需要访问 100 x 100=10,000 个元素，而每访问 2 个元素触发一次缺页中断，因此总共会发生 5000 次缺页中断。

### 情境 2：每页可存放 100 个整数

- 每页的大小：100 个 `int`，即 `100 * 4 = 400` 字节。
- 数据矩阵 A 中的元素按行优先存储，因此每行的 100 个元素需要占据一个内存页。

#### 程序 A：

- **程序 A** 中，访问矩阵时，按行访问。由于每行正好对应一个页，所以每访问一行就会发生一次缺页中断。
- 共有 100 行，每访问一行触发一次缺页中断，因此总共会发生 100 次缺页中断。

#### 程序 B：

- **程序 B** 中，访问矩阵时，按列访问。由于数据按行存储，而程序按列访问，每访问一个元素都需要加载一个新的页。程序 B 需要访问 100 x 100=10,000 个元素，每访问一个元素触发一次缺页中断，因此总共会发生 10,000 次缺页中断。

### 结果总结：

1. **每块存放 200 个整数：**
   - **程序 A** 的缺页中断次数：**50 次**
   - **程序 B** 的缺页中断次数：**5000 次**

2. **每页存放 100 个整数：**
   - **程序 A** 的缺页中断次数：**100 次**
   - **程序 B** 的缺页中断次数：**10,000 次**

### 分析与结论：

- **缺页次数与数据存储顺序及程序访问顺序的关系：**
  - 程序 A 按行访问数据，与内存中数据的行优先存储顺序一致，因此缺页中断次数较少。
  - 程序 B 按列访问数据，而内存中数据是按行存储的，这使得程序 B 在访问时频繁发生缺页中断，因为每次访问的数据块不连续。
  
- **页面大小对缺页次数的影响：**
  - 当每个页面较大时（如每块存放 200 个整数），程序 A 的缺页次数较少，因为程序 A 和数据存储顺序一致，访问时的数据能够尽可能地在一个页面内找到。
  - 当页面较小时（如每页存放 100 个整数），程序 B 的缺页次数大大增加，因为每访问一个元素就需要加载一个新的页面，造成了极高的缺页次数。

- **总结：**
  - 数据存储方式和程序的访问方式对缺页中断的次数有重要影响。
  - 在内存页较大时，程序的访问顺序和数据的存储顺序越一致，缺页中断次数就越少。
  - 当页面较小且程序的访问方式与存储方式不一致时，缺页中断的次数会显著增加。

这也突出了一个系统设计的要点：**内存页面的大小选择**与程序的访问模式之间的匹配性至关重要，合理的页面大小能够显著降低缺页中断的次数，提高程序的执行效率。

---

# 00504

4. 假设目前有 6 个读写磁盘的请求如表 5 所示：表 5

|   |   |   |   |
|---|---|---|---|
|请求次序|柱面号|磁头号|扇区号|
|1|180|7|1|
|2|30|7|2|
|3|12|9|10|
|4|40|2|1|
|5|35|4|8|
|6|90|9|11|

假定当前移动臂位置在 20 号柱面，移动方向是向大于 20 号柱面的方向移动。试问：

（1）       采用电梯调度算法（scan），上述请求的访问次序为何？ 

（2）       如果所有请求的柱面号相同，上述请求的最短寻道时间优先（sstf）次序为何？  答：（1）2,5,4,6,1,3    

（2）3,2,5,4,6,1     



### 题目分析与解答

在这个问题中，我们有 6 个磁盘访问请求，并且要求使用两种调度算法来确定磁头的访问顺序：**电梯调度算法（Scan）** 和 **最短寻道时间优先（SSTF）**。

#### 1. 电梯调度算法（Scan）

**电梯调度算法（Scan）** 的工作原理是：磁头沿着一个方向移动，直到到达磁盘的一端，然后反转方向并开始向相反的方向移动，访问请求。由于磁头当前的位置在柱面 20 上，并且移动方向是向大于 20 的方向（即向高柱面方向），我们就可以按照电梯算法的规则来确定访问次序。

#### 步骤：
- 当前磁头的位置：柱面 20
- 移动方向：向大于 20 的方向移动。

请求的柱面号分别是：
- 请求 1：180
- 请求 2：30
- 请求 3：12
- 请求 4：40
- 请求 5：35
- 请求 6：90

**按柱面号排序后：**
- 12, 30, 35, 40, 90, 180

根据电梯调度算法，磁头首先沿着当前方向（向大于 20 的方向）移动，直到到达最后的请求柱面，然后反向处理剩余的请求。

- 从柱面 20 开始，磁头会处理 30、35、40、90、180（沿着大柱面方向依次访问这些请求）。
- 完成后，磁头会反向移动，访问剩余的请求 12。

因此，访问顺序是：**2, 5, 4, 6, 1, 3**。

**答案：**
（1）电梯调度算法（Scan）的访问次序是 **2, 5, 4, 6, 1, 3**。

#### 2. 最短寻道时间优先（SSTF）

**最短寻道时间优先（SSTF）** 调度算法的工作原理是：每次选择距离当前磁头位置最近的请求来访问。磁头每次选择离当前位置最近的柱面进行访问，从而尽量减少寻道时间。

#### 步骤：
- 当前磁头的位置：柱面 20
- 请求的柱面号分别是：12, 30, 35, 40, 90, 180

**计算每个请求的距离**（当前磁头位置为柱面 20）：
- 请求 1：180，距离 160
- 请求 2：30，距离 10
- 请求 3：12，距离 8
- 请求 4：40，距离 20
- 请求 5：35，距离 15
- 请求 6：90，距离 70

首先，选择距离柱面 20 最近的请求：
- 距离 20 最近的是请求 3，柱面号为 12。

接着，从柱面 12 开始，计算剩余请求的距离：
- 请求 3：12，已访问
- 请求 2：30，距离 18
- 请求 5：35，距离 23
- 请求 4：40，距离 28
- 请求 6：90，距离 78
- 请求 1：180，距离 168

选择距离 12 最近的是请求 2，柱面号为 30。

从柱面 30 开始，计算剩余请求的距离：
- 请求 2：30，已访问
- 请求 5：35，距离 5
- 请求 4：40，距离 10
- 请求 6：90，距离 60
- 请求 1：180，距离 150

选择距离 30 最近的是请求 5，柱面号为 35。

从柱面 35 开始，计算剩余请求的距离：
- 请求 5：35，已访问
- 请求 4：40，距离 5
- 请求 6：90，距离 55
- 请求 1：180，距离 145

选择距离 35 最近的是请求 4，柱面号为 40。

从柱面 40 开始，计算剩余请求的距离：
- 请求 4：40，已访问
- 请求 6：90，距离 50
- 请求 1：180，距离 140

选择距离 40 最近的是请求 6，柱面号为 90。

从柱面 90 开始，计算剩余请求的距离：
- 请求 6：90，已访问
- 请求 1：180，距离 90

最后，选择请求 1，柱面号为 180。

因此，访问顺序是：**3, 2, 5, 4, 6, 1**。

**答案：**
（2）最短寻道时间优先（SSTF）的访问次序是 **3, 2, 5, 4, 6, 1**。

---

### 总结：
- **电梯调度算法（Scan）**：磁头按一个方向移动，直到到达磁盘的一端，再反向处理请求。执行时根据请求的柱面顺序确定访问顺序。
- **最短寻道时间优先（SSTF）**：每次选择距离当前磁头位置最近的请求进行处理，从而减少寻道时间。

通过这两个算法的比较，我们可以看出，电梯调度算法更加系统地按照方向处理请求，而 SSTF 更加注重每次选择当前最接近的请求来减少磁头移动的距离。

---

# 00505

5. 有两个用户进程 A 和 B, 在运行过程中都要使用系统中的一台打印机输出计算结果.

(1)    试说明 A, B 两进程之间存在什么样的制约关系 

(2)    为保证这两个进程能正确地打印出各自的结果, 请用信号量和 P, V 操作写出各自的有关申请, 使用打印机的代码. 要求给出信号量的含义和初值. 

答：(1) A, B 两进程之间存在互斥制约关系. 因为打印机属于临界资源, 必须一个进程使用完之后另一个进程才能使用.

(2) mutex: 用于互斥的信号量, 因为只有一台打印机, 所以初值为

|   |   |
|---|---|
|进程 A|进程 B|
|......<br><br>P (mutex);<br><br>使用打印机;<br><br>V (mutex);<br><br>……|......<br><br>P (mutex);<br><br>使用打印机;<br><br>V (mutex);<br><br>……|



### 题目分析与解答

#### (1) A 和 B 两进程之间的制约关系

在这个问题中，进程 A 和进程 B 都需要访问同一台打印机来输出计算结果。由于打印机是**共享资源**且只能被一个进程在同一时间使用，因此这两个进程之间存在**互斥制约关系**。

- **互斥制约关系**：由于打印机是一种临界资源（即同一时刻只能被一个进程访问），所以进程 A 和进程 B 在访问打印机时不能同时进行。也就是说，一个进程必须等到另一个进程完成对打印机的使用之后，才能继续使用打印机。

这种互斥性要求我们使用一些同步机制来控制两个进程的执行，确保打印机在任何时刻都只能被一个进程使用。

#### (2) 使用信号量和 P、V 操作来控制打印机的访问

为了保证打印机资源能够按照正确的顺序和互斥地被两个进程使用，我们可以引入一个互斥信号量（`mutex`）来控制访问打印机的过程。

- **信号量的含义和初值**：
  - `mutex`：这个信号量用于控制进程对打印机的访问，它的初值为 1，表示初始时打印机是空闲的，可以被任意一个进程访问。
  - `mutex` 的值会在每次进程请求打印机时被修改，确保只有一个进程可以在同一时刻使用打印机。

- **P 和 V 操作的使用**：
  - **P 操作**（或称为 `wait` 操作）：当进程 A 或 B 要使用打印机时，它首先执行 `P(mutex)` 操作，这会尝试将信号量 `mutex` 的值减 1。如果 `mutex` 的值为 0，表示打印机当前被另一个进程占用，那么请求的进程将被挂起，直到打印机变为空闲。
  - **V 操作**（或称为 `signal` 操作）：当进程 A 或 B 使用完打印机后，它执行 `V(mutex)` 操作，这会将 `mutex` 的值加 1，表示打印机空闲，可以被其他进程使用。

#### 代码实现：

我们可以为进程 A 和进程 B 编写如下代码，确保它们正确地申请和释放打印机：

```text
// 定义互斥信号量，初值为 1
Semaphore mutex = 1;

// 进程 A 的代码
Process A {
    // 请求打印机
    P(mutex);            // 进入临界区，获取打印机
    // 使用打印机进行输出
    // ......
    // 释放打印机
    V(mutex);            // 离开临界区，释放打印机
}

// 进程 B 的代码
Process B {
    // 请求打印机
    P(mutex);            // 进入临界区，获取打印机
    // 使用打印机进行输出
    // ......
    // 释放打印机
    V(mutex);            // 离开临界区，释放打印机
}
```

#### 解释：
- **P (mutex)**：每个进程在使用打印机之前会执行这个操作。此操作会检查信号量 `mutex`，如果 `mutex` 为 1，进程就可以进入临界区并开始使用打印机。如果 `mutex` 为 0，表示打印机正在被另一个进程占用，当前进程会被阻塞，直到信号量 `mutex` 变为 1（即打印机空闲）。
- **V (mutex)**：每个进程在完成打印任务后都会执行这个操作。此操作将信号量 `mutex` 加 1，表示打印机已空闲，其他等待的进程可以继续进入临界区使用打印机。

### 总结：

1. **制约关系**：进程 A 和进程 B 之间有互斥制约关系，因为它们共享一台打印机，不能同时使用。
2. **信号量控制**：我们使用一个互斥信号量 `mutex` 来控制对打印机的访问。初始值为 1，确保在任何时刻只有一个进程可以使用打印机。
3. **P 和 V 操作**：通过 `P(mutex)` 和 `V(mutex)` 来实现对打印机的互斥访问，确保正确的同步和互斥控制。

这个例子展示了如何使用信号量来管理进程之间的资源竞争，保证资源的正确共享和同步。

---

# 00506

6. 现有一作业，在段式存储管理的系统中已为主存分配了如表所示的段表。

|   |   |   |
|---|---|---|
|段号|段长|主存起始地址|
|0|700|1780|
|1|180|1020|
|2|220|1580|
|3|910|2820|
|4|1500|1650|

计算该作业访问[0,600],[1,400],[2,286],[3,755][4,960]时的绝对地址。（方括号中第一个元素为段号，第二个元素为段内地址）。

答：(1) [0,600]：因为 600＜700，所以绝对地址＝1780+600＝2380。

(2)    [1,400]：因为 400＞180，所以该逻辑地址越界，系统发出“越界中断”。

(3)    [2,286]：因为 286＞220，所以该逻辑地址越界，系统发出“越界中断”。

(4)    [3,755]：因为 755＜910，所以绝对地址＝2820+755＝3575。

(5)    [4,960]：因为 960＜1500，所以绝对地址＝1650+960＝2610。



### 问题分析与解答

在段式存储管理中，每个段都可以有不同的长度，并且每个段在主存中的起始地址也不同。段表记录了每个段的长度和起始地址。为了计算给定段和段内地址的绝对地址，我们需要通过以下步骤进行：

1. **确定段号的合法性**：检查访问的段号是否有效，如果段号超过了段表中的范围，则会产生越界中断。
2. **检查段内地址是否有效**：如果段内地址超过了该段的长度，也会产生越界中断。
3. **计算绝对地址**：如果上述两项都没有问题，计算绝对地址的公式为：
   $$
   \text{绝对地址} = \text{段起始地址} + \text{段内地址}
   $$

### 给定段表

| 段号 | 段长 | 主存起始地址 |
|------|------|--------------|
| 0    | 700  | 1780         |
| 1    | 180  | 1020         |
| 2    | 220  | 1580         |
| 3    | 910  | 2820         |
| 4    | 1500 | 1650         |

### 对每个逻辑地址进行计算

1. **访问 [0,600]**：
   - 段号为 0，段长为 700，段内地址为 600。
   - 因为 600 < 700（在段内地址范围内），所以可以计算绝对地址。
   - 绝对地址 = 1780 + 600 = 2380。

2. **访问 [1,400]**：
   - 段号为 1，段长为 180，段内地址为 400。
   - 因为 400 > 180（超过了该段的长度），所以该逻辑地址越界。
   - 系统会发出“越界中断”。

3. **访问 [2,286]**：
   - 段号为 2，段长为 220，段内地址为 286。
   - 因为 286 > 220（超过了该段的长度），所以该逻辑地址越界。
   - 系统会发出“越界中断”。

4. **访问 [3,755]**：
   - 段号为 3，段长为 910，段内地址为 755。
   - 因为 755 < 910（在段内地址范围内），所以可以计算绝对地址。
   - 绝对地址 = 2820 + 755 = 3575。

5. **访问 [4,960]**：
   - 段号为 4，段长为 1500，段内地址为 960。
   - 因为 960 < 1500（在段内地址范围内），所以可以计算绝对地址。
   - 绝对地址 = 1650 + 960 = 2610。

### 总结

1. **[0,600]**：绝对地址 = 2380
2. **[1,400]**：越界中断
3. **[2,286]**：越界中断
4. **[3,755]**：绝对地址 = 3575
5. **[4,960]**：绝对地址 = 2610

### 关键点

- **越界中断**：当段内地址超过该段的实际长度时，系统会发生“越界中断”，这意味着该访问请求无效。
- **计算绝对地址**：当段号和段内地址合法时，我们通过段的起始地址和段内地址相加，得到逻辑地址对应的物理内存地址。

这种方式是段式存储管理中的典型地址转换过程，其中段号和段内地址被映射到实际的物理内存地址。

---

# 00507

7. 在一个采用页式虚拟存储管理的系统中, 有一用户作业, 它依次要访问的地址序列是: 115,228,120,88,446,102,321,432,260,167, 若该作业的第 0 页已经装入主存, 现分配给该作业的主存共 300 B, 页的大小为 100 B, 请回答下列问题: 

(1) 页面请求序列。

(2) 按 FIFO 调度算法将产生 (  ) 次缺页中断, 依次淘汰的页号为 (  ) ,缺页中断率为 (  ) . 

(3) 按 LRU 调度算法将产生 (  ) 次缺页中断, 依次淘汰的页号为 (  ) ,缺页中断率为 (  ) .  答：

(1) 根据地址序列求出页面访问序列：

115/100=1，228/100=2，120/100=1，88/100=0，446/100=4，102/100=1，321/100=3，432/100=4， 260/100=2，167/100=1。故页面访问序列为：1，2，1，0，4，1，3，4，2，1. 

(2) 按 FIFO 调度算法将产生 5 次缺页中断（1 分） ;依次淘汰的页号为: 0,1,2;  缺页中断率为: 5/10=50%

(2) 按 LRU 调度算法将产生 6 次缺页中断（1 分）; 依次淘汰的页号为: 2,0,1,3;  缺页中断率为: 6/10=60%



### 问题解析与解答

给定的条件是：
- 页面大小：100 B
- 主存总大小：300 B
- 页式虚拟存储管理
- 已装入主存的第 0 页
- 访问的地址序列：115, 228, 120, 88, 446, 102, 321, 432, 260, 167

我们将根据这个条件回答以下问题：

---

### (1) 页面请求序列

首先，我们要根据给定的地址序列，计算出每个地址对应的页面号。通过页面大小（100 B）可以确定每个地址所属的页面。具体方法是将地址除以页面大小，得到该地址对应的页面号。

**计算过程：**
- 地址 115 属于第 1 页（115 ÷ 100 = 1）
- 地址 228 属于第 2 页（228 ÷ 100 = 2）
- 地址 120 属于第 1 页（120 ÷ 100 = 1）
- 地址 88 属于第 0 页（88 ÷ 100 = 0）
- 地址 446 属于第 4 页（446 ÷ 100 = 4）
- 地址 102 属于第 1 页（102 ÷ 100 = 1）
- 地址 321 属于第 3 页（321 ÷ 100 = 3）
- 地址 432 属于第 4 页（432 ÷ 100 = 4）
- 地址 260 属于第 2 页（260 ÷ 100 = 2）
- 地址 167 属于第 1 页（167 ÷ 100 = 1）

因此，页面请求序列为：
**1, 2, 1, 0, 4, 1, 3, 4, 2, 1**

---

### (2) 按 FIFO 调度算法

FIFO（先进先出）调度算法的基本思想是：当主存中没有足够的空间来加载新页面时，选择最早进入主存的页面进行替换。

**步骤：**
1. 初始化主存为空，开始访问页面。
2. 主存能容纳 3 页，因为主存总大小为 300 B，每页大小 100 B。
3. 页面请求序列依次访问：1, 2, 1, 0, 4, 1, 3, 4, 2, 1。
4. 使用 FIFO 算法进行页面替换。

**页面访问过程（FIFO）：**
- 初始主存：[ ]
- 访问页面 1，缺页中断，加载页 1 → 主存：[1]
- 访问页面 2，缺页中断，加载页 2 → 主存：[1, 2]
- 访问页面 1，已在主存中，不缺页。
- 访问页面 0，缺页中断，加载页 0 → 主存：[1, 2, 0]
- 访问页面 4，缺页中断，替换最早的页（页 1），加载页 4 → 主存：[2, 0, 4]
- 访问页面 1，缺页中断，替换最早的页（页 2），加载页 1 → 主存：[0, 4, 1]
- 访问页面 3，缺页中断，替换最早的页（页 0），加载页 3 → 主存：[4, 1, 3]
- 访问页面 4，已在主存中，不缺页。
- 访问页面 2，缺页中断，替换最早的页（页 4），加载页 2 → 主存：[1, 3, 2]
- 访问页面 1，已在主存中，不缺页。

**总结：**
- 总共产生了 5 次缺页中断。
- 依次淘汰的页号为：0, 1, 2。
- 缺页中断率 = 5 / 10 = **50%**。

---

### (3) 按 LRU 调度算法

LRU（最近最少使用）调度算法的基本思想是：当主存中没有足够的空间来加载新页面时，选择最久未被使用的页面进行替换。

**步骤：**
1. 初始化主存为空，开始访问页面。
2. 主存能容纳 3 页，因为主存总大小为 300 B，每页大小 100 B。
3. 页面请求序列依次访问：1, 2, 1, 0, 4, 1, 3, 4, 2, 1。
4. 使用 LRU 算法进行页面替换。

**页面访问过程（LRU）：**
- 初始主存：[ ]
- 访问页面 1，缺页中断，加载页 1 → 主存：[1]
- 访问页面 2，缺页中断，加载页 2 → 主存：[1, 2]
- 访问页面 1，已在主存中，不缺页。
- 访问页面 0，缺页中断，加载页 0 → 主存：[1, 2, 0]
- 访问页面 4，缺页中断，替换最久未使用的页（页 1），加载页 4 → 主存：[2, 0, 4]
- 访问页面 1，缺页中断，替换最久未使用的页（页 2），加载页 1 → 主存：[0, 4, 1]
- 访问页面 3，缺页中断，替换最久未使用的页（页 0），加载页 3 → 主存：[4, 1, 3]
- 访问页面 4，已在主存中，不缺页。
- 访问页面 2，缺页中断，替换最久未使用的页（页 1），加载页 2 → 主存：[3, 2, 4]
- 访问页面 1，缺页中断，替换最久未使用的页（页 3），加载页 1 → 主存：[2, 4, 1]

**总结：**
- 总共产生了 6 次缺页中断。
- 依次淘汰的页号为：2, 0, 1, 3。
- 缺页中断率 = 6 / 10 = **60%**。

---

### 总结

1. **页面请求序列**：1, 2, 1, 0, 4, 1, 3, 4, 2, 1
2. **FIFO 调度算法**：
   - 缺页中断次数：5
   - 淘汰的页号：0, 1, 2
   - 缺页中断率：50%
3. **LRU 调度算法**：
   - 缺页中断次数：6
   - 淘汰的页号：2, 0, 1, 3
   - 缺页中断率：60%



---

# 00508

8. 某系统有 R 1, R 2, R 3 共 3 种资源，在 T 0 时刻 P 1, P 2, P 3, P 4 这 4 个进程对资源的占用和需求如下，系统的可用资源向量为（2，1，2）

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|进程||最大需求|   ||占有量||
|R 1|R 2|R 3|R 1|R 2|R 3|
|P 1|3|2|2|1|0|0|
|P 2|6|1|3|4|1|1|
|P 3|3|1|4|2|1|1|
|P 4|4|2|2|0|0|2|

（1）将系统中各种资源的总和及此刻各进程对资源的需求数目用向量或矩阵表示出来。（2）如果此时 P 1 和 P 2 均发出资源请求向量（1，0，1），为了保持系统安全性，应如何分配资源给这两个进程。答：

（1）       各类资源总和: [R 1, R 2, R 3]=[ 9,3,6] 各进程对资源的需求数目: 

  2  2  2

  2  0  2

1  0  3 

4  2  0  

（2）       当将资源分配给 P 1 后，需求矩阵为：

1     2  1

2     0  2

1  0  3

4  2  0 

系统可利用资源为：1  1  1  故此时不存在安全序列，系统处于不安全状态，所以 P 1 进程的资源请求不能满足。

当将资源分配给 P 2 后，需求矩阵为：

2  2  2

1  0  1

1  0  3

4  2  0

系统可利用资源为：1  1  1 故此时存在安全序列 P 2, P 3, P 4, P 1，所以 P 2 进程的资源请求可以满足。



### 问题分析与解答

给定的条件：
- 资源类型：R 1, R 2, R 3（共三种资源）
- 系统的可用资源向量为：**[2, 1, 2]**
- 4 个进程对资源的最大需求和当前占有量如下表所示：

| 进程   | 最大需求 (R 1, R 2, R 3) | 占有量 (R 1, R 2, R 3) |
|--------|----------------------|-------------------|
| P 1     | 3, 2, 2               | 1, 0, 0           |
| P 2     | 6, 1, 3               | 4, 1, 1           |
| P 3     | 3, 1, 4               | 2, 1, 1           |
| P 4     | 4, 2, 2               | 0, 0, 2           |

### (1) 系统中各种资源的总和及此刻各进程对资源的需求数目

#### 资源总和

资源总和就是系统中每种资源的总量。可以通过每个进程的最大需求量和占有量来求得。

- **资源 R 1 总量**：  
  $\text{总需求} = 3 + 6 + 3 + 4 = 16$  
  $\text{总占有} = 1 + 4 + 2 + 0 = 7$  
  $\text{总量} = \text{总需求} = 16$ （因为总量就是最大需求量的上限）

- **资源 R 2 总量**：  
  $\text{总需求} = 2 + 1 + 1 + 2 = 6$  
  $\text{总占有} = 0 + 1 + 1 + 0 = 2$  
  $\text{总量} = 6$

- **资源 R 3 总量**：  
  $\text{总需求} = 2 + 3 + 4 + 2 = 11$  
  $\text{总占有} = 0 + 1 + 1 + 2 = 4$  
  $\text{总量} = 11$

因此，**系统中各种资源的总和**为：
$$
[R 1, R 2, R 3] = [9, 3, 6]
$$

#### 各进程对资源的需求数目

每个进程的需求数目是其最大需求减去已占有的资源量。可以通过以下公式计算：

- P 1 的需求：
  $$
  \text{需求} = \text{最大需求} - \text{占有量} = (3, 2, 2) - (1, 0, 0) = (2, 2, 2)
  $$

- P 2 的需求：
  $$
  \text{需求} = \text{最大需求} - \text{占有量} = (6, 1, 3) - (4, 1, 1) = (2, 0, 2)
  $$

- P 3 的需求：
  $$
  \text{需求} = \text{最大需求} - \text{占有量} = (3, 1, 4) - (2, 1, 1) = (1, 0, 3)
  $$

- P 4 的需求：
  $$
  \text{需求} = \text{最大需求} - \text{占有量} = (4, 2, 2) - (0, 0, 2) = (4, 2, 0)
  $$

所以，**各进程对资源的需求数目**的矩阵为：
$$
\begin{bmatrix}
2 & 2 & 2 \\
2 & 0 & 2 \\
1 & 0 & 3 \\
4 & 2 & 0
\end{bmatrix}
$$

---

### (2) 资源请求分配

#### 情况：P 1 和 P 2 向系统请求资源向量 (1, 0, 1)

我们需要首先分析分配资源后的系统状态，并验证系统是否处于安全状态。

##### 资源请求分配给 P 1

- P 1 请求的资源为 (1, 0, 1)。
- 在给 P 1 分配资源后，P 1 的占有量将变为：  
  $\text{新占有量} = (1 + 1, 0 + 0, 0 + 1) = (2, 0, 1)$
- P 1 的新需求将变为：  
  $\text{新需求} = (2 - 2, 2 - 0, 2 - 1) = (0, 2, 1)$

系统可用资源将变为：
- 可用资源 = 当前可用资源 - 分配给 P 1 的资源  
  $\text{新可用资源} = (2, 1, 2) - (1, 0, 1) = (1, 1, 1)$

#### 判断系统是否处于安全状态

在 P 1 请求资源后，系统的可用资源变为 (1, 1, 1)，我们需要判断是否存在一个安全序列，即进程能按顺序执行且不会发生死锁。

- **P 1**：需求 (0, 2, 1)，已占用 (2, 0, 1)，缺少 (0, 2, 1)。  
  可用资源为 (1, 1, 1)，不足以满足 P 1 的需求，因此系统进入不安全状态，无法满足 P 1 的请求。

##### 资源请求分配给 P 2

- P 2 请求的资源为 (1, 0, 1)。
- 在给 P 2 分配资源后，P 2 的占有量将变为：  
  $\text{新占有量} = (4 + 1, 1 + 0, 1 + 1) = (5, 1, 2)$
- P 2 的新需求将变为：  
  $\text{新需求} = (6 - 5, 1 - 1, 3 - 2) = (1, 0, 1)$

系统可用资源将变为：
- 可用资源 = 当前可用资源 - 分配给 P 2 的资源  
  $\text{新可用资源} = (2, 1, 2) - (1, 0, 1) = (1, 1, 1)$

#### 判断系统是否处于安全状态

- **P 2**：需求 (1, 0, 1)，已占用 (5, 1, 2)，缺少 (1, 0, 1)，系统可用资源满足 P 2 的需求，P 2 可以执行完毕并释放资源。
- **P 3**：P 3 的需求为 (1, 0, 3)，系统可以分配资源给 P 3，P 3 执行完毕并释放资源。
- **P 4**：P 4 的需求为 (4, 2, 0)，系统可以分配资源给 P 4，P 4 执行完毕并释放资源。
- **P 1**：P 1 执行完毕后，系统的可用资源恢复，可以满足 P 1 的需求。

因此，存在安全序列 **P 2 → P 3 → P 4 → P 1**，系统处于安全状态，P 2 的资源请求可以满足。

### 总结

1. **各类资源总和**：\([R 1, R 2, R 3] = [9, 3, 6]\)
2. **各进程的资源需求**：
$$
\begin{bmatrix}
2 & 2 & 2 \\
2 & 0 & 2 \\
1 & 0 & 3 \\
4 & 2 & 0
\end{bmatrix}
$$
3. **P 1 和 P 2 请求资源**：
   - P 1 的资源请求无法满足，系统进入不安全状态。
   - P 2 的资源请求可以满足，系统处于安全状态，安全序列为 P 2 → P 3 → P 4 → P 1。