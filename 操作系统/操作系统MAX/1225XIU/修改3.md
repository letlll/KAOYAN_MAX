您好！感谢您提供详细的代码和问题描述。根据您提供的C++代码和现有的Java代码，我将帮助您修改Java代码的文件读取函数，以确保它们与C++代码的逻辑一致，并修正可能导致错误的问题。

## **问题概述**

您目前在Java中实现了以下文件读取函数：

1. `readProcess` - 读取 `Process.txt` 文件，加载进程信息。
2. `loadRunTimes` - 读取 `run.txt` 文件，加载程序的运行时间。
3. `readRun` - 读取 `runSteps.txt` 文件，加载运行步骤。
4. `readProgramDetails` - 读取 `program.txt` 文件，加载程序详细信息。

然而，您遇到了读取文件时的错误。经过对比C++代码和Java代码，我发现以下几点需要调整：

1. **文件内容和结构的对应关系**：确保Java代码读取的文件内容和C++代码预期的一致。
2. **数据解析逻辑的对齐**：确保Java代码中的解析逻辑与C++代码中的一致，尤其是在提取字段和处理逻辑方面。
3. **错误处理和调试信息**：增强Java代码的错误处理和调试输出，以便更容易定位问题。

下面，我将逐一对比C++代码和Java代码，提供相应的修正建议和代码示例。

## **1. 加载运行时间 (`loadRunTimes` 对应 `loadRunTimes`)**

### **C++ 代码分析**

C++ `loadRunTimes` 函数读取 `run.txt`，提取每个程序的最终运行时间。具体步骤：

- 打开 `run.txt` 文件。
- 遍历每一行：
    - 如果行以 "程序名"、"ProgramName" 或 "program" 开头，提取程序名称。
    - 否则，解析时间戳和操作类型。
    - 如果操作为 "结束" 或 "End"，记录该程序的运行时间为时间戳的最大值。
- 返回 `runTimes` 映射。

### **Java 代码修正**

您的Java `loadRunTimes` 函数基本上与C++逻辑一致，但可以做一些优化和增强调试信息。以下是修正后的Java代码：

```java
// 加载 run.txt 中的运行时间
private static Map<String, Integer> loadRunTimes(String filename) {
    Map<String, Integer> runTimes = new HashMap<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

        while ((line = br.readLine()) != null) {
            line = trim(line);
            if (line.isEmpty()) continue;

            // 跳过表头（假设第一行是表头）
            if (isFirstLine) {
                // 判断是否为表头，可以根据实际文件内容调整
                if (line.contains("ProgramName") || line.contains("程序名")) {
                    isFirstLine = false;
                    continue;
                }
            }

            // 检测是否为程序名行
            if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                    System.out.println("Found Program Name: [" + currentProgram + "]"); // Debug info
                } else {
                    System.err.println("警告: 无法提取程序名称: " + line);
                }
                continue;
            }

            // 解析时间戳和操作类型
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                continue;
            }

            int timestamp;
            String operation;
            try {
                timestamp = Integer.parseInt(parts[0]);
                operation = parts[1];
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                continue;
            }

            if (operation.equals("结束") || operation.equals("End")) {
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: 未指定当前程序名称，无法记录运行时间。");
                    continue;
                }
                int existingTime = runTimes.getOrDefault(currentProgram, 0);
                runTimes.put(currentProgram, Math.max(existingTime, timestamp));
                System.out.println("Set final run time for [" + currentProgram + "] to " + timestamp + " ms"); // Debug info
            }
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
    return runTimes;
}

// 辅助函数：去除字符串两端的空白字符
private static String trim(String str) {
    return str == null ? "" : str.trim();
}
```

### **关键点说明**

- **表头处理**：假设 `run.txt` 的第一行是表头，根据需要跳过。
- **程序名行检测**：根据行首是否包含 "程序名"、"ProgramName" 或 "program" 来检测程序名称行。
- **调试信息**：添加了 `System.out.println` 以输出找到的程序名称和设置的运行时间，便于调试。
- **错误处理**：增强了对异常和格式错误的处理，避免程序崩溃。

## **2. 读取运行步骤 (`loadRunSteps` 对应 `readRun`)**

### **C++ 代码分析**

C++ `loadRunSteps` 函数读取 `run.txt`，提取每个程序的页面访问序列和运行时间。具体步骤：

- 打开 `run.txt` 文件。
- 遍历每一行：
    - 如果行以 "ProgramName"、"程序" 开头，提取程序名称。
    - 否则，解析时间、操作和参数。
    - 如果操作为 "结束" 或 "End"，记录程序的最终运行时间。
    - 如果操作为 "Jump" 或 "跳转"，记录跳转地址。
- 输出加载的运行时间和页面访问序列。

### **Java 代码修正**

您的Java `readRun` 函数试图读取 `runSteps.txt`，但根据C++代码逻辑，应该是从 `run.txt` 读取运行步骤。因此，需要确保Java代码读取正确的文件，并与C++逻辑一致。

假设 `runSteps.txt` 与 C++ 的 `run.txt` 有不同的功能，您可能需要重新调整Java代码以匹配C++的逻辑。

以下是修正后的Java `readRun` 函数，假设它应读取 `run.txt` 文件：

```java
// 运行步骤结构体
static class RunSteps {
    Map<String, Integer> runTimes; // 程序的运行时间
    Map<String, List<Integer>> pageSequences; // 程序的页面访问序列

    RunSteps() {
        runTimes = new HashMap<>();
        pageSequences = new HashMap<>();
    }
}

// 读取 run.txt 文件，加载运行步骤
private static RunSteps loadRunSteps(String filename) {
    RunSteps runSteps = new RunSteps();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

        while ((line = br.readLine()) != null) {
            line = trim(line);
            if (line.isEmpty()) continue;

            // 跳过表头（假设第一行是表头）
            if (isFirstLine) {
                // 判断是否为表头，可以根据实际文件内容调整
                if (line.contains("ProgramName") || line.contains("程序名")) {
                    isFirstLine = false;
                    continue;
                }
                isFirstLine = false; // 如果没有表头，也不再跳过
            }

            // 检测是否为程序名行
            if (line.startsWith("ProgramName") || line.startsWith("程序")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                    System.out.println("Found Program Name: [" + currentProgram + "]"); // Debug info
                } else {
                    System.err.println("警告: 无法提取程序名称: " + line);
                }
                continue;
            }

            // 解析时间、操作和参数
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                continue;
            }

            int timestamp;
            String operation;
            String param = "";
            try {
                timestamp = Integer.parseInt(parts[0]);
                operation = parts[1];
                if (parts.length >= 3) {
                    param = parts[2];
                }
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                continue;
            }

            if (operation.equals("结束") || operation.equals("End")) {
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: 未指定当前程序名称，无法记录运行时间。");
                    continue;
                }
                int existingTime = runSteps.runTimes.getOrDefault(currentProgram, 0);
                runSteps.runTimes.put(currentProgram, Math.max(existingTime, timestamp));
                System.out.println("Set final run time for [" + currentProgram + "] to " + timestamp + " ms"); // Debug info
                continue;
            }

            if (operation.equals("Jump") || operation.equals("跳转")) {
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: 未指定当前程序名称，无法记录跳转地址。");
                    continue;
                }
                if (!param.isEmpty()) {
                    try {
                        int address = Integer.parseInt(param);
                        runSteps.pageSequences.computeIfAbsent(currentProgram, k -> new ArrayList<>()).add(address / pageSize);
                        System.out.println("Added Jump Address " + address + " to [" + currentProgram + "]"); // Debug info
                    } catch (NumberFormatException e) {
                        System.err.println("警告: 无法解析跳转地址: " + param + " 在行: " + line);
                    }
                } else {
                    System.err.println("警告: 缺少跳转地址在行: " + line);
                }
                // 更新运行时间
                runSteps.runTimes.put(currentProgram, Math.max(runSteps.runTimes.getOrDefault(currentProgram, 0), timestamp));
                System.out.println("Updated run time [" + currentProgram + "]: " + timestamp + " ms"); // Debug info
            } else {
                // 其他操作可以根据需要扩展
                System.out.println("Info: Unhandled operation [" + operation + "] in line: " + line);
                // 更新运行时间
                runSteps.runTimes.put(currentProgram, Math.max(runSteps.runTimes.getOrDefault(currentProgram, 0), timestamp));
                System.out.println("Updated run time [" + currentProgram + "]: " + timestamp + " ms"); // Debug info
            }
        }

        // 输出加载的运行时间
        System.out.println("\nLoaded Run Times:");
        for (Map.Entry<String, Integer> entry : runSteps.runTimes.entrySet()) {
            System.out.println("Program: [" + entry.getKey() + "], Run Time: " + entry.getValue() + " ms"); // Debug info
        }

        // 输出加载的页面访问序列
        System.out.println("Loaded Page Sequences:");
        for (Map.Entry<String, List<Integer>> entry : runSteps.pageSequences.entrySet()) {
            System.out.print("Program: [" + entry.getKey() + "], Pages: ");
            for (int page : entry.getValue()) {
                System.out.print(page + " ");
            }
            System.out.println();
        }

    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
    return runSteps;
}
```

### **关键点说明**

- **文件对应性**：确保读取的是正确的文件（根据C++逻辑，应为 `run.txt`）。
- **页面访问序列**：根据C++代码，跳转地址应转换为页面号（`address / pageSize`）。
- **调试信息**：添加了更多的 `System.out.println` 以输出处理的过程，便于调试。
- **错误处理**：增强了对缺少程序名称和跳转地址的处理，避免空指针异常。
- **数据结构**：引入了 `RunSteps` 类，以更好地组织运行时间和页面访问序列。

## **3. 读取程序详细信息 (`loadPrograms` 对应 `readProgramDetails`)**

### **C++ 代码分析**

C++ `loadPrograms` 函数读取 `program.txt`，提取每个程序的函数名称和大小。具体步骤：

- 打开 `program.txt` 文件。
- 遍历每一行：
    - 如果行以 "FileName" 开头，提取程序名称。
    - 否则，解析函数名称和大小。
- 返回程序详细信息的映射。

### **Java 代码修正**

您的Java `readProgramDetails` 函数需要与C++逻辑对齐。以下是修正后的Java代码：

```java
// 读取 program.txt 文件，加载程序详细信息
private static Map<String, Map<String, Double>> loadPrograms(String filename) {
    Map<String, Map<String, Double>> programs = new HashMap<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        boolean isFirstLine = true; // 标记是否为第一行

        while ((line = br.readLine()) != null) {
            if (isFirstLine) {
                // 检测并移除 BOM
                if (line.length() >= 3 &&
                    (line.charAt(0) & 0xFF) == 0xEF &&
                    (line.charAt(1) & 0xFF) == 0xBB &&
                    (line.charAt(2) & 0xFF) == 0xBF) {
                    line = line.substring(3);
                }
                isFirstLine = false;
            }

            // 打印读取的行及其长度以进行调试
            System.out.println("Reading line: [" + line + "], Length: " + line.length()); // Debug info

            line = trim(line);
            if (line.isEmpty()) continue; // 跳过空行

            // 检测是否为 FileName 行
            if (line.startsWith("FileName") || line.startsWith("FName") || line.startsWith("program")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                    programs.put(currentProgram, new HashMap<>());
                    System.out.println("Found Program: [" + currentProgram + "]"); // Debug info
                } else {
                    System.err.println("警告: 无法提取程序名称: " + line);
                }
                continue;
            }

            // 确保存在当前程序名
            if (currentProgram.isEmpty()) {
                System.err.println("警告: 在程序名称之前发现函数定义: " + line);
                continue;
            }

            // 解析函数名称和大小
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                continue;
            }

            String funcName = parts[0];
            double size;
            try {
                size = Double.parseDouble(parts[1]);
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析函数大小: " + line);
                continue;
            }

            programs.get(currentProgram).put(funcName, size);
            System.out.println("Added Function [" + funcName + "] Size " + size + " KB to Program [" + currentProgram + "]"); // Debug info
        }

    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
    return programs;
}
```

### **关键点说明**

- **文件对应性**：确保读取的是 `program.txt`，与C++逻辑一致。
- **程序名称行检测**：根据行首是否包含 "FileName"、"FName" 或 "program" 来检测程序名称行。
- **调试信息**：添加了 `System.out.println` 以输出找到的程序和添加的函数，便于调试。
- **BOM处理**：处理了可能存在的BOM（字节顺序标记），避免解析错误。
- **数据结构**：返回 `Map<String, Map<String, Double>>`，即程序名称映射到函数名称和大小的映射。

## **4. 读取进程信息 (`loadProcesses` 对应 `readProcess`)**

### **C++ 代码分析**

C++ `loadProcesses` 函数读取 `process.txt`，加载进程信息。具体步骤：

- 打开 `process.txt` 文件。
- 遍历每一行：
    - 如果行以 "ProcessName" 或 "程序" 开头，提取进程名称。
    - 否则，解析进程的创建时间、优先级和关联的程序名称。
    - 根据关联的程序名称，从 `runTimes` 获取运行时间。
    - 创建并添加 `Process` 对象到 `processList`。
- 输出加载的运行时间和页面访问序列。

### **Java 代码修正**

您的Java `readProcess` 函数需要与C++逻辑对齐。以下是修正后的Java代码：

```java
// 读取 Process.txt 文件，加载进程信息
private static void loadProcesses(String filename, Map<String, Integer> runTimes) {
    System.out.println("\nLoaded Run Times:");
    for (Map.Entry<String, Integer> entry : runTimes.entrySet()) {
        System.out.println("Program: [" + entry.getKey() + "], Run Time: " + entry.getValue() + "ms"); // Debug info
    }

    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

        while ((line = br.readLine()) != null) {
            if (isFirstLine) {
                // 检测并移除 BOM
                if (line.length() >= 3 &&
                    (line.charAt(0) & 0xFF) == 0xEF &&
                    (line.charAt(1) & 0xFF) == 0xBB &&
                    (line.charAt(2) & 0xFF) == 0xBF) {
                    line = line.substring(3);
                }
                isFirstLine = false;
                // 假设第一行是表头，如果需要可以进一步验证
                continue;
            }

            // 打印读取的行及其长度以进行调试
            System.out.println("Reading line: [" + line + "], Length: " + line.length()); // Debug info

            line = trim(line);
            if (line.isEmpty()) continue; // 跳过空行

            // 使用正则表达式或其他方式根据实际文件格式解析
            // 假设每行格式为: "进程名 创建时间 优先级 程序名称"
            String[] parts = line.split("\\s+");
            if (parts.length < 4) {
                System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                continue;
            }

            String proName = parts[0];
            int createTime;
            int priority;
            String programName = parts[3];
            try {
                createTime = Integer.parseInt(parts[1]);
                priority = Integer.parseInt(parts[2]);
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析创建时间或优先级: " + line);
                continue;
            }

            int runTime = runTimes.getOrDefault(programName, 0);
            if (runTime == 0) {
                System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
            }

            PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
            processes.add(pcb);
            System.out.println("Added Process: " + proName + " Run Time: " + runTime + " ms"); // Debug info
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### **关键点说明**

- **文件对应性**：确保读取的是 `Process.txt`，与C++逻辑一致。
- **进程信息解析**：假设每行格式为 `"进程名 创建时间 优先级 程序名称"`，根据需要调整。
- **调试信息**：添加了 `System.out.println` 以输出读取的行和添加的进程，便于调试。
- **错误处理**：增强了对缺少程序名称和解析错误的处理。

## **5. 综合修正后的代码结构**

为了更好地组织和管理这些文件读取函数，建议将它们集成到 `OSystem` 类中，并确保它们之间的调用顺序正确。以下是一个综合的代码示例：

```java
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class OSystem {

    // 进程控制块（PCB）
    static class PCB {
        String proName;                   // 进程名称
        int startTime;                    // 到达时间
        int priority;                     // 优先级
        int runTime;                      // 运行时间（剩余）
        int originalRunTime;              // 原始运行时间
        String programName;               // 关联的程序名称
        int firstTime;                    // 开始运行时间
        int finishTime;                   // 完成时间
        double turnoverTime;              // 周转时间
        double weightedTurnoverTime;      // 带权周转时间
        String status;                    // 状态
        List<Integer> visitList;          // 页面访问列表（新增字段）

        PCB(String proName, int startTime, int priority, int runTime, String programName) {
            this.proName = proName;
            this.startTime = startTime;
            this.priority = priority;
            this.runTime = runTime;
            this.originalRunTime = runTime;
            this.programName = programName;
            this.firstTime = -1;
            this.finishTime = 0;
            this.turnoverTime = 0.0;
            this.weightedTurnoverTime = 0.0;
            this.status = "等待";
            this.visitList = new ArrayList<>(); // 初始化 visitList
        }
    }

    // 运行步骤结构体
    static class RUN {
        String name;         // 进程名（程序名）
        int jumpTime;        // 执行时间
        double address;      // 访问地址

        RUN(String name, int jumpTime, double address) {
            this.name = name;
            this.jumpTime = jumpTime;
            this.address = address;
        }
    }

    // 函数信息结构体
    static class FunctionInfo {
        String funcName; // 函数名称
        double size;     // 函数大小 (KB)

        FunctionInfo(String funcName, double size) {
            this.funcName = funcName;
            this.size = size;
        }
    }

    // 程序信息结构体
    static class ProgramInfo {
        String programName;                      // 程序名称
        List<FunctionInfo> functions;            // 程序中的函数列表

        ProgramInfo(String programName) {
            this.programName = programName;
            this.functions = new ArrayList<>();
        }
    }

    // 页面替换管理器
    static class PageManager {
        double pageSize; // 页面大小（KB）
        int maxPages;    // 每个进程的最大页面数
        Queue<Integer> fifoPages; // FIFO页面队列
        LinkedHashMap<Integer, Integer> lruPages; // LRU页面映射：页面号 -> 最近访问时间
        List<String> log; // 页面操作日志
        int pageFaults;    // 缺页次数
        int pageHits;      // 命中次数

        PageManager(double pageSize, int maxPages) {
            this.pageSize = pageSize;
            this.maxPages = maxPages;
            this.fifoPages = new LinkedList<>();
            // 使用 accessOrder=true 的 LinkedHashMap 实现 LRU
            this.lruPages = new LinkedHashMap<Integer, Integer>(maxPages, 0.75f, true) {
                protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                    if (size() > PageManager.this.maxPages) {
                        log.add("LRU: 页面 " + eldest.getKey() + " 被移除。");
                        pageFaults++;
                        return true;
                    }
                    return false;
                }
            };
            this.log = new ArrayList<>();
            this.pageFaults = 0;
            this.pageHits = 0;
        }

        // FIFO替换策略
        void fifoReplace(int page) {
            // 检查页面是否已存在
            boolean found = fifoPages.contains(page);

            if (found) {
                pageHits++;
                log.add("FIFO: 页面 " + page + " 已在内存中 (命中)。");
                displayMemoryState("FIFO");
                return;
            }

            // 页面错误
            pageFaults++;
            if (fifoPages.size() >= maxPages) {
                if (!fifoPages.isEmpty()) {
                    int removed = fifoPages.poll();
                    log.add("FIFO: 页面 " + removed + " 被移除。");
                }
            }
            fifoPages.offer(page);
            log.add("FIFO: 页面 " + page + " 被添加。");

            // 记录当前内存状态
            displayMemoryState("FIFO");
        }

        // LRU替换策略
        void lruReplace(int page, int currentTime) {
            if (lruPages.containsKey(page)) {
                pageHits++;
                lruPages.put(page, currentTime); // 更新页面最近使用时间
                log.add("LRU: 页面 " + page + " 已在内存中 (命中)。");
                displayMemoryState("LRU");
                return;
            }

            // 页面错误
            pageFaults++;
            if (lruPages.size() >= maxPages) {
                // 最久未使用的页面会被自动移除，由 LinkedHashMap 的 removeEldestEntry 方法处理
                // 这里只需记录日志
            }
            lruPages.put(page, currentTime);
            log.add("LRU: 页面 " + page + " 被添加。");

            // 记录当前内存状态
            displayMemoryState("LRU");
        }

        // 获取页面置换日志
        List<String> getLog() {
            return log;
        }

        // 获取页面错误次数
        int getPageFaults() {
            return pageFaults;
        }

        // 获取页面命中次数
        int getPageHits() {
            return pageHits;
        }

        // 计算页面命中率
        double getHitRate() {
            return (pageHits + pageFaults) == 0 ? 0 : ((double) pageHits / (pageHits + pageFaults));
        }

        // 显示当前内存中的页面状态
        void displayMemoryState(String algorithm) {
            System.out.println("当前内存状态 (" + algorithm + "):");
            System.out.print("|");
            if (algorithm.equals("FIFO")) {
                for (int page : fifoPages) {
                    System.out.printf(" %d |", page);
                }
            } else if (algorithm.equals("LRU")) {
                for (int page : lruPages.keySet()) {
                    System.out.printf(" %d |", page);
                }
            }
            System.out.println();
        }

        // 打印总结报告
        void printSummary(String algorithm, String outputFile) {
            System.out.println("\n===== " + algorithm + " 总结报告 =====");
            System.out.println("缺页次数: " + pageFaults);
            System.out.println("页面命中次数: " + pageHits);
            if (pageHits + pageFaults > 0) {
                double hitRate = getHitRate() * 100;
                System.out.printf("页面命中率: %.2f%%\n", hitRate);
            }

            // 将总结报告写入文件
            try (BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile, true))) {
                bw.write("===== " + algorithm + " 总结报告 =====\n");
                bw.write("缺页次数: " + pageFaults + "\n");
                bw.write("页面命中次数: " + pageHits + "\n");
                if (pageHits + pageFaults > 0) {
                    double hitRate = getHitRate() * 100;
                    bw.write(String.format("页面命中率: %.2f%%\n", hitRate));
                }
                bw.write("\n");
            } catch (IOException e) {
                System.err.println("Error: 无法写入 " + outputFile + " 文件。");
            }
        }
    }

    // 全局变量
    static List<PCB> processes = new ArrayList<>(); // 所有进程
    static List<RUN> runSteps = new ArrayList<>();   // 所有运行步骤
    static Map<String, ProgramInfo> programs = new HashMap<>(); // 所有程序信息

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取数据文件
        System.out.println("\n正在加载数据文件...");
        // 获取文件路径
        String runFile = getFilePath(scanner, "请输入 run.txt 文件路径: ");
        String processFile = getFilePath(scanner, "请输入 Process.txt 文件路径: ");
        String programFile = getFilePath(scanner, "请输入 program.txt 文件路径: ");
        String runStepsFile = getFilePath(scanner, "请输入 runSteps.txt 文件路径: ");

        // 加载 run.txt 中的运行时间
        Map<String, Integer> runTimes = loadRunTimes(runFile);

        // 读取 Process.txt，传递 runTimes 以设置 runTime
        loadProcesses(processFile, runTimes);

        // 读取 program.txt 文件
        Map<String, Map<String, Double>> programDetails = loadPrograms(programFile);

        // 读取 run.txt 文件，加载运行步骤
        RunSteps loadedRunSteps = loadRunSteps(runFile);

        // 将页面访问序列赋值到对应的 PCB
        assignPageSequences(loadedRunSteps);

        System.out.println("数据文件加载完成！\n");

        while (true) {
            // 显示菜单
            showMenu();
            int choice = getUserChoice(scanner, 1, 7);

            switch (choice) {
                case 1:
                    // 显示进程信息
                    displayProcessInfo();
                    break;
                case 2:
                    // 显示程序详细信息
                    displayProgramDetails();
                    break;
                case 3:
                    // 先来先服务调度（FCFS）
                    System.out.println("\n正在执行先来先服务调度（FCFS）...");
                    performFCFS();
                    break;
                case 4:
                    // 时间片轮转调度（RR）
                    System.out.println("\n正在执行时间片轮转调度（RR）...");
                    performRR(scanner);
                    break;
                case 5:
                    // 分页调度（基于访问页号）
                    System.out.println("\n正在执行分页调度（基于访问页号）...");
                    PagingScheduler pagingSchedulerDefault = new PagingScheduler(4.0, 3); // 示例默认值
                    pagingSchedulerDefault.performPagingScheduling(scanner, "默认分页调度", "paging_default_log.txt");
                    break;
                case 6:
                    // 设置页面大小并执行分页调度
                    System.out.println("\n正在设置页面大小并执行分页调度...");
                    PagingScheduler dynamicScheduler = new PagingScheduler(0.0, 0); // 动态输入
                    dynamicScheduler.performPagingScheduling(scanner, "动态分页调度", "paging_dynamic_log.txt");
                    break;
                case 7:
                    // 退出程序
                    System.out.println("程序退出中，再见！");
                    scanner.close();
                    System.exit(0);
                    break;
                default:
                    // 无效选项
                    System.out.println("无效选项，请重新选择！");
            }
        }
    }

    // 辅助函数：去除字符串两端的空白字符
    private static String trim(String str) {
        return str == null ? "" : str.trim();
    }

    // 显示菜单
    private static void showMenu() {
        System.out.println("======================================");
        System.out.println("|         分页调度模拟系统           |");
        System.out.println("======================================");
        System.out.println("| 1. 显示进程信息                    |");
        System.out.println("| 2. 显示程序详细信息                |");
        System.out.println("| 3. 先来先服务调度 (FCFS)           |");
        System.out.println("| 4. 时间片轮转调度 (RR)             |");
        System.out.println("| 5. 分页调度 (基于访问页号)         |");
        System.out.println("| 6. 设置页面大小并执行分页调度       |");
        System.out.println("| 7. 退出程序                        |");
        System.out.println("======================================");
        System.out.print("请输入您的选择 (1-7): ");
    }

    // 获取文件路径
    private static String getFilePath(Scanner scanner, String prompt) {
        String path = "";
        while (true) {
            System.out.print(prompt);
            path = scanner.nextLine().trim();
            File file = new File(path);
            if (file.exists() && file.isFile()) {
                break;
            } else {
                System.out.println("文件不存在，请重新输入有效的文件路径。");
            }
        }
        return path;
    }

    // 获取用户选择，并验证输入
    private static int getUserChoice(Scanner scanner, int min, int max) {
        int choice = -1;
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                choice = Integer.parseInt(input);
                if (choice >= min && choice <= max) {
                    break;
                } else {
                    System.out.print("输入无效，请输入一个介于 " + min + " 和 " + max + " 之间的整数: ");
                }
            } catch (NumberFormatException e) {
                System.out.print("输入无效，请输入一个整数: ");
            }
        }
        return choice;
    }

    // 加载 run.txt 中的运行时间
    private static Map<String, Integer> loadRunTimes(String filename) {
        Map<String, Integer> runTimes = new HashMap<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

            while ((line = br.readLine()) != null) {
                line = trim(line);
                if (line.isEmpty()) continue;

                // 跳过表头（假设第一行是表头）
                if (isFirstLine) {
                    // 判断是否为表头，可以根据实际文件内容调整
                    if (line.contains("ProgramName") || line.contains("程序名")) {
                        isFirstLine = false;
                        continue;
                    }
                    isFirstLine = false; // 如果没有表头，也不再跳过
                }

                // 检测是否为程序名行
                if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                        System.out.println("Found Program Name: [" + currentProgram + "]"); // Debug info
                    } else {
                        System.err.println("警告: 无法提取程序名称: " + line);
                    }
                    continue;
                }

                // 解析时间戳和操作类型
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                    continue;
                }

                int timestamp;
                String operation;
                try {
                    timestamp = Integer.parseInt(parts[0]);
                    operation = parts[1];
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                    continue;
                }

                if (operation.equals("结束") || operation.equals("End")) {
                    if (currentProgram.isEmpty()) {
                        System.err.println("警告: 未指定当前程序名称，无法记录运行时间。");
                        continue;
                    }
                    int existingTime = runTimes.getOrDefault(currentProgram, 0);
                    runTimes.put(currentProgram, Math.max(existingTime, timestamp));
                    System.out.println("Set final run time for [" + currentProgram + "] to " + timestamp + " ms"); // Debug info
                }
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
        return runTimes;
    }

    // 读取 Process.txt 文件，加载进程信息
    private static void loadProcesses(String filename, Map<String, Integer> runTimes) {
        System.out.println("\nLoaded Run Times:");
        for (Map.Entry<String, Integer> entry : runTimes.entrySet()) {
            System.out.println("Program: [" + entry.getKey() + "], Run Time: " + entry.getValue() + "ms"); // Debug info
        }

        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    // 检测并移除 BOM
                    if (line.length() >= 3 &&
                        (line.charAt(0) & 0xFF) == 0xEF &&
                        (line.charAt(1) & 0xFF) == 0xBB &&
                        (line.charAt(2) & 0xFF) == 0xBF) {
                        line = line.substring(3);
                    }
                    isFirstLine = false;
                    // 假设第一行是表头，如果需要可以进一步验证
                    continue;
                }

                // 打印读取的行及其长度以进行调试
                System.out.println("Reading line: [" + line + "], Length: " + line.length()); // Debug info

                line = trim(line);
                if (line.isEmpty()) continue; // 跳过空行

                // 使用正则表达式或其他方式根据实际文件格式解析
                // 假设每行格式为: "进程名 创建时间 优先级 程序名称"
                String[] parts = line.split("\\s+");
                if (parts.length < 4) {
                    System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                    continue;
                }

                String proName = parts[0];
                int createTime;
                int priority;
                String programName = parts[3];
                try {
                    createTime = Integer.parseInt(parts[1]);
                    priority = Integer.parseInt(parts[2]);
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析创建时间或优先级: " + line);
                    continue;
                }

                int runTime = runTimes.getOrDefault(programName, 0);
                if (runTime == 0) {
                    System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
                }

                PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
                processes.add(pcb);
                System.out.println("Added Process: " + proName + " Run Time: " + runTime + " ms"); // Debug info
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 读取 program.txt 文件，加载程序详细信息
    private static Map<String, Map<String, Double>> loadPrograms(String filename) {
        Map<String, Map<String, Double>> programs = new HashMap<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            boolean isFirstLine = true; // 标记是否为第一行

            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    // 检测并移除 BOM
                    if (line.length() >= 3 &&
                        (line.charAt(0) & 0xFF) == 0xEF &&
                        (line.charAt(1) & 0xFF) == 0xBB &&
                        (line.charAt(2) & 0xFF) == 0xBF) {
                        line = line.substring(3);
                    }
                    isFirstLine = false;
                }

                // 打印读取的行及其长度以进行调试
                System.out.println("Reading line: [" + line + "], Length: " + line.length()); // Debug info

                line = trim(line);
                if (line.isEmpty()) continue; // 跳过空行

                // 检测是否为 FileName 行
                if (line.startsWith("FileName") || line.startsWith("FName") || line.startsWith("program")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                        programs.put(currentProgram, new HashMap<>());
                        System.out.println("Found Program: [" + currentProgram + "]"); // Debug info
                    } else {
                        System.err.println("警告: 无法提取程序名称: " + line);
                    }
                    continue;
                }

                // 确保存在当前程序名
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: 在程序名称之前发现函数定义: " + line);
                    continue;
                }

                // 解析函数名称和大小
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                    continue;
                }

                String funcName = parts[0];
                double size;
                try {
                    size = Double.parseDouble(parts[1]);
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析函数大小: " + line);
                    continue;
                }

                programs.get(currentProgram).put(funcName, size);
                System.out.println("Added Function [" + funcName + "] Size " + size + " KB to Program [" + currentProgram + "]"); // Debug info
            }

        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
        return programs;
    }

    // 读取 run.txt 文件，加载运行步骤
    private static RunSteps loadRunSteps(String filename) {
        RunSteps runSteps = new RunSteps();
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            boolean isFirstLine = true; // 标记是否为第一行，若有表头则跳过

            while ((line = br.readLine()) != null) {
                line = trim(line);
                if (line.isEmpty()) continue;

                // 跳过表头（假设第一行是表头）
                if (isFirstLine) {
                    // 判断是否为表头，可以根据实际文件内容调整
                    if (line.contains("ProgramName") || line.contains("程序名")) {
                        isFirstLine = false;
                        continue;
                    }
                    isFirstLine = false; // 如果没有表头，也不再跳过
                }

                // 检测是否为程序名行
                if (line.startsWith("ProgramName") || line.startsWith("程序")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                        System.out.println("Found Program Name: [" + currentProgram + "]"); // Debug info
                    } else {
                        System.err.println("警告: 无法提取程序名称: " + line);
                    }
                    continue;
                }

                // 解析时间、操作和参数
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: " + filename + " 中的行格式不正确: " + line);
                    continue;
                }

                int timestamp;
                String operation;
                String param = "";
                try {
                    timestamp = Integer.parseInt(parts[0]);
                    operation = parts[1];
                    if (parts.length >= 3) {
                        param = parts[2];
                    }
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                    continue;
                }

                if (operation.equals("结束") || operation.equals("End")) {
                    if (currentProgram.isEmpty()) {
                        System.err.println("警告: 未指定当前程序名称，无法记录运行时间。");
                        continue;
                    }
                    int existingTime = runSteps.runTimes.getOrDefault(currentProgram, 0);
                    runSteps.runTimes.put(currentProgram, Math.max(existingTime, timestamp));
                    System.out.println("Set final run time for [" + currentProgram + "] to " + timestamp + " ms"); // Debug info
                    continue;
                }

                if (operation.equals("Jump") || operation.equals("跳转")) {
                    if (currentProgram.isEmpty()) {
                        System.err.println("警告: 未指定当前程序名称，无法记录跳转地址。");
                        continue;
                    }
                    if (!param.isEmpty()) {
                        try {
                            int address = Integer.parseInt(param);
                            runSteps.pageSequences.computeIfAbsent(currentProgram, k -> new ArrayList<>()).add(address / 4); // 假设 pageSize=4
                            System.out.println("Added Jump Address " + address + " to [" + currentProgram + "]"); // Debug info
                        } catch (NumberFormatException e) {
                            System.err.println("警告: 无法解析跳转地址: " + param + " 在行: " + line);
                        }
                    } else {
                        System.err.println("警告: 缺少跳转地址在行: " + line);
                    }
                    // 更新运行时间
                    runSteps.runTimes.put(currentProgram, Math.max(runSteps.runTimes.getOrDefault(currentProgram, 0), timestamp));
                    System.out.println("Updated run time [" + currentProgram + "]: " + timestamp + " ms"); // Debug info
                } else {
                    // 其他操作可以根据需要扩展
                    System.out.println("Info: Unhandled operation [" + operation + "] in line: " + line);
                    // 更新运行时间
                    runSteps.runTimes.put(currentProgram, Math.max(runSteps.runTimes.getOrDefault(currentProgram, 0), timestamp));
                    System.out.println("Updated run time [" + currentProgram + "]: " + timestamp + " ms"); // Debug info
                }
            }

            // 输出加载的运行时间
            System.out.println("\nLoaded Run Times:");
            for (Map.Entry<String, Integer> entry : runSteps.runTimes.entrySet()) {
                System.out.println("Program: [" + entry.getKey() + "], Run Time: " + entry.getValue() + " ms"); // Debug info
            }

            // 输出加载的页面访问序列
            System.out.println("Loaded Page Sequences:");
            for (Map.Entry<String, List<Integer>> entry : runSteps.pageSequences.entrySet()) {
                System.out.print("Program: [" + entry.getKey() + "], Pages: ");
                for (int page : entry.getValue()) {
                    System.out.print(page + " ");
                }
                System.out.println();
            }

        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
        return runSteps;
    }

    // 将页面访问序列赋值到对应的 PCB
    private static void assignPageSequences(RunSteps loadedRunSteps) {
        for (PCB pcb : processes) {
            List<Integer> pages = loadedRunSteps.pageSequences.get(pcb.programName);
            if (pages != null) {
                pcb.visitList.addAll(pages);
                System.out.println("Assigned Page Sequence to Process [" + pcb.proName + "]: " + pages); // Debug info
            } else {
                System.err.println("警告: 未找到程序 [" + pcb.programName + "] 的页面访问序列。");
            }
        }
    }

    // 读取 program.txt 文件，加载程序详细信息
    private static void displayProgramDetails() {
        System.out.println("\n===== 程序详细信息 =====");
        for (ProgramInfo prog : programs.values()) {
            System.out.println("程序: " + prog.programName);
            for (FunctionInfo func : prog.functions) {
                System.out.println("  函数: " + func.funcName + ", 大小: " + func.size + " KB");
            }
            System.out.println();
        }
    }

    // 显示进程信息
    private static void displayProcessInfo() {
        System.out.println("\n===== 进程信息 =====");
        System.out.printf("%-12s%-12s%-12s%-15s%-15s\n", "进程名", "到达时间", "运行时间", "程序名称", "状态");
        System.out.println("------------------------------------------------------------------");
        for (PCB pro : processes) {
            System.out.printf("%-12s%-12d%-12d%-15s%-15s\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.programName,
                    pro.status);
        }
    }

    // 执行先来先服务调度（FCFS）
    private static void performFCFS() {
        System.out.println("\n=== 先来先服务调度（FCFS） ===");
        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

        int currentTime = 0;
        for (PCB pro : sortedProcesses) {
            if (currentTime < pro.startTime) {
                currentTime = pro.startTime;
            }
            pro.firstTime = currentTime;
            pro.status = "执行";
            currentTime += pro.runTime;
            pro.finishTime = currentTime;
            pro.turnoverTime = pro.finishTime - pro.startTime;
            pro.weightedTurnoverTime = pro.originalRunTime > 0
                    ? (double) pro.turnoverTime / pro.originalRunTime
                    : 0.0;
            pro.status = "完成";
        }

        // 保存与显示结果
        saveAndDisplayResults("先来先服务调度（FCFS）", sortedProcesses, "FCFS_result.txt");
    }

    // 执行时间片轮转调度（RR）
    private static void performRR(Scanner scanner) {
        System.out.println("\n=== 时间片轮转调度（RR） ===");
        System.out.print("请输入时间片长度 (ms): ");
        int timeQuantum = getUserChoice(scanner, 1, Integer.MAX_VALUE);

        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

        Queue<PCB> readyQueue = new LinkedList<>();
        int currentTime = 0, index = 0;

        while (!readyQueue.isEmpty() || index < sortedProcesses.size()) {
            while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                readyQueue.offer(sortedProcesses.get(index));
                sortedProcesses.get(index).status = "就绪";
                index++;
            }

            if (!readyQueue.isEmpty()) {
                PCB currentProcess = readyQueue.poll();
                if (currentProcess.firstTime == -1) {
                    currentProcess.firstTime = currentTime;
                }

                int execTime = Math.min(timeQuantum, currentProcess.runTime);
                currentTime += execTime;
                currentProcess.runTime -= execTime;

                // 处理在执行过程中到达的新进程
                while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                    readyQueue.offer(sortedProcesses.get(index));
                    sortedProcesses.get(index).status = "就绪";
                    index++;
                }

                if (currentProcess.runTime > 0) {
                    readyQueue.offer(currentProcess);
                    currentProcess.status = "就绪";
                } else {
                    currentProcess.finishTime = currentTime;
                    currentProcess.turnoverTime = currentProcess.finishTime - currentProcess.startTime;
                    currentProcess.weightedTurnoverTime = currentProcess.originalRunTime > 0
                            ? (double) currentProcess.turnoverTime / currentProcess.originalRunTime
                            : 0.0;
                    currentProcess.status = "完成";
                }
            } else {
                currentTime++; // 空闲时间片
            }
        }

        // 保存与显示结果
        saveAndDisplayResults("时间片轮转调度（RR）", sortedProcesses, "RR_result.txt");
    }

    // 保存与显示调度结果
    private static void saveAndDisplayResults(String title, List<PCB> processes, String fileName) {
        StringBuilder sb = new StringBuilder();
        sb.append("\n=== ").append(title).append(" ===\n");
        sb.append("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间\n");

        System.out.printf("\n=== %s ===\n", title);
        System.out.printf("%-10s%-12s%-12s%-12s%-12s%-12s%-16s\n",
                "进程名", "到达时间", "运行时间", "开始时间", "完成时间", "周转时间", "带权周转时间");
        System.out.println("--------------------------------------------------------------------------");

        for (PCB pro : processes) {
            sb.append(String.format("%s\t%d\t%d\t%d\t%d\t%.0f\t%.2f\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.firstTime,
                    pro.finishTime,
                    pro.turnoverTime,
                    pro.weightedTurnoverTime));
            System.out.printf("%-10s%-12d%-12d%-12d%-12d%-12.0f%-16.2f\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.firstTime,
                    pro.finishTime,
                    pro.turnoverTime,
                    pro.weightedTurnoverTime);
        }

        // 写入文件
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName, true))) {
            bw.write(sb.toString());
        } catch (IOException e) {
            System.err.println("Error: 无法写入 " + fileName + " 文件。");
        }

        System.out.printf("=== %s 完成。结果已保存到 %s ===\n", title, fileName);
    }

    // Static class for Paging Scheduling
    static class PagingScheduler {

        private PageManager pageManager;

        public PagingScheduler(double pageSize, int maxPages) {
            this.pageManager = new PageManager(pageSize, maxPages);
        }

        // Entry point for performing paging scheduling
        public void performPagingScheduling(Scanner scanner, String schedulerName, String logFileName) {
            System.out.println("\n===== " + schedulerName + " =====");

            // Prompt user for page size and max pages if not set
            double pageSize = this.pageManager.pageSize;
            int maxPages = this.pageManager.maxPages;

            if (pageSize <= 0 || maxPages <= 0) {
                pageSize = getUserInput(scanner, "请输入页面大小 (KB): ", 0.1, Double.MAX_VALUE);
                maxPages = (int) getUserInput(scanner, "请输入每个进程的最大页面数: ", 1, Integer.MAX_VALUE);
                this.pageManager = new PageManager(pageSize, maxPages);
            }

            // Assign run steps to processes based on page size
            assignRunStepsToProcesses(pageSize);

            // Calculate page requirements for all programs
            Map<String, Integer> pageRequirements = calculatePageRequirements(pageSize);

            // Prompt user for page replacement algorithm choice
            System.out.println("请选择页面调度算法：\n1. FIFO\n2. LRU");
            int choice = (int) getUserInput(scanner, "请输入选择 (1 或 2): ", 1, 2);

            // Perform page scheduling based on the selected algorithm
            System.out.println("\n页面调度过程:");
            performPageReplacement(choice, pageRequirements);

            // Display the results
            displayPageSummary(schedulerName, logFileName, pageRequirements);
        }

        // Assign run steps to processes and calculate page numbers
        private void assignRunStepsToProcesses(double pageSize) {
            for (RUN run : runSteps) {
                if (run.address == -1) {
                    continue; // Ignore "end" operations
                }
                int pageNumber = (int) Math.floor(run.address / pageSize);

                // Assign page numbers to the corresponding process
                Optional<PCB> processOpt = processes.stream()
                        .filter(pro -> pro.programName.equals(run.name))
                        .findFirst();

                if (processOpt.isPresent()) {
                    PCB pro = processOpt.get();
                    pro.visitList.add(pageNumber);
                } else {
                    System.err.println("警告: 未找到与程序名 [" + run.name + "] 匹配的进程。");
                }
            }
        }

        // Calculate the number of pages required for each program
        private Map<String, Integer> calculatePageRequirements(double pageSize) {
            return programs.entrySet().stream()
                    .collect(Collectors.toMap(
                            Map.Entry::getKey,
                            entry -> (int) Math.ceil(
                                    entry.getValue().values().stream()
                                            .mapToDouble(Double::doubleValue)
                                            .sum() / pageSize
                            )
                    ));
        }

        // Perform page replacement based on user choice (FIFO or LRU)
        private void performPageReplacement(int choice, Map<String, Integer> pageRequirements) {
            int currentTime = 0;

            for (Map.Entry<String, Integer> entry : pageRequirements.entrySet()) {
                String programName = entry.getKey();
                int pages = entry.getValue();
                System.out.printf("程序 %s 需要 %d 页\n", programName, pages);

                PCB programPCB = processes.stream()
                        .filter(pro -> pro.programName.equals(programName))
                        .findFirst()
                        .orElse(null);

                if (programPCB == null) {
                    System.err.println("警告: 未找到与程序名 [" + programName + "] 匹配的进程。");
                    continue;
                }

                for (int pageNumber : programPCB.visitList) {
                    if (choice == 1) {
                        pageManager.fifoReplace(pageNumber);
                    } else {
                        pageManager.lruReplace(pageNumber, currentTime);
                    }
                    currentTime++;
                }
            }
        }

        // Display summary of the page replacement process
        private void displayPageSummary(String schedulerName, String logFileName, Map<String, Integer> pageRequirements) {
            System.out.println("\n===== " + schedulerName + " 总结报告 =====");
            pageRequirements.forEach((programName, pages) -> {
                System.out.printf("程序: %s | 总页面数: %d\n", programName, pages);
            });

            System.out.println("页面命中次数: " + pageManager.getPageHits());
            System.out.println("页面置换次数 (页面错误): " + pageManager.getPageFaults());
            System.out.printf("页面命中率: %.2f%%\n", pageManager.getHitRate() * 100);

            // 将总结报告写入文件
            try (BufferedWriter bw = new BufferedWriter(new FileWriter(logFileName, true))) {
                bw.write("===== " + schedulerName + " 总结报告 =====\n");
                pageRequirements.forEach((programName, pages) -> {
                    bw.write(String.format("程序: %s | 总页面数: %d\n", programName, pages));
                });
                bw.write("页面命中次数: " + pageManager.getPageHits() + "\n");
                bw.write("页面置换次数 (页面错误): " + pageManager.getPageFaults() + "\n");
                bw.write(String.format("页面命中率: %.2f%%\n\n", pageManager.getHitRate() * 100));
            } catch (IOException e) {
                System.err.println("Error: 无法写入 " + logFileName + " 文件。");
            }
        }

        // General method for getting user input
        private double getUserInput(Scanner scanner, String prompt, double min, double max) {
            double value = -1;
            while (true) {
                try {
                    System.out.print(prompt);
                    String input = scanner.nextLine().trim();
                    value = Double.parseDouble(input);
                    if (value >= min && value <= max) {
                        break;
                    } else {
                        System.out.printf("输入无效，请输入一个介于 %.1f 和 %.1f 之间的数字。\n", min, max);
                    }
                } catch (NumberFormatException e) {
                    System.out.println("输入无效，请输入一个数字。");
                }
            }
            return value;
        }
    }
```

### **关键点说明**

- **文件读取顺序**：在 `main` 方法中，按照逻辑顺序加载 `run.txt` 的运行时间、`Process.txt` 的进程信息、`program.txt` 的程序详细信息、以及 `run.txt` 的运行步骤。
- **页面访问序列赋值**：在加载完所有数据后，将页面访问序列 (`pageSequences`) 赋值给对应的 `PCB` 对象。
- **分页调度逻辑**：在 `PagingScheduler` 类中，使用 `PCB` 的 `visitList` 来执行页面替换。
- **调试信息**：在各个关键步骤添加了调试输出，帮助您跟踪程序的执行过程。
- **错误处理**：增强了对文件格式错误和缺失数据的处理，确保程序的健壮性。

## **6. 总结与建议**

通过上述修改，您的Java代码应能更好地与C++代码的逻辑保持一致，减少文件读取和数据解析时的错误。同时，增强的调试信息将帮助您更容易地定位和解决潜在的问题。

### **建议**

1. **文件格式验证**：确保您的输入文件 (`run.txt`、`Process.txt`、`program.txt`) 格式与代码中的解析逻辑完全一致。任何格式不匹配都会导致解析错误。
2. **统一文件读取**：根据C++代码逻辑，确保所有必要的数据都从正确的文件中读取。例如，C++的 `loadRunSteps` 读取的是 `run.txt`，而Java代码中您原本的 `readRun` 可能误读为 `runSteps.txt`。
3. **调试与测试**：运行程序时，仔细观察控制台输出的调试信息，确保所有数据都被正确加载和解析。如果发现数据不一致，回到相应的文件和代码进行检查。
4. **异常处理**：在实际应用中，可以考虑使用更细粒度的异常处理，避免程序因一个错误而完全退出。例如，可以记录错误并继续处理其他数据。
5. **代码优化**：根据需要，可以进一步优化代码结构，如将文件读取和数据解析封装成更小的函数，增强代码的可读性和可维护性。

如果您在实施上述修改后仍然遇到问题，请提供具体的错误信息或异常堆栈，我将进一步协助您解决问题。