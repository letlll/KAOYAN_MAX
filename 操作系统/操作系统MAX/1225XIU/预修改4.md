理解到您在修改 `performRR` 方法后遇到了运行时错误，主要是由于进程的运行时间（`runTime`）读取不正确导致的。根据您提供的 `Process.txt`、`run.txt` 和 `program.txt` 文件格式，`runTime` 需要从 `run.txt` 文件中提取，而不是直接从 `Process.txt` 中读取。

以下是详细的步骤和修改建议，以确保您的 Java 程序能够正确读取进程的运行时间，并成功执行调度算法。

## 1. 修改 `PCB` 类

首先，确保 `PCB` 类包含所有必要的字段，包括 `priority` 和正确的字段名称。以下是修改后的 `PCB` 类：

```java
static class PCB {
    String proName;                   // 进程名称
    int startTime;                    // 到达时间
    int priority;                     // 优先级
    int runTime;                      // 运行时间（剩余）
    int originalRunTime;              // 原始运行时间
    String programName;               // 关联的程序名称
    int firstTime;                    // 开始运行时间
    int finishTime;                   // 完成时间
    double turnoverTime;              // 周转时间
    double weightedTurnoverTime;      // 带权周转时间
    String status;                    // 状态

    PCB(String proName, int startTime, int priority, int runTime, String programName) {
        this.proName = proName;
        this.startTime = startTime;
        this.priority = priority;
        this.runTime = runTime;
        this.originalRunTime = runTime;
        this.programName = programName;
        this.firstTime = -1;
        this.finishTime = 0;
        this.turnoverTime = 0.0;
        this.weightedTurnoverTime = 0.0;
        this.status = "等待";
    }
}
```

## 2. 创建一个方法来加载 `run.txt` 并提取每个程序的 `runTime`

`run.txt` 文件记录了每个程序的执行步骤，其中“结束”操作的时间戳即为程序的总运行时间。我们需要解析 `run.txt` 文件，并为每个程序提取其 `runTime`。

```java
// 加载 run.txt 中的运行时间
private static Map<String, Integer> loadRunTimes(String filename) {
    Map<String, Integer> runTimes = new HashMap<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) continue;
            // 检测是否为程序名行
            if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                }
                continue;
            }
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: run.txt 中的行格式不正确: " + line);
                continue;
            }
            int timestamp;
            String operation;
            try {
                timestamp = Integer.parseInt(parts[0]);
                operation = parts[1];
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                continue;
            }
            if (operation.equals("结束") || operation.equals("End")) {
                runTimes.put(currentProgram, Math.max(runTimes.getOrDefault(currentProgram, 0), timestamp));
            }
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
    return runTimes;
}
```

### 说明

- **`loadRunTimes` 方法**：解析 `run.txt` 文件，识别每个程序的“结束”操作，并记录其时间戳作为 `runTime`。
- **错误处理**：如果遇到格式不正确的行，会发出警告并跳过。

## 3. 修改 `readProcess` 方法以正确读取 `Process.txt` 并分配 `runTime`

根据您的 `Process.txt` 文件格式，`readProcess` 方法需要读取进程的名称、创建时间、优先级和关联的程序名称，然后根据 `runTimes` 映射为每个进程分配正确的 `runTime`。

```java
// 读取 Process.txt 文件
private static void readProcess(String filename, Map<String, Integer> runTimes) {
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        boolean isFirstLine = true;
        while ((line = br.readLine()) != null) {
            if (isFirstLine) {
                // 跳过表头
                isFirstLine = false;
                continue;
            }
            if (line.trim().isEmpty()) continue;
            String[] parts = line.trim().split("\\s+");
            if (parts.length < 4) {
                System.err.println("警告: Process.txt 中的行格式不正确: " + line);
                continue;
            }
            String proName = parts[0];
            int createTime;
            int priority;
            String programName = parts[3];
            try {
                createTime = Integer.parseInt(parts[1]);
                priority = Integer.parseInt(parts[2]);
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析创建时间或优先级: " + line);
                continue;
            }
            int runTime = runTimes.getOrDefault(programName, 0);
            if (runTime == 0) {
                System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
            }
            PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
            processes.add(pcb);
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### 说明

- **`readProcess` 方法**：读取 `Process.txt`，为每个进程分配对应程序的 `runTime`。
- **错误处理**：如果 `runTime` 未设置（即程序未在 `run.txt` 中找到“结束”操作），则将 `runTime` 设为0并发出警告。

## 4. 修改 `main` 方法以按照正确的顺序调用加载方法

确保在调用 `readProcess` 之前先加载 `runTimes`，然后再读取 `Process.txt`。以下是修改后的 `main` 方法：

```java
public static void main(String[] args) {
    // 创建 Scanner 对象（如果需要用户输入）
    Scanner scanner = new Scanner(System.in);

    // 加载 run.txt 中的运行时间
    Map<String, Integer> runTimes = loadRunTimes("run.txt");

    // 读取 Process.txt，传递 runTimes 以设置 runTime
    readProcess("Process.txt", runTimes);

    // 读取 program.txt 文件
    readProgramDetails("program.txt");

    // 显示进程信息和程序详细信息（可选）
    displayProcessInfo();
    displayProgramDetails();

    // 执行调度算法
    performRR();
    performFCFS(); // 如果需要同时运行 FCFS

    scanner.close();
}
```

### 说明

- **调用顺序**：首先加载 `runTimes`，然后读取 `Process.txt`，再读取 `program.txt`。
- **资源管理**：关闭 `Scanner` 对象以释放资源。

## 5. 确保 `readProgramDetails` 方法正确解析 `program.txt`

根据您提供的 `program.txt` 格式，确保 `readProgramDetails` 方法能够正确解析程序名称和函数信息。

```java
// 读取 program.txt 文件
private static void readProgramDetails(String filename) {
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) continue;
            // 检测是否为 FName 行
            if (line.startsWith("文件名") || line.startsWith("FName")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                    programs.put(currentProgram, new ProgramInfo(currentProgram));
                }
                continue;
            }
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: program.txt 中的行格式不正确: " + line);
                continue;
            }
            String funcName = parts[0];
            double size;
            try {
                size = Double.parseDouble(parts[1].replace("k", "").replace("K", ""));
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析函数大小: " + line);
                continue;
            }
            FunctionInfo func = new FunctionInfo(funcName, size);
            if (currentProgram.isEmpty()) {
                System.err.println("警告: program.txt 中的函数未关联到任何程序: " + line);
                continue;
            }
            programs.get(currentProgram).functions.add(func);
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### 说明

- **函数大小解析**：移除了大小字符串中的“k”或“K”，然后解析为 `double` 类型。
- **关联程序**：确保每个函数都关联到当前正在处理的程序。

## 6. 修改调度方法 (`performRR` 和 `performFCFS`)

确保调度方法使用正确的 `runTime` 并生成与 C++ 版本相同的输出格式。

### 6.1 修改后的 `performRR` 方法

```java
private static void performRR() {
    System.out.println("\n=== 时间片轮转调度（RR） ===");
    // 时间片长度固定为1ms
    int timeQuantum = 1;

    // 按到达时间排序
    List<PCB> sortedProcesses = new ArrayList<>(processes);
    sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime));

    Queue<PCB> readyQueue = new LinkedList<>();
    int currentTime = 0;
    int index = 0; // 用于跟踪哪些进程已被加入队列

    // 使用Map来跟踪每个进程的剩余运行时间
    Map<String, Integer> remainingTimeMap = new HashMap<>();
    for (PCB process : sortedProcesses) {
        remainingTimeMap.put(process.proName, process.runTime);
    }

    // 准备写入result.txt文件
    try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", false))) { // 覆盖模式打开，避免重复
        // 输出表头
        resultFile.print("时间片\t运行的进程\t");
        for (PCB process : sortedProcesses) {
            resultFile.print("进程" + process.proName + "状态\t");
        }
        resultFile.println();

        // 主调度循环
        while (!readyQueue.isEmpty() || index < sortedProcesses.size()) {
            // 将当前时间的进程加入队列
            while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                PCB newProcess = sortedProcesses.get(index);
                readyQueue.offer(newProcess);
                newProcess.status = "就绪";
                System.out.println("进程: " + newProcess.proName + " 在 " + currentTime + " ms 时被加入队列");
                index++;
            }

            // 如果队列为空，记录空闲时间片
            if (readyQueue.isEmpty()) {
                // 输出空闲时间片状态
                resultFile.print(currentTime + "\t" + "null\t");
                for (PCB process : sortedProcesses) {
                    if (process.startTime > currentTime) {
                        resultFile.print("null\t");
                    } else if (remainingTimeMap.get(process.proName) == 0) {
                        resultFile.print("complete\t");
                    } else {
                        resultFile.print("ready\t");
                    }
                }
                resultFile.println();
                currentTime++;
                continue;
            }

            // 从队列中取出一个进程
            PCB currentProcess = readyQueue.poll();

            // 如果是第一次运行，设置开始时间
            if (currentProcess.firstTime == -1) {
                currentProcess.firstTime = currentTime;
            }

            // 执行一个时间片
            int execTime = Math.min(timeQuantum, remainingTimeMap.get(currentProcess.proName));
            remainingTimeMap.put(currentProcess.proName, remainingTimeMap.get(currentProcess.proName) - execTime);
            currentProcess.runTime -= execTime;
            int startExecTime = currentTime;
            currentTime += execTime;

            // 更新进程状态
            if (remainingTimeMap.get(currentProcess.proName) > 0) {
                currentProcess.status = "就绪";
            } else {
                currentProcess.status = "完成";
                currentProcess.finishTime = currentTime;
                currentProcess.turnoverTime = currentProcess.finishTime - currentProcess.startTime;
                currentProcess.weightedTurnoverTime = (double) currentProcess.turnoverTime / currentProcess.originalRunTime;
            }

            // 输出当前时间片的状态
            resultFile.print(startExecTime + "\t" + currentProcess.proName + "\t");

            for (PCB process : sortedProcesses) {
                if (process.proName.equals(currentProcess.proName)) {
                    if (remainingTimeMap.get(process.proName) > 0) {
                        resultFile.print("run\t");
                    } else {
                        resultFile.print("complete\t");
                    }
                } else {
                    if (remainingTimeMap.get(process.proName) == 0) {
                        resultFile.print("complete\t");
                    } else if (process.startTime > startExecTime) {
                        resultFile.print("null\t");
                    } else {
                        resultFile.print("ready\t");
                    }
                }
            }
            resultFile.println();

            // 如果进程未完成，重新加入队列
            if (remainingTimeMap.get(currentProcess.proName) > 0) {
                readyQueue.offer(currentProcess);
            } else {
                // 进程完成，输出完成信息
                resultFile.println("进程 " + currentProcess.proName + " 在 " + currentTime + " ms 完成 "
                        + "| 周转时间： " + currentProcess.turnoverTime
                        + " ms | 带权周转时间： " + String.format("%.2f", currentProcess.weightedTurnoverTime));
            }
        }

        // 输出最终统计信息
        resultFile.println("\n最终统计信息：");
        resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
        for (PCB process : sortedProcesses) {
            resultFile.println(process.proName + "\t"
                    + process.startTime + "\t"
                    + process.originalRunTime + "\t"
                    + process.firstTime + "\t"
                    + process.finishTime + "\t"
                    + process.turnoverTime + "\t"
                    + String.format("%.2f", process.weightedTurnoverTime));
        }

        System.out.println("RR 调度完成，结果已保存到 result.txt");

    } catch (IOException e) {
        System.err.println("错误：无法打开 result.txt 进行结果保存");
        e.printStackTrace();
    }
}
```

### 说明

- **时间片长度固定为1ms**：与 C++ 版本保持一致。
- **按到达时间排序**：确保进程按到达时间顺序进入调度队列。
- **状态标记**：
    - `run`：当前正在运行的进程。
    - `ready`：已到达但未运行的进程。
    - `complete`：已完成的进程。
    - `null`：尚未到达的进程。
- **输出格式**：每1ms记录一次调度状态，并将结果写入 `result.txt`。
- **进程完成处理**：当进程完成时，记录其完成时间、周转时间和带权周转时间，并输出相关信息。

### 6.2 修改后的 `performFCFS` 方法

确保 `performFCFS` 方法使用一致的字段名称，并生成与 C++ 版本相同的输出格式。

```java
private static void performFCFS() {
    System.out.println("\n=== 先来先服务调度（FCFS） ===");
    List<PCB> sortedProcesses = new ArrayList<>(processes);
    sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

    int currentTime = 0;
    for (PCB pro : sortedProcesses) {
        if (currentTime < pro.startTime) {
            currentTime = pro.startTime;
        }
        pro.firstTime = currentTime;
        pro.status = "执行";
        currentTime += pro.runTime;
        pro.finishTime = currentTime;
        pro.turnoverTime = pro.finishTime - pro.startTime;
        pro.weightedTurnoverTime = pro.originalRunTime > 0
                ? (double) pro.turnoverTime / pro.originalRunTime
                : 0.0;
        pro.status = "完成";
    }

    // 保存与显示结果
    try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", true))) { // 追加模式
        resultFile.println("\n=== 先来先服务调度（FCFS） ===");
        resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
        for (PCB process : sortedProcesses) {
            resultFile.println(process.proName + "\t"
                    + process.startTime + "\t"
                    + process.originalRunTime + "\t"
                    + process.firstTime + "\t"
                    + process.finishTime + "\t"
                    + process.turnoverTime + "\t"
                    + String.format("%.2f", process.weightedTurnoverTime));
        }
        System.out.println("FCFS 调度完成，结果已保存到 result.txt");
    } catch (IOException e) {
        System.err.println("错误：无法打开 result.txt 进行结果保存");
        e.printStackTrace();
    }
}
```

### 说明

- **排序**：按到达时间排序进程。
- **调度**：依次执行每个进程，记录开始时间、完成时间、周转时间和带权周转时间。
- **输出**：将调度结果追加到 `result.txt` 文件中。

## 7. 修改 `displayProcessInfo` 和 `displayProgramDetails` 方法

确保这些方法使用正确的字段名称，并准确显示进程和程序信息。

### 7.1 修改后的 `displayProcessInfo` 方法

```java
// 显示进程信息 
private static void displayProcessInfo() {
    System.out.println("\n===== 进程信息 =====");
    System.out.printf("%-12s%-12s%-12s%-15s%-15s\n", "进程名", "到达时间", "优先级", "程序名称", "状态");
    System.out.println("------------------------------------------------------------------");
    for (PCB pro : processes) {
        System.out.printf("%-12s%-12d%-12d%-15s%-15s\n",
                pro.proName,
                pro.startTime,
                pro.priority,
                pro.programName,
                pro.status);
    }
}
```

### 7.2 修改后的 `displayProgramDetails` 方法

```java
// 显示程序详细信息
private static void displayProgramDetails() {
    System.out.println("\n===== 程序详细信息 =====");
    for (ProgramInfo prog : programs.values()) {
        System.out.println("程序: " + prog.programName);
        System.out.println("包含的函数\t大小");
        for (FunctionInfo func : prog.functions) {
            System.out.println(func.funcName + "\t" + func.size + "k");
        }
        System.out.println();
    }
}
```

### 说明

- **格式一致性**：确保输出格式清晰，字段对齐。
- **字段名称**：使用与 `PCB` 类中定义的字段名称一致。

## 8. 完整的修正后的 Java 代码

以下是修正后的完整 Java 代码，确保所有方法和字段名称一致，并正确读取进程的运行时间。

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;

public class RoundRobinScheduler {

    // PCB 类定义
    static class PCB {
        String proName;                   // 进程名称
        int startTime;                    // 到达时间
        int priority;                     // 优先级
        int runTime;                      // 运行时间（剩余）
        int originalRunTime;              // 原始运行时间
        String programName;               // 关联的程序名称
        int firstTime;                    // 开始运行时间
        int finishTime;                   // 完成时间
        double turnoverTime;              // 周转时间
        double weightedTurnoverTime;      // 带权周转时间
        String status;                    // 状态

        PCB(String proName, int startTime, int priority, int runTime, String programName) {
            this.proName = proName;
            this.startTime = startTime;
            this.priority = priority;
            this.runTime = runTime;
            this.originalRunTime = runTime;
            this.programName = programName;
            this.firstTime = -1;
            this.finishTime = 0;
            this.turnoverTime = 0.0;
            this.weightedTurnoverTime = 0.0;
            this.status = "等待";
        }
    }

    // RUN 类定义（如有需要，可以扩展）
    static class RUN {
        String currentProgram;
        int jumpTime;
        double address;

        RUN(String currentProgram, int jumpTime, double address) {
            this.currentProgram = currentProgram;
            this.jumpTime = jumpTime;
            this.address = address;
        }
    }

    // ProgramInfo 类定义
    static class ProgramInfo {
        String programName;
        List<FunctionInfo> functions;

        ProgramInfo(String programName) {
            this.programName = programName;
            this.functions = new ArrayList<>();
        }
    }

    // FunctionInfo 类定义
    static class FunctionInfo {
        String funcName;
        double size;

        FunctionInfo(String funcName, double size) {
            this.funcName = funcName;
            this.size = size;
        }
    }

    // 全局变量
    private static List<PCB> processes = new ArrayList<>();
    private static List<RUN> runSteps = new ArrayList<>();
    private static Map<String, ProgramInfo> programs = new HashMap<>();

    public static void main(String[] args) {
        // 创建 Scanner 对象（如果需要用户输入）
        Scanner scanner = new Scanner(System.in);

        // 加载 run.txt 中的运行时间
        Map<String, Integer> runTimes = loadRunTimes("run.txt");

        // 读取 Process.txt，传递 runTimes 以设置 runTime
        readProcess("Process.txt", runTimes);

        // 读取 program.txt 文件
        readProgramDetails("program.txt");

        // 显示进程信息和程序详细信息（可选）
        displayProcessInfo();
        displayProgramDetails();

        // 执行调度算法
        performRR();
        performFCFS(); // 如果需要同时运行 FCFS

        scanner.close();
    }

    // 获取用户选择，并验证输入 
    private static int getUserChoice(Scanner scanner, int min, int max) {
        int choice = -1;
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                choice = Integer.parseInt(input);
                if (choice >= min && choice <= max) {
                    break;
                } else {
                    System.out.print("输入无效，请输入一个介于 " + min + " 和 " + max + " 之间的整数: ");
                }
            } catch (NumberFormatException e) {
                System.out.print("输入无效，请输入一个整数: ");
            }
        }
        return choice;
    }

    // 加载 run.txt 中的运行时间
    private static Map<String, Integer> loadRunTimes(String filename) {
        Map<String, Integer> runTimes = new HashMap<>();
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                // 检测是否为程序名行
                if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                    }
                    continue;
                }
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: run.txt 中的行格式不正确: " + line);
                    continue;
                }
                int timestamp;
                String operation;
                try {
                    timestamp = Integer.parseInt(parts[0]);
                    operation = parts[1];
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                    continue;
                }
                if (operation.equals("结束") || operation.equals("End")) {
                    runTimes.put(currentProgram, Math.max(runTimes.getOrDefault(currentProgram, 0), timestamp));
                }
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
        return runTimes;
    }

    // 读取 Process.txt 文件
    private static void readProcess(String filename, Map<String, Integer> runTimes) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            boolean isFirstLine = true;
            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    // 跳过表头
                    isFirstLine = false;
                    continue;
                }
                if (line.trim().isEmpty()) continue;
                String[] parts = line.trim().split("\\s+");
                if (parts.length < 4) {
                    System.err.println("警告: Process.txt 中的行格式不正确: " + line);
                    continue;
                }
                String proName = parts[0];
                int createTime;
                int priority;
                String programName = parts[3];
                try {
                    createTime = Integer.parseInt(parts[1]);
                    priority = Integer.parseInt(parts[2]);
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析创建时间或优先级: " + line);
                    continue;
                }
                int runTime = runTimes.getOrDefault(programName, 0);
                if (runTime == 0) {
                    System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
                }
                PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
                processes.add(pcb);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 读取 run.txt 文件（如果需要存储 runSteps）
    private static void readRunSteps(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                // 检测是否为程序名行
                if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                    }
                    continue;
                }
                String[] parts = line.split("\\s+");
                if (parts.length < 3) {
                    System.err.println("警告: run.txt 中的行格式不正确: " + line);
                    continue;
                }
                int jumpTime;
                String operation;
                double address;
                try {
                    jumpTime = Integer.parseInt(parts[0]);
                    operation = parts[1];
                    if (operation.equals("结束") || operation.equals("End")) {
                        address = -1;
                    } else {
                        address = Double.parseDouble(parts[2]);
                    }
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析行中的数值: " + line);
                    continue;
                }
                RUN run = new RUN(currentProgram, jumpTime, address);
                runSteps.add(run);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 读取 program.txt 文件
    private static void readProgramDetails(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                // 检测是否为 FName 行
                if (line.startsWith("文件名") || line.startsWith("FName")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                        programs.put(currentProgram, new ProgramInfo(currentProgram));
                    }
                    continue;
                }
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: program.txt 中的行格式不正确: " + line);
                    continue;
                }
                String funcName = parts[0];
                double size;
                try {
                    size = Double.parseDouble(parts[1].replace("k", "").replace("K", ""));
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析函数大小: " + line);
                    continue;
                }
                FunctionInfo func = new FunctionInfo(funcName, size);
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: program.txt 中的函数未关联到任何程序: " + line);
                    continue;
                }
                programs.get(currentProgram).functions.add(func);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 显示进程信息 
    private static void displayProcessInfo() {
        System.out.println("\n===== 进程信息 =====");
        System.out.printf("%-12s%-12s%-12s%-15s%-15s\n", "进程名", "到达时间", "优先级", "程序名称", "状态");
        System.out.println("------------------------------------------------------------------");
        for (PCB pro : processes) {
            System.out.printf("%-12s%-12d%-12d%-15s%-15s\n",
                    pro.proName,
                    pro.startTime,
                    pro.priority,
                    pro.programName,
                    pro.status);
        }
    }

    // 显示程序详细信息
    private static void displayProgramDetails() {
        System.out.println("\n===== 程序详细信息 =====");
        for (ProgramInfo prog : programs.values()) {
            System.out.println("程序: " + prog.programName);
            System.out.println("包含的函数\t大小");
            for (FunctionInfo func : prog.functions) {
                System.out.println(func.funcName + "\t" + func.size + "k");
            }
            System.out.println();
        }
    }

    // 修改后的 performRR 方法
    private static void performRR() {
        System.out.println("\n=== 时间片轮转调度（RR） ===");
        // 时间片长度固定为1ms
        int timeQuantum = 1;

        // 按到达时间排序
        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime));

        Queue<PCB> readyQueue = new LinkedList<>();
        int currentTime = 0;
        int index = 0; // 用于跟踪哪些进程已被加入队列

        // 使用Map来跟踪每个进程的剩余运行时间
        Map<String, Integer> remainingTimeMap = new HashMap<>();
        for (PCB process : sortedProcesses) {
            remainingTimeMap.put(process.proName, process.runTime);
        }

        // 准备写入result.txt文件
        try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", false))) { // 覆盖模式打开，避免重复
            // 输出表头
            resultFile.print("时间片\t运行的进程\t");
            for (PCB process : sortedProcesses) {
                resultFile.print("进程" + process.proName + "状态\t");
            }
            resultFile.println();

            // 主调度循环
            while (!readyQueue.isEmpty() || index < sortedProcesses.size()) {
                // 将当前时间的进程加入队列
                while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                    PCB newProcess = sortedProcesses.get(index);
                    readyQueue.offer(newProcess);
                    newProcess.status = "就绪";
                    System.out.println("进程: " + newProcess.proName + " 在 " + currentTime + " ms 时被加入队列");
                    index++;
                }

                // 如果队列为空，记录空闲时间片
                if (readyQueue.isEmpty()) {
                    // 输出空闲时间片状态
                    resultFile.print(currentTime + "\t" + "null\t");
                    for (PCB process : sortedProcesses) {
                        if (process.startTime > currentTime) {
                            resultFile.print("null\t");
                        } else if (remainingTimeMap.get(process.proName) == 0) {
                            resultFile.print("complete\t");
                        } else {
                            resultFile.print("ready\t");
                        }
                    }
                    resultFile.println();
                    currentTime++;
                    continue;
                }

                // 从队列中取出一个进程
                PCB currentProcess = readyQueue.poll();

                // 如果是第一次运行，设置开始时间
                if (currentProcess.firstTime == -1) {
                    currentProcess.firstTime = currentTime;
                }

                // 执行一个时间片
                int execTime = Math.min(timeQuantum, remainingTimeMap.get(currentProcess.proName));
                remainingTimeMap.put(currentProcess.proName, remainingTimeMap.get(currentProcess.proName) - execTime);
                currentProcess.runTime -= execTime;
                int startExecTime = currentTime;
                currentTime += execTime;

                // 更新进程状态
                if (remainingTimeMap.get(currentProcess.proName) > 0) {
                    currentProcess.status = "就绪";
                } else {
                    currentProcess.status = "完成";
                    currentProcess.finishTime = currentTime;
                    currentProcess.turnoverTime = currentProcess.finishTime - currentProcess.startTime;
                    currentProcess.weightedTurnoverTime = (double) currentProcess.turnoverTime / currentProcess.originalRunTime;
                }

                // 输出当前时间片的状态
                resultFile.print(startExecTime + "\t" + currentProcess.proName + "\t");

                for (PCB process : sortedProcesses) {
                    if (process.proName.equals(currentProcess.proName)) {
                        if (remainingTimeMap.get(process.proName) > 0) {
                            resultFile.print("run\t");
                        } else {
                            resultFile.print("complete\t");
                        }
                    } else {
                        if (remainingTimeMap.get(process.proName) == 0) {
                            resultFile.print("complete\t");
                        } else if (process.startTime > startExecTime) {
                            resultFile.print("null\t");
                        } else {
                            resultFile.print("ready\t");
                        }
                    }
                }
                resultFile.println();

                // 如果进程未完成，重新加入队列
                if (remainingTimeMap.get(currentProcess.proName) > 0) {
                    readyQueue.offer(currentProcess);
                } else {
                    // 进程完成，输出完成信息
                    resultFile.println("进程 " + currentProcess.proName + " 在 " + currentTime + " ms 完成 "
                            + "| 周转时间： " + currentProcess.turnoverTime
                            + " ms | 带权周转时间： " + String.format("%.2f", currentProcess.weightedTurnoverTime));
                }
            }

            // 输出最终统计信息
            resultFile.println("\n最终统计信息：");
            resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
            for (PCB process : sortedProcesses) {
                resultFile.println(process.proName + "\t"
                        + process.startTime + "\t"
                        + process.originalRunTime + "\t"
                        + process.firstTime + "\t"
                        + process.finishTime + "\t"
                        + process.turnoverTime + "\t"
                        + String.format("%.2f", process.weightedTurnoverTime));
            }

            System.out.println("RR 调度完成，结果已保存到 result.txt");

        } catch (IOException e) {
            System.err.println("错误：无法打开 result.txt 进行结果保存");
            e.printStackTrace();
        }
    }

    // 修改后的 performFCFS 方法
    private static void performFCFS() {
        System.out.println("\n=== 先来先服务调度（FCFS） ===");
        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

        int currentTime = 0;
        for (PCB pro : sortedProcesses) {
            if (currentTime < pro.startTime) {
                currentTime = pro.startTime;
            }
            pro.firstTime = currentTime;
            pro.status = "执行";
            currentTime += pro.runTime;
            pro.finishTime = currentTime;
            pro.turnoverTime = pro.finishTime - pro.startTime;
            pro.weightedTurnoverTime = pro.originalRunTime > 0
                    ? (double) pro.turnoverTime / pro.originalRunTime
                    : 0.0;
            pro.status = "完成";
        }

        // 保存与显示结果
        try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", true))) { // 追加模式
            resultFile.println("\n=== 先来先服务调度（FCFS） ===");
            resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
            for (PCB process : sortedProcesses) {
                resultFile.println(process.proName + "\t"
                        + process.startTime + "\t"
                        + process.originalRunTime + "\t"
                        + process.firstTime + "\t"
                        + process.finishTime + "\t"
                        + process.turnoverTime + "\t"
                        + String.format("%.2f", process.weightedTurnoverTime));
            }
            System.out.println("FCFS 调度完成，结果已保存到 result.txt");
        } catch (IOException e) {
            System.err.println("错误：无法打开 result.txt 进行结果保存");
            e.printStackTrace();
        }
    }

    // 显示进程信息 
    private static void displayProcessInfo() {
        System.out.println("\n===== 进程信息 =====");
        System.out.printf("%-12s%-12s%-12s%-15s%-15s\n", "进程名", "到达时间", "优先级", "程序名称", "状态");
        System.out.println("------------------------------------------------------------------");
        for (PCB pro : processes) {
            System.out.printf("%-12s%-12d%-12d%-15s%-15s\n",
                    pro.proName,
                    pro.startTime,
                    pro.priority,
                    pro.programName,
                    pro.status);
        }
    }

    // 显示程序详细信息
    private static void displayProgramDetails() {
        System.out.println("\n===== 程序详细信息 =====");
        for (ProgramInfo prog : programs.values()) {
            System.out.println("程序: " + prog.programName);
            System.out.println("包含的函数\t大小");
            for (FunctionInfo func : prog.functions) {
                System.out.println(func.funcName + "\t" + func.size + "k");
            }
            System.out.println();
        }
    }

    // 移除或注释掉 saveAndDisplayResults 方法，因为 performRR 和 performFCFS 已直接处理结果保存
    // private static void saveAndDisplayResults(String title, List<PCB> sortedProcesses, String filename) {
    //     // 可以移除此方法，或保留用于其他用途
    // }
}
```

### 说明

1. **`PCB` 类**：现在包含了 `priority` 字段，并确保所有字段名称一致。
2. **`loadRunTimes` 方法**：正确解析 `run.txt`，提取每个程序的 `runTime`。
3. **`readProcess` 方法**：读取 `Process.txt`，为每个进程分配正确的 `runTime`，并处理优先级。
4. **调度方法**：
    - **`performRR`**：实现了时间片轮转调度（RR），并将调度过程详细记录到 `result.txt` 中。
    - **`performFCFS`**：实现了先来先服务调度（FCFS），并将结果追加到 `result.txt` 中。
5. **显示方法**：
    - **`displayProcessInfo`** 和 **`displayProgramDetails`**：确保准确显示进程和程序的详细信息。

## 9. 确保输入文件格式正确

请确保您的输入文件（`Process.txt`、`run.txt` 和 `program.txt`）格式正确，并且字段之间使用空格或制表符分隔。例如：

### 9.1 `Process.txt`

```
进程名    进程创建时间    优先级    备注
A进程    0              5        程序A
B进程    1              4        程序B
C进程    3              7        程序C
D进程    6              5        程序D
E进程    8              6        程序E
```

### 9.2 `run.txt`

```
程序名    程序A
关键时间节点    操作类型    跳转目的地
5           跳转        1021
10          跳转        2021
20          读写磁盘    10
30          跳转        2031
20          跳转        4050
100         结束

程序名    程序B
关键时间节点    操作类型    跳转目的地
...
```

### 9.3 `program.txt`

```
文件名    程序A
包含的函数    大小
main       0.6k
A1         1.2k
A2         1.2k
A3         1.5k
A4         0.8k

文件名    程序B
包含的函数    大小
...
```

## 10. 编译和运行

1. **编译**：确保您的 Java 文件（如 `RoundRobinScheduler.java`）位于项目的根目录中，并且所有输入文件 (`Process.txt`、`run.txt`、`program.txt`) 也位于同一目录。
    
2. **运行**：在命令行中运行 Java 程序：
    
    ```bash
    javac RoundRobinScheduler.java
    java RoundRobinScheduler
    ```
    
3. **输出**：程序将生成 `result.txt` 文件，记录调度过程和最终统计信息。
    

## 11. 示例输出

假设您的输入文件内容如下：

### `Process.txt`

```
进程名    进程创建时间    优先级    备注
A进程    0              5        程序A
B进程    1              4        程序B
C进程    3              7        程序C
D进程    6              5        程序D
E进程    8              6        程序E
```

### `run.txt`

```
程序名    程序A
关键时间节点    操作类型    跳转目的地
5           跳转        1021
10          跳转        2021
20          读写磁盘    10
30          跳转        2031
20          跳转        4050
100         结束

程序名    程序B
关键时间节点    操作类型    跳转目的地
...
```

### `program.txt`

```
文件名    程序A
包含的函数    大小
main       0.6k
A1         1.2k
A2         1.2k
A3         1.5k
A4         0.8k

文件名    程序B
包含的函数    大小
...
```

### `result.txt` 的部分内容

```
时间片	运行的进程	进程A状态	进程B状态	进程C状态	进程D状态	进程E状态	
0	A	run	null	null	null	null	
1	B	run	ready	null	null	null	
2	C	run	ready	ready	null	null	
3	D	run	ready	ready	ready	null	
4	A	run	ready	ready	ready	null	
5	A	run	ready	ready	ready	null	
...
进程 A 在 100 ms 完成 | 周转时间： 100.0 ms | 带权周转时间： 20.00

最终统计信息：
进程名	到达时间	运行时间	开始时间	完成时间	周转时间	带权周转时间
A进程	0	100	0	100	100.0	20.00
B进程	1	...	...	...	...	...
...
```

## 12. 总结

通过上述修改，您的 Java 程序现在能够：

1. **正确读取进程的运行时间**：从 `run.txt` 中提取每个程序的总运行时间，并将其分配给对应的进程。
2. **生成与 C++ 版本相同的输出格式**：每1ms记录一次调度状态，包括运行的进程和各个进程的状态。
3. **处理调度算法**：实现了时间片轮转调度（RR）和先来先服务调度（FCFS），并将结果保存到 `result.txt` 中。

### 注意事项

1. **输入文件格式**：确保所有输入文件的格式正确，字段之间使用空格或制表符分隔，且文件中无多余的空行或错误行。
2. **错误处理**：程序会在控制台输出警告信息，指示任何格式不正确或数据缺失的行。请根据这些警告检查并修正输入文件。
3. **文件路径**：确保 `Process.txt`、`run.txt` 和 `program.txt` 文件位于项目的根目录中，或根据需要调整文件路径。
4. **资源管理**：使用 `try-with-resources` 语句确保文件正确关闭，避免资源泄漏。

如果在编译或运行过程中仍遇到错误，请提供具体的错误信息，以便进一步诊断和解决问题。

希望这些修改和建议能够帮助您成功实现 Java 版本的时间片轮转调度（RR）和先来先服务调度（FCFS）算法。如果有任何进一步的问题或需要更多帮助，请随时提问！