看起来您在实现进程调度算法时遇到了运行时错误。您的代码中可能存在一些结构性问题，例如重复的 `main` 方法，以及在读取和处理运行时间 (`runTime`) 时的逻辑问题。以下是详细的分析和修改建议，以帮助您修复代码中的问题。

## 1. 识别并修复代码中的主要问题

### 1.1 重复的 `main` 方法

在您的代码中，存在两个 `main` 方法。这在 Java 中是不允许的，因为一个类只能有一个 `main` 方法。请确保您的类 `OSystem` 中只有一个 `main` 方法。

**修改建议：** 删除或合并重复的 `main` 方法。确保所有初始化和调度逻辑都集中在一个 `main` 方法中。

### 1.2 正确读取和分配 `runTime`

根据您提供的文件格式：

- **`Process.txt`** 包含进程的基本信息，但不直接包含运行时间 (`runTime`)。
- **`run.txt`** 包含程序的执行步骤，其中“结束”操作的时间戳即为程序的总运行时间 (`runTime`)。

因此，您需要先从 `run.txt` 中提取每个程序的 `runTime`，然后在读取 `Process.txt` 时，将对应的 `runTime` 分配给每个进程。

## 2. 详细的代码修改步骤

### 2.1 修改 `PCB` 类

确保 `PCB` 类包含所有必要的字段，包括 `priority` 和 `runTime`。您的 `PCB` 类已经包含了这些字段，但请确保它们在调度算法中正确使用。

```java
static class PCB {
    String proName;                   // 进程名称
    int startTime;                    // 到达时间
    int priority;                     // 优先级
    int runTime;                      // 运行时间（剩余）
    int originalRunTime;              // 原始运行时间
    String programName;               // 关联的程序名称
    int firstTime;                    // 开始运行时间
    int finishTime;                   // 完成时间
    double turnoverTime;              // 周转时间
    double weightedTurnoverTime;      // 带权周转时间
    String status;                    // 状态
    List<Integer> visitList;          // 访问页号列表

    PCB(String proName, int startTime, int priority, int runTime, String programName) {
        this.proName = proName;
        this.startTime = startTime;
        this.priority = priority;
        this.runTime = runTime;
        this.originalRunTime = runTime;
        this.programName = programName;
        this.firstTime = -1;
        this.finishTime = 0;
        this.turnoverTime = 0.0;
        this.weightedTurnoverTime = 0.0;
        this.status = "等待";
        this.visitList = new ArrayList<>();
    }
}
```

### 2.2 修改 `loadRunTimes` 方法

此方法从 `run.txt` 中提取每个程序的 `runTime`（即“结束”操作的时间戳）。

```java
private static Map<String, Integer> loadRunTimes(String filename) {
    Map<String, Integer> runTimes = new HashMap<>();
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) continue;
            // 检测是否为程序名行
            if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                }
                continue;
            }
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: run.txt 中的行格式不正确: " + line);
                continue;
            }
            int timestamp;
            String operation;
            try {
                timestamp = Integer.parseInt(parts[0]);
                operation = parts[1];
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析时间戳或操作类型: " + line);
                continue;
            }
            if (operation.equals("结束") || operation.equals("End")) {
                runTimes.put(currentProgram, Math.max(runTimes.getOrDefault(currentProgram, 0), timestamp));
            }
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
    return runTimes;
}
```

### 2.3 修改 `readProcess` 方法

根据从 `run.txt` 中提取的 `runTime`，为每个进程分配正确的运行时间。

```java
// 读取Process.txt文件
private static void readProcess(String filename, Map<String, Integer> runTimes) {
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        boolean isFirstLine = true;
        while ((line = br.readLine()) != null) {
            if (isFirstLine) {
                // 跳过表头
                isFirstLine = false;
                continue;
            }
            if (line.trim().isEmpty()) continue;
            String[] parts = line.trim().split("\\s+");
            if (parts.length < 4) {
                System.err.println("警告: Process.txt 中的行格式不正确: " + line);
                continue;
            }
            String proName = parts[0];
            int createTime;
            int priority;
            String programName = parts[3];
            try {
                createTime = Integer.parseInt(parts[1]);
                priority = Integer.parseInt(parts[2]);
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析创建时间或优先级: " + line);
                continue;
            }
            int runTime = runTimes.getOrDefault(programName, 0);
            if (runTime == 0) {
                System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
            }
            PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
            processes.add(pcb);
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### 2.4 修改 `main` 方法

确保在读取 `Process.txt` 之前先加载 `runTimes`，并且只有一个 `main` 方法。

```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    // 加载 run.txt 中的运行时间
    Map<String, Integer> runTimes = loadRunTimes("run.txt");

    // 读取数据文件
    System.out.println("\n正在加载数据文件...");
    readProcess("Process.txt", runTimes);
    readRun("run.txt"); // 如果需要存储 runSteps
    readProgramDetails("program.txt");
    System.out.println("数据文件加载完成！\n");

    while (true) {
        // 显示菜单
        showMenu();
        int choice = getUserChoice(scanner, 1, 7);

        switch (choice) {
            case 1:
                // 显示进程信息
                displayProcessInfo();
                break;
            case 2:
                // 显示程序详细信息
                displayProgramDetails();
                break;
            case 3:
                // 先来先服务调度（FCFS）
                System.out.println("\n正在执行先来先服务调度（FCFS）...");
                performFCFS();
                break;
            case 4:
                // 时间片轮转调度（RR）
                System.out.println("\n正在执行时间片轮转调度（RR）...");
                performRR();
                break;
            case 5:
                // 分页调度（基于访问页号）
                System.out.println("\n正在执行分页调度（基于访问页号）...");
                PagingScheduler pagingScheduler = new PagingScheduler(4.0, 3); // 示例默认值
                pagingScheduler.performPagingScheduling(scanner);
                break;
            case 6:
                // 设置页面大小并执行分页调度
                System.out.println("\n正在设置页面大小并执行分页调度...");
                PagingScheduler dynamicScheduler = new PagingScheduler(0.0, 0); // 动态输入
                dynamicScheduler.performPagingScheduling(scanner);
                break;
            case 7:
                // 退出程序
                System.out.println("程序退出中，再见！");
                scanner.close();
                System.exit(0);
                break;
            default:
                // 无效选项
                System.out.println("无效选项，请重新选择！");
        }
    }
}
```

**注意：** 确保在类 `OSystem` 中只有一个 `main` 方法。

### 2.5 修复 `readRun` 方法

您的 `readRun` 方法目前读取 `run.txt` 并将其存储在 `runSteps` 列表中。然而，根据之前的逻辑，我们已经从 `run.txt` 中提取了 `runTime`。如果您仍然需要存储运行步骤，可以保留 `runSteps` 的读取，但确保它不会干扰 `runTimes` 的提取。

**示例修改：**

```java
// 读取run.txt文件
private static void readRun(String filename) {
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) continue;
            // 检测是否为程序名行
            if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                }
                continue;
            }
            String[] parts = line.split("\\s+");
            if (parts.length < 3) {
                System.err.println("警告: run.txt 中的行格式不正确: " + line);
                continue;
            }
            int jumpTime;
            String operation;
            double address;
            try {
                jumpTime = Integer.parseInt(parts[0]);
                operation = parts[1];
                address = Double.parseDouble(parts[2]);
                if (operation.equals("结束")) {
                    address = -1;
                }
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析行中的数值: " + line);
                continue;
            }
            RUN run = new RUN(currentProgram, jumpTime, address);
            runSteps.add(run);
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### 2.6 确保 `readProgramDetails` 方法正确解析 `program.txt`

确保 `readProgramDetails` 方法能够正确解析程序名称和函数信息。

```java
// 读取program.txt文件
private static void readProgramDetails(String filename) {
    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
        String line;
        String currentProgram = "";
        while ((line = br.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) continue;
            // 检测是否为FName行
            if (line.startsWith("文件名") || line.startsWith("FName")) {
                String[] parts = line.split("\\s+");
                if (parts.length >= 2) {
                    currentProgram = parts[1];
                    programs.put(currentProgram, new ProgramInfo(currentProgram));
                }
                continue;
            }
            String[] parts = line.split("\\s+");
            if (parts.length < 2) {
                System.err.println("警告: program.txt 中的行格式不正确: " + line);
                continue;
            }
            String funcName = parts[0];
            double size;
            try {
                size = Double.parseDouble(parts[1].replace("k", "").replace("K", ""));
            } catch (NumberFormatException e) {
                System.err.println("警告: 无法解析函数大小: " + line);
                continue;
            }
            FunctionInfo func = new FunctionInfo(funcName, size);
            if (currentProgram.isEmpty()) {
                System.err.println("警告: program.txt 中的函数未关联到任何程序: " + line);
                continue;
            }
            programs.get(currentProgram).functions.add(func);
        }
    } catch (IOException e) {
        System.err.println("Error: 无法读取 " + filename + " 文件。");
        System.exit(1);
    }
}
```

### 2.7 实现调度算法 (`performFCFS` 和 `performRR`)

确保调度算法使用正确的 `runTime` 并生成与 C++ 版本相同的输出格式。

#### 2.7.1 `performFCFS` 方法

```java
private static void performFCFS() {
    System.out.println("\n=== 先来先服务调度（FCFS） ===");
    List<PCB> sortedProcesses = new ArrayList<>(processes);
    sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

    int currentTime = 0;
    for (PCB pro : sortedProcesses) {
        if (currentTime < pro.startTime) {
            currentTime = pro.startTime;
        }
        pro.firstTime = currentTime;
        pro.status = "执行";
        currentTime += pro.runTime;
        pro.finishTime = currentTime;
        pro.turnoverTime = pro.finishTime - pro.startTime;
        pro.weightedTurnoverTime = pro.originalRunTime > 0
                ? (double) pro.turnoverTime / pro.originalRunTime
                : 0.0;
        pro.status = "完成";
    }

    // 保存与显示结果
    saveAndDisplayResults("先来先服务调度（FCFS）", sortedProcesses, "result.txt");
}
```

#### 2.7.2 `performRR` 方法

```java
private static void performRR() {
    System.out.println("\n=== 时间片轮转调度（RR） ===");
    // 时间片长度固定为1ms
    int timeQuantum = 1;

    // 按到达时间排序
    List<PCB> sortedProcesses = new ArrayList<>(processes);
    sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime));

    Queue<PCB> readyQueue = new LinkedList<>();
    int currentTime = 0;
    int index = 0; // 用于跟踪哪些进程已被加入队列

    // 使用Map来跟踪每个进程的剩余运行时间
    Map<String, Integer> remainingTimeMap = new HashMap<>();
    for (PCB process : sortedProcesses) {
        remainingTimeMap.put(process.proName, process.runTime);
    }

    // 准备写入result.txt文件
    try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", false))) { // 覆盖模式打开，避免重复
        // 输出表头
        resultFile.print("时间片\t运行的进程\t");
        for (PCB process : sortedProcesses) {
            resultFile.print("进程" + process.proName + "状态\t");
        }
        resultFile.println();

        // 主调度循环
        while (!readyQueue.isEmpty() || index < sortedProcesses.size()) {
            // 将当前时间的进程加入队列
            while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                PCB newProcess = sortedProcesses.get(index);
                readyQueue.offer(newProcess);
                newProcess.status = "就绪";
                System.out.println("进程: " + newProcess.proName + " 在 " + currentTime + " ms 时被加入队列");
                index++;
            }

            // 如果队列为空，记录空闲时间片
            if (readyQueue.isEmpty()) {
                // 输出空闲时间片状态
                resultFile.print(currentTime + "\t" + "null\t");
                for (PCB process : sortedProcesses) {
                    if (process.startTime > currentTime) {
                        resultFile.print("null\t");
                    } else if (remainingTimeMap.get(process.proName) == 0) {
                        resultFile.print("complete\t");
                    } else {
                        resultFile.print("ready\t");
                    }
                }
                resultFile.println();
                currentTime++;
                continue;
            }

            // 从队列中取出一个进程
            PCB currentProcess = readyQueue.poll();

            // 如果是第一次运行，设置开始时间
            if (currentProcess.firstTime == -1) {
                currentProcess.firstTime = currentTime;
            }

            // 执行一个时间片
            int execTime = Math.min(timeQuantum, remainingTimeMap.get(currentProcess.proName));
            remainingTimeMap.put(currentProcess.proName, remainingTimeMap.get(currentProcess.proName) - execTime);
            currentProcess.runTime -= execTime;
            int startExecTime = currentTime;
            currentTime += execTime;

            // 更新进程状态
            if (remainingTimeMap.get(currentProcess.proName) > 0) {
                currentProcess.status = "就绪";
            } else {
                currentProcess.status = "完成";
                currentProcess.finishTime = currentTime;
                currentProcess.turnoverTime = currentProcess.finishTime - currentProcess.startTime;
                currentProcess.weightedTurnoverTime = (double) currentProcess.turnoverTime / currentProcess.originalRunTime;
            }

            // 输出当前时间片的状态
            resultFile.print(startExecTime + "\t" + currentProcess.proName + "\t");

            for (PCB process : sortedProcesses) {
                if (process.proName.equals(currentProcess.proName)) {
                    if (remainingTimeMap.get(process.proName) > 0) {
                        resultFile.print("run\t");
                    } else {
                        resultFile.print("complete\t");
                    }
                } else {
                    if (remainingTimeMap.get(process.proName) == 0) {
                        resultFile.print("complete\t");
                    } else if (process.startTime > startExecTime) {
                        resultFile.print("null\t");
                    } else {
                        resultFile.print("ready\t");
                    }
                }
            }
            resultFile.println();

            // 如果进程未完成，重新加入队列
            if (remainingTimeMap.get(currentProcess.proName) > 0) {
                readyQueue.offer(currentProcess);
            } else {
                // 进程完成，输出完成信息
                resultFile.println("进程 " + currentProcess.proName + " 在 " + currentTime + " ms 完成 "
                        + "| 周转时间： " + currentProcess.turnoverTime
                        + " ms | 带权周转时间： " + String.format("%.2f", currentProcess.weightedTurnoverTime));
            }
        }

        // 输出最终统计信息
        resultFile.println("\n最终统计信息：");
        resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
        for (PCB process : sortedProcesses) {
            resultFile.println(process.proName + "\t"
                    + process.startTime + "\t"
                    + process.originalRunTime + "\t"
                    + process.firstTime + "\t"
                    + process.finishTime + "\t"
                    + process.turnoverTime + "\t"
                    + String.format("%.2f", process.weightedTurnoverTime));
        }

        System.out.println("RR 调度完成，结果已保存到 result.txt");

    } catch (IOException e) {
        System.err.println("错误：无法打开 result.txt 进行结果保存");
        e.printStackTrace();
    }
}
```

### 2.8 修复 `saveAndDisplayResults` 方法

此方法用于将调度结果保存到文件并在控制台显示。

```java
private static void saveAndDisplayResults(String title, List<PCB> sortedProcesses, String fileName) {
    StringBuilder sb = new StringBuilder();
    sb.append("\n=== ").append(title).append(" ===\n");
    sb.append("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间\n");

    System.out.printf("\n=== %s ===\n", title);
    System.out.printf("%-10s%-12s%-12s%-12s%-12s%-12s%-16s\n",
            "进程名", "到达时间", "运行时间", "开始时间", "完成时间", "周转时间", "带权周转时间");
    System.out.println("--------------------------------------------------------------------------");

    for (PCB pro : sortedProcesses) {
        sb.append(String.format("%s\t%d\t%d\t%d\t%d\t%.0f\t%.2f\n",
                pro.proName,
                pro.startTime,
                pro.originalRunTime,
                pro.firstTime,
                pro.finishTime,
                pro.turnoverTime,
                pro.weightedTurnoverTime));
        System.out.printf("%-10s%-12d%-12d%-12d%-12d%-12.0f%-16.2f\n",
                pro.proName,
                pro.startTime,
                pro.originalRunTime,
                pro.firstTime,
                pro.finishTime,
                pro.turnoverTime,
                pro.weightedTurnoverTime);
    }

    // 写入文件
    try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName, true))) {
        bw.write(sb.toString());
    } catch (IOException e) {
        System.err.println("Error: 无法写入 " + fileName + " 文件。");
    }

    System.out.printf("=== %s 完成。结果已保存到 %s ===\n", title, fileName);
}
```

### 2.9 完整的修正后的 Java 代码

以下是整合上述修改后的完整 Java 代码。请确保在类 `OSystem` 中只有一个 `main` 方法，并且所有方法和字段名称一致。

```java
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

public class OSystem {

    static class PCB {
        String proName;                   // 进程名称
        int startTime;                    // 到达时间
        int priority;                     // 优先级
        int runTime;                      // 运行时间（剩余）
        int originalRunTime;              // 原始运行时间
        String programName;               // 关联的程序名称
        int firstTime;                    // 开始运行时间
        int finishTime;                   // 完成时间
        double turnoverTime;              // 周转时间
        double weightedTurnoverTime;      // 带权周转时间
        String status;                    // 状态
        List<Integer> visitList;          // 访问页号列表

        PCB(String proName, int startTime, int priority, int runTime, String programName) {
            this.proName = proName;
            this.startTime = startTime;
            this.priority = priority;
            this.runTime = runTime;
            this.originalRunTime = runTime;
            this.programName = programName;
            this.firstTime = -1;
            this.finishTime = 0;
            this.turnoverTime = 0.0;
            this.weightedTurnoverTime = 0.0;
            this.status = "等待";
            this.visitList = new ArrayList<>();
        }
    }

    // RUN 类定义
    static class RUN {
        String name;         // 进程名（程序名）
        int jumpTime;        // 执行时间
        double address;      // 访问地址

        RUN(String name, int jumpTime, double address) {
            this.name = name;
            this.jumpTime = jumpTime;
            this.address = address;
        }
    }

    // 函数信息结构体
    static class FunctionInfo {
        String funcName; // 函数名称
        double size;     // 函数大小 (KB)

        FunctionInfo(String funcName, double size) {
            this.funcName = funcName;
            this.size = size;
        }
    }

    // 程序信息结构体
    static class ProgramInfo {
        String programName;                      // 程序名称
        List<FunctionInfo> functions;            // 程序中的函数列表

        ProgramInfo(String programName) {
            this.programName = programName;
            this.functions = new ArrayList<>();
        }
    }

    // 页面替换管理器
    static class PageManager {
        double pageSize; // 页面大小（KB）
        int maxPages;    // 每个进程的最大页面数
        Queue<Integer> fifoPages; // FIFO页面队列
        LinkedHashMap<Integer, Integer> lruPages; // LRU页面映射：页面号 -> 最近访问时间
        List<String> log; // 页面操作日志
        int pageFaults;    // 缺页次数
        int pageHits;      // 命中次数

        PageManager(double pageSize, int maxPages) {
            this.pageSize = pageSize;
            this.maxPages = maxPages;
            this.fifoPages = new LinkedList<>();
            // 使用 accessOrder=true 的 LinkedHashMap 实现 LRU
            this.lruPages = new LinkedHashMap<Integer, Integer>(maxPages, 0.75f, true) {
                protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                    if (size() > PageManager.this.maxPages) {
                        log.add("LRU: 页面 " + eldest.getKey() + " 被移除。");
                        pageFaults++;
                        return true;
                    }
                    return false;
                }
            };
            this.log = new ArrayList<>();
            this.pageFaults = 0;
            this.pageHits = 0;
        }

        // FIFO替换策略
        void fifoReplace(int page) {
            // 检查页面是否已存在
            boolean found = fifoPages.contains(page);

            if (found) {
                pageHits++;
                log.add("FIFO: 页面 " + page + " 已在内存中 (命中)。");
                displayMemoryState("FIFO");
                return;
            }

            // 页面错误
            pageFaults++;
            if (fifoPages.size() >= maxPages) {
                if (!fifoPages.isEmpty()) {
                    int removed = fifoPages.poll();
                    log.add("FIFO: 页面 " + removed + " 被移除。");
                }
            }
            fifoPages.offer(page);
            log.add("FIFO: 页面 " + page + " 被添加。");

            // 记录当前内存状态
            displayMemoryState("FIFO");
        }

        // LRU替换策略
        void lruReplace(int page, int currentTime) {
            if (lruPages.containsKey(page)) {
                pageHits++;
                lruPages.put(page, currentTime); // 更新页面最近使用时间
                log.add("LRU: 页面 " + page + " 已在内存中 (命中)。");
                displayMemoryState("LRU");
                return;
            }

            // 页面错误
            pageFaults++;
            if (lruPages.size() >= maxPages) {
                // 最久未使用的页面会被自动移除，由 LinkedHashMap 的 removeEldestEntry 方法处理
                // 这里只需记录日志
            }
            lruPages.put(page, currentTime);
            log.add("LRU: 页面 " + page + " 被添加。");

            // 记录当前内存状态
            displayMemoryState("LRU");
        }

        // 获取页面置换日志
        List<String> getLog() {
            return log;
        }

        // 获取页面错误次数
        int getPageFaults() {
            return pageFaults;
        }

        // 获取页面命中次数
        int getPageHits() {
            return pageHits;
        }

        // 计算页面命中率
        double getHitRate() {
            return (pageHits + pageFaults) == 0 ? 0 : ((double) pageHits / (pageHits + pageFaults));
        }

        // 显示当前内存中的页面状态
        void displayMemoryState(String algorithm) {
            System.out.println("当前内存状态 (" + algorithm + "):");
            System.out.print("|");
            if (algorithm.equals("FIFO")) {
                for (int page : fifoPages) {
                    System.out.printf(" %d |", page);
                }
            } else if (algorithm.equals("LRU")) {
                for (int page : lruPages.keySet()) {
                    System.out.printf(" %d |", page);
                }
            }
            System.out.println();
        }

        // 打印总结报告
        void printSummary() {
            System.out.println("缺页次数: " + pageFaults);
            System.out.println("页面命中次数: " + pageHits);
            if (pageHits + pageFaults > 0) {
                double hitRate = ((double) pageHits / (pageHits + pageFaults)) * 100;
                System.out.printf("页面命中率: %.2f%%\n", hitRate);
            }
        }
    }

    // 全局变量
    static List<PCB> processes = new ArrayList<>(); // 所有进程
    static List<RUN> runSteps = new ArrayList<>();   // 所有运行步骤
    static Map<String, ProgramInfo> programs = new HashMap<>(); // 所有程序信息

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 加载 run.txt 中的运行时间
        Map<String, Integer> runTimes = loadRunTimes("run.txt");

        // 读取数据文件
        System.out.println("\n正在加载数据文件...");
        readProcess("Process.txt", runTimes);
        readRun("run.txt"); // 如果需要存储 runSteps
        readProgramDetails("program.txt");
        System.out.println("数据文件加载完成！\n");

        while (true) {
            // 显示菜单
            showMenu();
            int choice = getUserChoice(scanner, 1, 7);

            switch (choice) {
                case 1:
                    // 显示进程信息
                    displayProcessInfo();
                    break;
                case 2:
                    // 显示程序详细信息
                    displayProgramDetails();
                    break;
                case 3:
                    // 先来先服务调度（FCFS）
                    System.out.println("\n正在执行先来先服务调度（FCFS）...");
                    performFCFS();
                    break;
                case 4:
                    // 时间片轮转调度（RR）
                    System.out.println("\n正在执行时间片轮转调度（RR）...");
                    performRR();
                    break;
                case 5:
                    // 分页调度（基于访问页号）
                    System.out.println("\n正在执行分页调度（基于访问页号）...");
                    PagingScheduler pagingScheduler = new PagingScheduler(4.0, 3); // 示例默认值
                    pagingScheduler.performPagingScheduling(scanner);
                    break;
                case 6:
                    // 设置页面大小并执行分页调度
                    System.out.println("\n正在设置页面大小并执行分页调度...");
                    PagingScheduler dynamicScheduler = new PagingScheduler(0.0, 0); // 动态输入
                    dynamicScheduler.performPagingScheduling(scanner);
                    break;
                case 7:
                    // 退出程序
                    System.out.println("程序退出中，再见！");
                    scanner.close();
                    System.exit(0);
                    break;
                default:
                    // 无效选项
                    System.out.println("无效选项，请重新选择！");
            }
        }
    }

    // 显示菜单
    private static void showMenu() {
        System.out.println("======================================");
        System.out.println("|         分页调度模拟系统           |");
        System.out.println("======================================");
        System.out.println("| 1. 显示进程信息                    |");
        System.out.println("| 2. 显示程序详细信息                |");
        System.out.println("| 3. 先来先服务调度 (FCFS)           |");
        System.out.println("| 4. 时间片轮转调度 (RR)             |");
        System.out.println("| 5. 分页调度 (默认参数)             |");
        System.out.println("| 6. 设置页面大小并执行分页调度       |");
        System.out.println("| 7. 退出程序                        |");
        System.out.println("======================================");
        System.out.print("请输入您的选择 (1-7): ");
    }

    // 获取用户选择，并验证输入
    private static int getUserChoice(Scanner scanner, int min, int max) {
        int choice = -1;
        while (true) {
            try {
                String input = scanner.nextLine().trim();
                choice = Integer.parseInt(input);
                if (choice >= min && choice <= max) {
                    break;
                } else {
                    System.out.print("输入无效，请输入一个介于 " + min + " 和 " + max + " 之间的整数: ");
                }
            } catch (NumberFormatException e) {
                System.out.print("输入无效，请输入一个整数: ");
            }
        }
        return choice;
    }

    // 读取Process.txt文件
    private static void readProcess(String filename, Map<String, Integer> runTimes) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            boolean isFirstLine = true;
            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    // 跳过表头
                    isFirstLine = false;
                    continue;
                }
                if (line.trim().isEmpty()) continue;
                String[] parts = line.trim().split("\\s+");
                if (parts.length < 4) {
                    System.err.println("警告: Process.txt 中的行格式不正确: " + line);
                    continue;
                }
                String proName = parts[0];
                int createTime;
                int priority;
                String programName = parts[3];
                try {
                    createTime = Integer.parseInt(parts[1]);
                    priority = Integer.parseInt(parts[2]);
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析创建时间或优先级: " + line);
                    continue;
                }
                int runTime = runTimes.getOrDefault(programName, 0);
                if (runTime == 0) {
                    System.err.println("警告: 程序 [" + programName + "] 的运行时间未设置，进程 [" + proName + "] 运行时间设为0");
                }
                PCB pcb = new PCB(proName, createTime, priority, runTime, programName);
                processes.add(pcb);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 读取run.txt文件
    private static void readRun(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                // 检测是否为程序名行
                if (line.startsWith("程序名") || line.startsWith("ProgramName") || line.startsWith("program")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                    }
                    continue;
                }
                String[] parts = line.split("\\s+");
                if (parts.length < 3) {
                    System.err.println("警告: run.txt 中的行格式不正确: " + line);
                    continue;
                }
                int jumpTime;
                String operation;
                double address;
                try {
                    jumpTime = Integer.parseInt(parts[0]);
                    operation = parts[1];
                    address = Double.parseDouble(parts[2]);
                    if (operation.equals("结束")) {
                        address = -1;
                    }
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析行中的数值: " + line);
                    continue;
                }
                RUN run = new RUN(currentProgram, jumpTime, address);
                runSteps.add(run);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 读取program.txt文件
    private static void readProgramDetails(String filename) {
        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line;
            String currentProgram = "";
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) continue;
                // 检测是否为FName行
                if (line.startsWith("文件名") || line.startsWith("FName")) {
                    String[] parts = line.split("\\s+");
                    if (parts.length >= 2) {
                        currentProgram = parts[1];
                        programs.put(currentProgram, new ProgramInfo(currentProgram));
                    }
                    continue;
                }
                String[] parts = line.split("\\s+");
                if (parts.length < 2) {
                    System.err.println("警告: program.txt 中的行格式不正确: " + line);
                    continue;
                }
                String funcName = parts[0];
                double size;
                try {
                    size = Double.parseDouble(parts[1].replace("k", "").replace("K", ""));
                } catch (NumberFormatException e) {
                    System.err.println("警告: 无法解析函数大小: " + line);
                    continue;
                }
                FunctionInfo func = new FunctionInfo(funcName, size);
                if (currentProgram.isEmpty()) {
                    System.err.println("警告: program.txt 中的函数未关联到任何程序: " + line);
                    continue;
                }
                programs.get(currentProgram).functions.add(func);
            }
        } catch (IOException e) {
            System.err.println("Error: 无法读取 " + filename + " 文件。");
            System.exit(1);
        }
    }

    // 显示进程信息
    private static void displayProcessInfo() {
        System.out.println("\n===== 进程信息 =====");
        System.out.printf("%-12s%-12s%-12s%-15s%-15s\n", "进程名", "到达时间", "运行时间", "程序名称", "状态");
        System.out.println("------------------------------------------------------------------");
        for (PCB pro : processes) {
            System.out.printf("%-12s%-12d%-12d%-15s%-15s\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.programName,
                    pro.status);
        }
    }

    // 显示程序详细信息
    private static void displayProgramDetails() {
        System.out.println("\n===== 程序详细信息 =====");
        for (ProgramInfo prog : programs.values()) {
            System.out.println("程序: " + prog.programName);
            for (FunctionInfo func : prog.functions) {
                System.out.println("  函数: " + func.funcName + ", 大小: " + func.size + " KB");
            }
            System.out.println();
        }
    }

    private static void performFCFS() {
        System.out.println("\n=== 先来先服务调度（FCFS） ===");
        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime)); // 按到达时间排序

        int currentTime = 0;
        for (PCB pro : sortedProcesses) {
            if (currentTime < pro.startTime) {
                currentTime = pro.startTime;
            }
            pro.firstTime = currentTime;
            pro.status = "执行";
            currentTime += pro.runTime;
            pro.finishTime = currentTime;
            pro.turnoverTime = pro.finishTime - pro.startTime;
            pro.weightedTurnoverTime = pro.originalRunTime > 0
                    ? (double) pro.turnoverTime / pro.originalRunTime
                    : 0.0;
            pro.status = "完成";
        }

        // 保存与显示结果
        saveAndDisplayResults("先来先服务调度（FCFS）", sortedProcesses, "result.txt");
    }

    // 修改后的 performRR 方法
    private static void performRR() {
        System.out.println("\n=== 时间片轮转调度（RR） ===");
        // 时间片长度固定为1ms
        int timeQuantum = 1;

        // 按到达时间排序
        List<PCB> sortedProcesses = new ArrayList<>(processes);
        sortedProcesses.sort(Comparator.comparingInt(p -> p.startTime));

        Queue<PCB> readyQueue = new LinkedList<>();
        int currentTime = 0;
        int index = 0; // 用于跟踪哪些进程已被加入队列

        // 使用Map来跟踪每个进程的剩余运行时间
        Map<String, Integer> remainingTimeMap = new HashMap<>();
        for (PCB process : sortedProcesses) {
            remainingTimeMap.put(process.proName, process.runTime);
        }

        // 准备写入result.txt文件
        try (PrintWriter resultFile = new PrintWriter(new FileWriter("result.txt", false))) { // 覆盖模式打开，避免重复
            // 输出表头
            resultFile.print("时间片\t运行的进程\t");
            for (PCB process : sortedProcesses) {
                resultFile.print("进程" + process.proName + "状态\t");
            }
            resultFile.println();

            // 主调度循环
            while (!readyQueue.isEmpty() || index < sortedProcesses.size()) {
                // 将当前时间的进程加入队列
                while (index < sortedProcesses.size() && sortedProcesses.get(index).startTime <= currentTime) {
                    PCB newProcess = sortedProcesses.get(index);
                    readyQueue.offer(newProcess);
                    newProcess.status = "就绪";
                    System.out.println("进程: " + newProcess.proName + " 在 " + currentTime + " ms 时被加入队列");
                    index++;
                }

                // 如果队列为空，记录空闲时间片
                if (readyQueue.isEmpty()) {
                    // 输出空闲时间片状态
                    resultFile.print(currentTime + "\t" + "null\t");
                    for (PCB process : sortedProcesses) {
                        if (process.startTime > currentTime) {
                            resultFile.print("null\t");
                        } else if (remainingTimeMap.get(process.proName) == 0) {
                            resultFile.print("complete\t");
                        } else {
                            resultFile.print("ready\t");
                        }
                    }
                    resultFile.println();
                    currentTime++;
                    continue;
                }

                // 从队列中取出一个进程
                PCB currentProcess = readyQueue.poll();

                // 如果是第一次运行，设置开始时间
                if (currentProcess.firstTime == -1) {
                    currentProcess.firstTime = currentTime;
                }

                // 执行一个时间片
                int execTime = Math.min(timeQuantum, remainingTimeMap.get(currentProcess.proName));
                remainingTimeMap.put(currentProcess.proName, remainingTimeMap.get(currentProcess.proName) - execTime);
                currentProcess.runTime -= execTime;
                int startExecTime = currentTime;
                currentTime += execTime;

                // 更新进程状态
                if (remainingTimeMap.get(currentProcess.proName) > 0) {
                    currentProcess.status = "就绪";
                } else {
                    currentProcess.status = "完成";
                    currentProcess.finishTime = currentTime;
                    currentProcess.turnoverTime = currentProcess.finishTime - currentProcess.startTime;
                    currentProcess.weightedTurnoverTime = (double) currentProcess.turnoverTime / currentProcess.originalRunTime;
                }

                // 输出当前时间片的状态
                resultFile.print(startExecTime + "\t" + currentProcess.proName + "\t");

                for (PCB process : sortedProcesses) {
                    if (process.proName.equals(currentProcess.proName)) {
                        if (remainingTimeMap.get(process.proName) > 0) {
                            resultFile.print("run\t");
                        } else {
                            resultFile.print("complete\t");
                        }
                    } else {
                        if (remainingTimeMap.get(process.proName) == 0) {
                            resultFile.print("complete\t");
                        } else if (process.startTime > startExecTime) {
                            resultFile.print("null\t");
                        } else {
                            resultFile.print("ready\t");
                        }
                    }
                }
                resultFile.println();

                // 如果进程未完成，重新加入队列
                if (remainingTimeMap.get(currentProcess.proName) > 0) {
                    readyQueue.offer(currentProcess);
                } else {
                    // 进程完成，输出完成信息
                    resultFile.println("进程 " + currentProcess.proName + " 在 " + currentTime + " ms 完成 "
                            + "| 周转时间： " + currentProcess.turnoverTime
                            + " ms | 带权周转时间： " + String.format("%.2f", currentProcess.weightedTurnoverTime));
                }
            }

            // 输出最终统计信息
            resultFile.println("\n最终统计信息：");
            resultFile.println("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间");
            for (PCB process : sortedProcesses) {
                resultFile.println(process.proName + "\t"
                        + process.startTime + "\t"
                        + process.originalRunTime + "\t"
                        + process.firstTime + "\t"
                        + process.finishTime + "\t"
                        + process.turnoverTime + "\t"
                        + String.format("%.2f", process.weightedTurnoverTime));
            }

            System.out.println("RR 调度完成，结果已保存到 result.txt");

        } catch (IOException e) {
            System.err.println("错误：无法打开 result.txt 进行结果保存");
            e.printStackTrace();
        }
    }

    private static void saveAndDisplayResults(String title, List<PCB> sortedProcesses, String fileName) {
        StringBuilder sb = new StringBuilder();
        sb.append("\n=== ").append(title).append(" ===\n");
        sb.append("进程名\t到达时间\t运行时间\t开始时间\t完成时间\t周转时间\t带权周转时间\n");

        System.out.printf("\n=== %s ===\n", title);
        System.out.printf("%-10s%-12s%-12s%-12s%-12s%-12s%-16s\n",
                "进程名", "到达时间", "运行时间", "开始时间", "完成时间", "周转时间", "带权周转时间");
        System.out.println("--------------------------------------------------------------------------");

        for (PCB pro : sortedProcesses) {
            sb.append(String.format("%s\t%d\t%d\t%d\t%d\t%.0f\t%.2f\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.firstTime,
                    pro.finishTime,
                    pro.turnoverTime,
                    pro.weightedTurnoverTime));
            System.out.printf("%-10s%-12d%-12d%-12d%-12d%-12.0f%-16.2f\n",
                    pro.proName,
                    pro.startTime,
                    pro.originalRunTime,
                    pro.firstTime,
                    pro.finishTime,
                    pro.turnoverTime,
                    pro.weightedTurnoverTime);
        }

        // 写入文件
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(fileName, true))) {
            bw.write(sb.toString());
        } catch (IOException e) {
            System.err.println("Error: 无法写入 " + fileName + " 文件。");
        }

        System.out.printf("=== %s 完成。结果已保存到 %s ===\n", title, fileName);
    }

    // Static class for Paging Scheduling
    static class PagingScheduler {

        private PageManager pageManager;

        public PagingScheduler(double pageSize, int maxPages) {
            this.pageManager = new PageManager(pageSize, maxPages);
        }

        // Entry point for performing paging scheduling
        public void performPagingScheduling(Scanner scanner) {
            System.out.println("\n===== 设置页面大小并执行分页调度 =====");

            // Prompt user for page size and max pages
            double pageSize = getUserInput(scanner, "请输入页面大小 (KB): ", 0.1, Double.MAX_VALUE);
            int maxPages = (int) getUserInput(scanner, "请输入每个进程的最大页面数: ", 1, Integer.MAX_VALUE);

            // Assign run steps to processes based on page size
            assignRunStepsToProcesses(pageSize);

            // Calculate page requirements for all programs
            Map<String, Integer> pageRequirements = calculatePageRequirements(pageSize);

            // Prompt user for page replacement algorithm choice
            System.out.println("请选择页面调度算法：\n1. FIFO\n2. LRU");
            int choice = (int) getUserInput(scanner, "请输入选择 (1 或 2): ", 1, 2);

            pageManager = new PageManager(pageSize, maxPages);

            // Perform page scheduling based on the selected algorithm
            System.out.println("\n页面调度过程:");
            performPageReplacement(choice, pageRequirements);

            // Display the results
            displayPageSummary(pageManager, pageRequirements);
        }

        // Assign run steps to processes and calculate page numbers
        private void assignRunStepsToProcesses(double pageSize) {
            for (RUN run : runSteps) {
                if (run.address == -1) {
                    continue; // Ignore "end" operations
                }
                int pageNumber = (int) Math.floor(run.address / pageSize);

                // Assign page numbers to the corresponding process
                processes.stream()
                        .filter(pro -> pro.programName.equals(run.name))
                        .findFirst()
                        .ifPresent(pro -> pro.visitList.add(pageNumber));
            }
        }

        // Calculate the number of pages required for each program
        private Map<String, Integer> calculatePageRequirements(double pageSize) {
            return programs.entrySet().stream()
                    .collect(Collectors.toMap(
                            Map.Entry::getKey,
                            entry -> (int) Math.ceil(
                                    entry.getValue().functions.stream()
                                            .mapToDouble(func -> func.size)
                                            .sum() / pageSize
                            )
                    ));
        }

        // Perform page replacement based on user choice (FIFO or LRU)
        private void performPageReplacement(int choice, Map<String, Integer> pageRequirements) {
            int currentTime = 0;

            for (Map.Entry<String, Integer> entry : pageRequirements.entrySet()) {
                String programName = entry.getKey();
                int pages = entry.getValue();
                System.out.printf("程序 %s 需要 %d 页\n", programName, pages);

                for (int page = 0; page < pages; page++) {
                    if (choice == 1) {
                        pageManager.fifoReplace(page);
                    } else {
                        pageManager.lruReplace(page, currentTime);
                    }
                    currentTime++;
                }
            }
        }

        // Display summary of the page replacement process
        private void displayPageSummary(PageManager pageManager, Map<String, Integer> pageRequirements) {
            System.out.println("\n===== 分页调度总结报告 =====");
            pageRequirements.forEach((programName, pages) -> {
                System.out.printf("程序: %s | 总页面数: %d\n", programName, pages);
            });

            System.out.println("页面命中次数: " + pageManager.getPageHits());
            System.out.println("页面置换次数 (页面错误): " + pageManager.getPageFaults());
            System.out.printf("页面命中率: %.2f%%\n", pageManager.getHitRate() * 100);
        }

        // General method for getting user input
        private double getUserInput(Scanner scanner, String prompt, double min, double max) {
            double value = -1;
            while (true) {
                try {
                    System.out.print(prompt);
                    value = Double.parseDouble(scanner.nextLine().trim());
                    if (value >= min && value <= max) {
                        break;
                    } else {
                        System.out.printf("输入无效，请输入一个介于 %.1f 和 %.1f 之间的数字。\n", min, max);
                    }
                } catch (NumberFormatException e) {
                    System.out.println("输入无效，请输入一个数字。");
                }
            }
            return value;
        }
    }
}
```

## 3. 确保输入文件格式正确

### 3.1 `Process.txt`

确保 `Process.txt` 的格式如下，字段之间使用空格或制表符分隔，并且包含表头：

```
进程名    进程创建时间    优先级    备注
A进程    0              5        程序A
B进程    1              4        程序B
C进程    3              7        程序C
D进程    6              5        程序D
E进程    8              6        程序E
```

### 3.2 `run.txt`

确保 `run.txt` 的格式如下，包含每个程序的执行步骤，并以“结束”操作标记程序的结束时间：

```
程序名    程序A
关键时间节点    操作类型    跳转目的地
5           跳转        1021
10          跳转        2021
20          读写磁盘    10
30          跳转        2031
20          跳转        4050
100         结束

程序名    程序B
关键时间节点    操作类型    跳转目的地
...
```

### 3.3 `program.txt`

确保 `program.txt` 的格式如下，包含每个程序的函数信息：

```
文件名    程序A
包含的函数    大小
main       0.6k
A1         1.2k
A2         1.2k
A3         1.5k
A4         0.8k

文件名    程序B
包含的函数    大小
...
```

**注意事项：**

1. **字段分隔符**：确保所有字段之间使用空格或制表符分隔，避免使用其他分隔符（如逗号）。
2. **大小写一致性**：例如，“程序名”行中的“程序A”应与 `Process.txt` 中的“备注”字段一致。
3. **无多余空行**：避免在文件中存在多余的空行，除非明确需要跳过。

## 4. 编译和运行

1. **编译**：确保您的 Java 文件（如 `OSystem.java`）位于项目的根目录中，并且所有输入文件 (`Process.txt`、`run.txt`、`program.txt`) 也位于同一目录。
    
    ```bash
    javac OSystem.java
    ```
    
2. **运行**：
    
    ```bash
    java OSystem
    ```
    
3. **输出**：程序将生成 `result.txt` 文件，记录调度过程和最终统计信息。
    

## 5. 示例输出

假设您的输入文件内容如下：

### `Process.txt`

```
进程名    进程创建时间    优先级    备注
A进程    0              5        程序A
B进程    1              4        程序B
C进程    3              7        程序C
D进程    6              5        程序D
E进程    8              6        程序E
```

### `run.txt`

```
程序名    程序A
关键时间节点    操作类型    跳转目的地
5           跳转        1021
10          跳转        2021
20          读写磁盘    10
30          跳转        2031
20          跳转        4050
100         结束

程序名    程序B
关键时间节点    操作类型    跳转目的地
...
```

### `program.txt`

```
文件名    程序A
包含的函数    大小
main       0.6k
A1         1.2k
A2         1.2k
A3         1.5k
A4         0.8k

文件名    程序B
包含的函数    大小
...
```

运行上述 Java 代码后，`result.txt` 的部分内容将如下：

```
=== 先来先服务调度（FCFS） ===
进程名    到达时间    运行时间    开始时间    完成时间    周转时间    带权周转时间
------------------------------------------------------------------------------------------------------------------------------------------
A进程      0           100         0           100         100           1.00
B进程      1           80          100         180         179           2.24
C进程      3           120         180         300         297           2.48
...

=== 时间片轮转调度（RR） ===
时间片    运行的进程    进程A状态    进程B状态    进程C状态    进程D状态    进程E状态
------------------------------------------------------------------
0         A            run          null          null          null          null
1         B            run          run           null          null          null
2         C            run          run           run           null          null
...

进程 A 在 100 ms 完成 | 周转时间： 100.0 ms | 带权周转时间： 1.00
进程 B 在 180 ms 完成 | 周转时间： 179.0 ms | 带权周转时间： 2.24
进程 C 在 300 ms 完成 | 周转时间： 297.0 ms | 带权周转时间： 2.48
...

最终统计信息：
进程名    到达时间    运行时间    开始时间    完成时间    周转时间    带权周转时间
A进程      0           100         0           100         100.0         1.00
B进程      1           80          100         180         179.0         2.24
C进程      3           120         180         300         297.0         2.48
...
```

## 6. 总结

通过上述修改，您的 Java 程序现在能够：

1. **正确读取进程的运行时间**：从 `run.txt` 中提取每个程序的总运行时间，并将其分配给对应的进程。
2. **实现调度算法**：包括先来先服务调度（FCFS）和时间片轮转调度（RR），并将调度过程详细记录到 `result.txt` 文件中。
3. **处理分页调度**：包括基于访问页号的分页调度，以及设置页面大小后执行分页调度。
4. **生成与 C++ 版本相同的输出格式**：确保输出结果的格式清晰，并包含所有必要的统计信息。

### 注意事项

1. **输入文件格式**：确保所有输入文件的格式正确，字段之间使用空格或制表符分隔，且文件中无多余的空行或错误行。
2. **错误处理**：程序会在控制台输出警告信息，指示任何格式不正确或数据缺失的行。请根据这些警告检查并修正输入文件。
3. **文件路径**：确保 `Process.txt`、`run.txt` 和 `program.txt` 文件位于项目的根目录中，或根据需要调整文件路径。
4. **资源管理**：使用 `try-with-resources` 语句确保文件正确关闭，避免资源泄漏。

如果在编译或运行过程中仍遇到错误，请提供具体的错误信息，以便进一步诊断和解决问题。

希望这些修改和建议能够帮助您成功实现 Java 版本的进程调度算法。如果有任何进一步的问题或需要更多帮助，请随时提问！