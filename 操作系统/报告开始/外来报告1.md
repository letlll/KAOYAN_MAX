# 课设报告

## 一、课设目的

通过课程设计，熟练应用调度算法，如先来先服调度、时间片调度，了解进程和页面调度算法的运行原理，探索如何在实际工程工作中应用调度算法。选择一个实际的进程调度问题，通过实现和分析，培养分析解决实际问题的能力。

---

## 二、课设题目

题目：基 u 4 e 8 e 先来先服调度和时间片调度的进程调度系统实现，设计一个系统，能够分别实现并分析调度调度方案的效率。

---

## 三、系统功能结构

通过对进程和程序模块的分析，设计系统实现如下功能：

1. **进程管理功能**：
   - 进程信息显示（进程名称、创建时间、运行时间、优先级等）
   - 先来先服调度
   - 时间片调度
2. **程序管理功能**：
   - 程序运行步骤加载和显示
   - 程序功能和大小分析
3. **分页调度功能**：
   - FIFO 和 LRU 策略分页调度
   - 调度日志和应用效率计算
4. **模拟 CPU 使用功能**：
   - CPU 模拟运行
   - 操作记录和分析显示

系统功能结构如下图所示：

```
系统功能模块结构：
进程管理 ---------分页调度
     |
程序管理 ---------模拟CPU
```

---

## 四、主要数据结构

在进程和程序管理中，采用下列数据结构：

### **1. PCB：进程控制块**
```cpp
class PCB {
public:
    std::string pName;         // 进程名称
    std::string pRemark;       // 程序名称
    std::string pStatus;       // 进程状态
    int createTime;            // 创建时间
    int runTime;               // 运行时间
    int grade;                 // 优先级
    int startTime;             // 开始时间
    int completeTime;          // 完成时间
    int turnoverTime;          // 周转时间
    double weightedTurnoverTime; // 带权周转时间
    int originalRunTime;       // 原始运行时间
};
```

### **2. PageManager：分页管理**
```cpp
class PageManager {
public:
    double pageSize;               // 页面大小（KB）
    int maxPages;                  // 最大页面数量
    std::queue<int> fifoPages;     // FIFO队列
    std::unordered_map<int, int> lruPages; // LRU是用时间对应的页面
    std::vector<std::string> log;  // 分页操作日志
};
```

---

## 五、系统设计

### **1. 类图：**

系统设计采用下列类：

```
PCB类 ---------进程管理
PageManager类 ---------分页管理
CPU模拟和调度
```

系统依赖关系：PCB 和程序为根本资源，分页和模拟调度为进阶实现。

### **2. 状态图：进程调度流程**

1. 创建进程
2. 进程调度：先来先服（FCFS）和时间片（RR）
3. 最终完成状态调度，计算效率

---

## **六、运行结果显示与分析**

#### **1. FCFS（先来先服务）与 RR（时间片轮转）结果对比**

运行 `Process.txt` 和 `Program.txt` 文件中定义的任务，调度结果显示如下：

|**调度算法**|**进程名称**|**开始时间**|**完成时间**|**周转时间**|**带权周转时间**|
|---|---|---|---|---|---|
|**FCFS**|AProgram|0|70|70|1.00|
||BProgram|70|97|96|3.56|
||CProgram|97|127|124|4.13|
||DProgram|127|155|149|5.32|
||EProgram|155|187|179|5.59|
|**RR**|AProgram|0|187|187|2.67|
||BProgram|4|131|130|4.81|
||CProgram|8|147|144|4.80|
||DProgram|12|141|135|4.82|
||EProgram|16|155|147|4.59|

#### **分析**

1. **FCFS（First-Come, First-Served Scheduling）：**
    
    - 调度的基本策略是按进程创建时间的先后顺序执行。
    - 整个系统中，`AProgram` 从 `0ms` 开始运行，`BProgram` 紧随其后依次执行。
    - 周转时间和带权周转时间相对较小，适用于短任务场景，但不适合时间片竞争激烈的系统。
2. **RR（Round Robin Scheduling）：**
    
    - 时间片调度中，每个进程在一个固定时间片内轮流执行。
    - 结果显示，`AProgram` 作为第一个进程，从 `0ms` 开始多次执行后完成。
    - RR调度更适用于任务长度分布均匀的系统，但增加了调度上下文切换的开销。

---

## 七、课程设计中遇到的问题及解决方法

### **1. 问题：字符编码问题导致程序名称和函数乱码**

- **问题描述**：原始 `run.txt` 和 `program.txt` 文件中包含中文内容，导致在文件读取阶段，程序无法正确解析字符串。
- **解决方法**：统一文件编码为英文，避免了 UTF-8/GBK 等编码兼容性问题。此外，优化了文件解析逻辑，通过动态空格分割，而非固定字节偏移解析。

### **2. 问题：逻辑实现中的队列管理复杂度**

- **问题描述**：在实现时间片轮转调度（RR）时，如何高效管理进程队列及剩余时间，成为实现的关键问题。
- **解决方法**：采用 `std::queue` 实现进程队列，使用 `std::unordered_map` 保存剩余时间，以 O(1) 的复杂度动态更新每个进程的运行状态，优化了调度性能。

### **3. 问题：结果数据不一致**

- **问题描述**：早期代码在 RR 调度中未正确记录 `startTime`，导致计算结果偏差。
- **解决方法**：在每次进程被调度时，检查并更新 `startTime`，保证计算逻辑的完整性。

---

## 八、设计感想

通过本次课程设计，深入了解了进程调度的基本原理和具体实现过程。以下是一些个人体会：

1. **理论与实践结合的重要性**：
    
    - 从理论学习到代码实现，经历了多次尝试和修改，进一步理解了 FCFS 和 RR 调度的优缺点。
    - 特别是在文件解析、队列管理等细节上，实践使我对操作系统的设计思想有了更深的认识。
2. **问题导向的学习**：
    
    - 从字符编码、文件格式到调度算法的逻辑实现，每个问题的解决都推动了对系统设计和优化的深刻理解。
3. **团队协作和改进的价值**：
    
    - 多次与调试工具交互、修改编码错误，反复优化后代码变得更加简洁高效。这体现了团队协作和迭代优化在项目开发中的重要性。
4. **未来改进方向**：
    
    - 加入更复杂的调度算法（如优先级调度、SJF 等）进行扩展分析。
    - 使用图形化工具展示调度结果，使输出更加直观。

通过本次课程设计，不仅完成了目标任务，还从代码优化与设计思维的提升中收获颇多。

如果对上述报告还有具体的改动需求，请指出调整的部分，我会进一步完善内容！
