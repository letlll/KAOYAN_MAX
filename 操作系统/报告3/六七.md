### 六、运行结果展示与分析

#### 1. **分页调度（FIFO）与（LRU）**

**运行情况：**

程序首先选择了“设置页面大小并执行分页调度”，输入了页面大小为 2 KB，进程最大页面数为 2，并选择了不同的页面调度算法（FIFO 和 LRU）。
对每个程序，分别执行了 FIFO 和 LRU 算法，并输出了每个程序需要的总页面数及页面命中率、置换次数等信息。

**FIFO调度结果：**

![|350](assets/屏幕截图%202024-12-21%20143602%201.png) 
![|350](assets/屏幕截图%202024-12-21%20143616%201.png)

![|350](assets/屏幕截图%202024-12-21%20143626.png)

![|350](assets/屏幕截图%202024-12-21%20143635.png)

程序的页面需求量如 `programD` 需要 4 页，`programE` 需要 2 页，依此类推。
每个进程的页面置换情况及内存状态在调度过程中动态变化，FIFO 和 LRU 两种算法的页面命中率存在较大差异。
**页面命中率：**
    FIFO 算法的页面命中率为 **14.29%**。
    LRU 算法的页面命中率稍低，为 **8.33%**。
    这表明 LRU 算法更频繁地发生页面置换，因此其命中率较低。

**分析：**

**FIFO**（先进先出）算法的页面置换策略较为简单，但并不总能优化页面的使用，容易导致高的页面错误（页面置换次数），尤其是在进程访问模式不规则时。
**LRU**（最近最少使用）算法理论上能够提供更高的命中率，尤其适用于访问模式较为局部化的情况。但是，LRU 在本次运行中的表现较差，可能是因为每个程序的内存需求较大且访问模式分散，导致频繁的页面替换。

#### 2. **进程调度（FCFS与RR）**

**先来先服务调度（FCFS）：**

FCFS 调度顺序：`processA -> processB -> processC -> processD -> processE`，依照到达时间排序。
各进程的 `开始时间`、`完成时间`、`周转时间` 和 `带权周转时间` 被正确计算并输出到结果中。

**时间片轮转调度（RR）：**

时间片长度为 3 毫秒。
根据时间片轮转调度算法，各进程的执行过程逐步进行，时间片为 3 毫秒，每个进程在时间片内轮流执行，直至完成。

![|350](assets/屏幕截图%202024-12-21%20135829.png)

**分析：**

**FCFS调度**：先到先服务调度算法的优点是简单，但它的缺点也很明显。若前面的进程运行时间较长，会导致后面的进程等待较久，这也导致了周转时间的增大。例如 `processB` 和 `processC` 的带权周转时间较高。
**RR调度**：相比 FCFS，时间片轮转调度使得每个进程获得均等的执行时间，减少了长时间等待的情况。但是 RR 算法会增加进程的周转时间，尤其是时间片较小时，进程可能需要多轮才能完成。

### 七、课程设计中遇到的问题及解决方法

#### 1. **输入格式不正确（run.txt 文件）**

错误信息：**警告: run.txt 中的行格式不正确: 100 结束**
**问题分析：** `run.txt` 文件中的某一行存在格式错误，可能是输入数据中“100 结束”的格式不符合预期。
**解决方法：**
    检查 `run.txt` 文件中每行的格式，确保每行包含有效的地址和指令。
    确保输入文件中每个“进程”或“地址”后都紧跟着正确的操作，例如指令如 `100` 或 `结束`。
    对文件格式进行验证，确保程序能够正确解析每一行的内容。

#### 2. **页面调度算法表现不佳**

**问题分析：** FIFO 和 LRU 算法的页面命中率较低，尤其在多程序运行时。
**解决方法：**
    改进页面调度算法，尝试加入 **先进先出（FIFO）和最近最少使用（LRU）结合的算法**，或者考虑实现更复杂的算法如 **Optimal** 或 **Clock** 算法。
    优化内存分配策略，可以考虑为每个进程提供一个动态调整大小的内存窗口，避免内存的浪费。

#### 3. **进程调度的周转时间与带权周转时间计算不准确**

**问题分析：** 周转时间和带权周转时间可能因为进程的上下文切换、优先级等因素出现误差。
**解决方法：**
    确保周转时间计算公式正确：`周转时间 = 完成时间 到达时间`，`带权周转时间 = 周转时间 / 运行时间`。
    详细检查每个进程的执行顺序，确保没有遗漏任何进程的调度，尤其在复杂调度算法如时间片轮转中。

#### 4. **内存状态输出不一致**

**问题分析：** 在执行 FIFO 和 LRU 算法时，页面状态（内存中的页面）没有按照预期更新。
**解决方法：**
    确保页面调度器（`PageManager`）中每次替换页面时都会正确更新内存状态。
    可以在内存状态更新后，加入详细的日志输出，确保内存中的页面按预期更新。

#### 5. **类结构不清晰或冗余**

**问题**：在最初的代码设计中，类的结构和字段设计不够清晰，有些类的设计过于复杂或者字段冗余，导致代码难以理解和维护。尤其是 `PCB` 类和 `PageManager` 类，它们包含很多属性和方法，在初步书写时并没有清晰地分隔不同的功能模块。

**解决方法**：

**清晰的类设计**：在设计类时，应当遵循单一职责原则，即每个类应该仅包含它应负责的功能。例如，`PCB` 类应只处理与进程相关的逻辑，而 `PageManager` 类应只负责页管理的功能。
**简化类成员**：不应过多地把一些复杂的数据类型（如 `List<Integer>` 或 `LinkedHashMap<Integer, Integer>`）直接写到类设计中，可以通过简化字段的表示形式来提高代码的可读性和简洁性。

#### 6. **代码未充分注释或文档化**

**问题**：在早期的代码中，缺乏注释和适当的文档，导致阅读和理解代码时可能需要花费更多时间。尤其是对于复杂的类结构和函数实现，缺乏足够的描述容易让他人（或自己）在以后阅读时感到困惑。

**解决方法**：

**添加详细注释**：每个类和方法应该有清晰的注释，特别是类的构造函数、重要字段以及方法的功能描述。这不仅能帮助别人理解代码，也能在自己需要修改时提供足够的上下文信息。
**文档化接口**：对于公开的接口方法，应该提供足够的文档说明，包括方法的输入、输出以及可能的异常。