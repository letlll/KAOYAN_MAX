### 6. 装载问题

### 问题描述

给定一批集装箱，每个集装箱有一个重量 \( W_i \)。有两艘轮船，它们的最大载重分别为 \( C_1 \) 和 \( C_2 \)。问题要求判断是否存在一种装载方案，可以将所有集装箱装载到两艘轮船上，并找出一种合理的装载方案（使总装载重量尽可能接近轮船的载重限制）。

### 算法思想

该装载问题可以看作是一个特殊的 0-1 背包问题。在这个问题中，每个集装箱只能放在其中一艘轮船上，并且我们希望尽可能优化装载重量的分配。我们可以通过**分支限界法**来解决此问题：

1. **状态空间树的构建**：
   - 每个节点表示一个装载状态，左子树表示将当前集装箱装载到轮船 1，右子树表示将当前集装箱装载到轮船 2。
   
2. **限界函数**：
   - 在每个节点上计算当前装载状态下的剩余容量、已装载的重量以及将来可能装载的最大重量。
   - 如果当前节点已经超过某艘轮船的载重量，或者无法实现更优的装载，则剪枝。
   
3. **剪枝策略**：
   - 如果当前装载方案无法超过已知的最佳装载方案，则剪去该路径，从而避免不必要的搜索。

### 伪代码分析

#### 分支限界法的伪代码

```python
function load_branch_and_bound(weights, C1, C2):
    # 初始化
    n = length(weights)
    max_heap = initialize_empty_max_heap()
    best_load = 0
    best_assignment = None

    # 将初始状态推入堆中
    initial_state = (0, 0, 0, 0, 0)  # (负载重, 集装箱索引, 轮船1的重量, 轮船2的重量, 当前已装载重量)
    max_heap.push(initial_state)

    # 主循环：遍历状态空间树的各个节点
    while max_heap is not empty:
        (neg_load, index, load1, load2, current_load) = max_heap.pop()
        load = -neg_load  # 负数表示最大堆

        # 如果所有集装箱都考虑过，检查当前解是否优于最优解
        if index == n:
            if load > best_load:
                best_load = load
                best_assignment = (load1, load2)
            continue

        # 尝试将当前集装箱放入轮船1
        if load1 + weights[index] <= C1:
            new_load1 = load1 + weights[index]
            new_current_load = current_load + weights[index]
            max_heap.push((-new_current_load, index + 1, new_load1, load2, new_current_load))

        # 尝试将当前集装箱放入轮船2
        if load2 + weights[index] <= C2:
            new_load2 = load2 + weights[index]
            new_current_load = current_load + weights[index]
            max_heap.push((-new_current_load, index + 1, load1, new_load2, new_current_load))

    return best_load, best_assignment
```

### 伪代码解读

1. **初始化**：
   - 初始化一个最大堆 `max_heap` 用于存储活结点，以便我们可以优先扩展当前装载重量最高的状态。
   - 记录最佳装载重量 `best_load` 和最佳装载方案 `best_assignment`，初始值设为 0 和 `None`。

2. **初始状态**：
   - 将初始状态（即未装载任何集装箱时的状态）推入堆中。状态包括当前已装载的负载重（取负值以在堆中实现最大堆）、当前考虑的集装箱索引、轮船 1 和轮船 2 的载重、以及当前已装载的总重量。

3. **主循环**：
   - 取出最大堆中的元素，并记录其状态。这里我们取负值的原因是 Python 中的堆是最小堆，通过负数实现最大堆效果。
   - 如果当前集装箱索引等于总集装箱数，说明已遍历完所有集装箱。此时，检查当前装载方案是否比已知的最佳方案更优，如果是，则更新 `best_load` 和 `best_assignment`。
   - 否则，继续考虑将当前集装箱装入轮船 1 或轮船 2：

4. **装入轮船 1 的情况**：
   - 如果将当前集装箱装入轮船 1 后不会超重（即 `load1 + weights[index] <= C1`），则计算新的载重 `new_load1` 和新的总装载重量 `new_current_load`，并将该状态推入最大堆。

5. **装入轮船 2 的情况**：
   - 同样地，如果将当前集装箱装入轮船 2 后不会超重，则计算新的载重 `new_load2` 和新的总装载重量 `new_current_load`，并将该状态推入最大堆。

6. **返回结果**：
   - 最后，返回最佳装载重量 `best_load` 和装载方案 `best_assignment`。

### 示例解释

以 `weights = [16, 15, 15]`，`C1 = 30`，`C2 = 30` 为例：

- 初始状态：
  - 当前装载重量为 0，两艘船的载重都为 0，当前已装载重量为 0。
  
- 每一步尝试将一个集装箱装入轮船 1 或轮船 2，利用堆中保存的最大载重策略，选择最有希望达到最优解的路径。

- 通过分支限界和剪枝，避免无效路径，提高计算效率。

### 代码的主要步骤总结

1. **初始化最大堆**，存储每个节点的装载状态。
2. **从堆中取出最优节点**（即当前已装载重量最大的节点）进行扩展。
3. **剪枝和限界**：在节点扩展时检查是否满足约束条件，不满足则剪枝。
4. **更新最优解**：每次遍历完一个解后，检查当前解是否优于已知的最优解，更新最优解。

---

### 复杂度分析

- **时间复杂度**：由于分支限界算法会遍历部分或全部的解空间树，时间复杂度为 \(O (2^n)\) 的减少版本，具体复杂度依赖于剪枝效果。
- **空间复杂度**：需要使用一个堆来保存活结点，因此空间复杂度为 \(O (2^n)\) 的减少版本。

### 总结

通过分支限界法的限界和剪枝策略，装载问题的解决效率得到了显著提高。