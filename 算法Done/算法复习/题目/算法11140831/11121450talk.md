### 0-1 背包问题的详细解决步骤

我们通过一个实际的例子来逐步理解如何使用动态规划求解 **0-1 背包问题**。假设背包容量为 $C = 15$，并且有 4 个物品，它们的重量和价值如下：

| 物品   | 重量 $w_i$ | 价值 $v_i$ |
|--------|------------|------------|
| 物品 1 | 2          | 10         |
| 物品 2 | 4          | 10         |
| 物品 3 | 6          | 12         |
| 物品 4 | 9          | 18         |

我们目标是计算在背包容量为 15 时，可以装入的物品组合，使得背包中物品的总价值最大。

### 步骤 1: 初始化 DP 数组

首先，我们创建一个二维动态规划数组 `dp[i][j]`，其中 `i` 表示考虑前 `i` 个物品，`j` 表示背包容量。数组的每个元素 `dp[i][j]` 表示在考虑前 `i` 个物品、背包容量为 `j` 时能取得的最大价值。

初始条件如下：
- `dp[0][j] = 0`：没有物品时，无论背包容量是多少，最大价值为 0。
- `dp[i][0] = 0`：背包容量为 0 时，无论有多少物品，最大价值都为 0。

因此，初始时，我们的 DP 数组看起来如下：

| $i \backslash j$ | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 |
|------------------|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
| 0 (物品 0)       | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  | 0  |
| 1 (物品 1)       | 0  | 0  | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 |
| 2 (物品 2)       | 0  | 0  | 10 | 10 | 10 | 10 | 10 | 10 | 20 | 20 | 20 | 20 | 20 | 20 | 20 | 20 |
| 3 (物品 3)       | 0  | 0  | 10 | 10 | 10 | 10 | 12 | 12 | 20 | 22 | 22 | 22 | 22 | 22 | 22 | 22 |
| 4 (物品 4)       | 0  | 0  | 10 | 10 | 10 | 10 | 12 | 12 | 20 | 22 | 22 | 22 | 22 | 28 | 28 | 28 |

### 步骤 2: 填充 DP 表

接下来，我们逐步填充 `dp` 表，遍历每个物品并计算出每个背包容量下的最大价值。对于每个物品，我们有两种选择：

1. **不选择当前物品**：此时，最大价值与之前的状态相同，即 `dp[i][j] = dp[i-1][j]`。
2. **选择当前物品**：此时，最大价值是选择当前物品后的价值，即 `dp[i][j] = dp[i-1][j - w[i]] + v[i]`（前提是背包容量 `j` 大于等于物品的重量 `w[i]`）。

让我们逐步计算每个物品的情况：

#### 1. 处理物品 1（重量 2，价值 10）

对于背包容量 $j$，我们更新 `dp[1][j]`，当背包容量 $j \geq 2$ 时：

\[
Dp[1][j] = \max (dp[0][j], dp[0][j - 2] + 10)
\]

例如：
- 当背包容量为 2 时，`dp[1][2] = \max(dp[0][2], dp[0][0] + 10) = \max(0, 10) = 10`
- 当背包容量为 3 时，`dp[1][3] = \max(dp[0][3], dp[0][1] + 10) = \max(0, 10) = 10`
- 以此类推，直到背包容量 15。

#### 2. 处理物品 2（重量 4，价值 10）

对于每个背包容量 $j \geq 4$，我们使用以下公式更新 `dp[2][j]`：

\[
Dp[2][j] = \max (dp[1][j], dp[1][j - 4] + 10)
\]

例如：
- 当背包容量为 4 时，`dp[2][4] = \max(dp[1][4], dp[1][0] + 10) = \max(10, 10) = 10`
- 当背包容量为 5 时，`dp[2][5] = \max(dp[1][5], dp[1][1] + 10) = \max(10, 10) = 10`
- 当背包容量为 6 时，`dp[2][6] = \max(dp[1][6], dp[1][2] + 10) = \max(10, 20) = 20`
- 以此类推，直到背包容量 15。

#### 3. 处理物品 3（重量 6，价值 12）

同样，对于每个背包容量 $j \geq 6$，我们使用以下公式更新 `dp[3][j]`：

\[
Dp[3][j] = \max (dp[2][j], dp[2][j - 6] + 12)
\]

#### 4. 处理物品 4（重量 9，价值 18）

最后，对于每个背包容量 $j \geq 9$，我们使用以下公式更新 `dp[4][j]`：

\[
Dp[4][j] = \max (dp[3][j], dp[3][j - 9] + 18)
\]

### 步骤 3: 获取结果

在填充完成 DP 表之后，我们的目标是找到 `dp[n][C]`，即在考虑了所有物品后，背包容量为 $C = 15$ 时能够获得的最大价值。

从上面的 DP 表中我们看到：

\[
Dp[4][15] = 28
\]

这意味着，在背包容量为 15 时，选择的最优物品组合使得总价值为 28。

### 总结

- 我们使用二维数组 `dp[i][j]` 来存储在前 `i` 个物品和容量为 `j` 时的最大价值。
- 对于每个物品，我们有两种选择：选择或不选择，分别根据背包容量更新 `dp` 表。
- 最终结果存储在 `dp[n][C]` 中，表示在给定容量下，能够获得的最大价值。

### 你对这个解决方案是否理解？

1. 你是否理解了如何填充 `dp` 表？
2. 你是否掌握了如何根据背包容量和物品的重量、价值来更新 DP 数组？
3. 你对动态规划的基本思路和实现方法是否清晰？

如果有任何不明白的地方，或是你对某个步骤有疑问，可以随时告诉我，我会进一步解释。