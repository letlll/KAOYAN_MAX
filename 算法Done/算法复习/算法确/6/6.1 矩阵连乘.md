---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-08T20:33:00
description: 
review-frequency: normal
reviewed: 2024年-11月-08日
---
>[!important] 
>矩阵连乘数学公式

假设我们有 3 个矩阵 $A 1, A 2, A 3$：
- 矩阵 $A 1$ 的维度是 $p[0] \times p[1] = 50 \times 10$
- 矩阵 $A 2$ 的维度是 $p[1] \times p[2] = 10 \times 40$
- 矩阵 $A 3$ 的维度是 $p[2] \times p[3] = 40 \times 30$

我们想计算矩阵链 $A 1 \cdot A 2 \cdot A 3$ 的最小乘法次数。每次矩阵相乘所需的计算次数与矩阵的维度有关，公式为：
$$
\text{乘法次数} = \text{行数} \times \text{公共维度} \times \text{列数}
$$


---

好的，我们来针对例题 `p = [50, 10, 40, 30, 5]` 展示动态规划表格的构建过程，帮助理解动态规划的表格填充过程。

### 问题回顾

给定四个矩阵：
- $A 1$: $50 \times 10$
- $A 2$: $10 \times 40$
- $A 3$: $40 \times 30$
- $A 4$: $30 \times 5$

目标是通过动态规划找到一种最优的括号化方式，使得总乘法次数最少。

矩阵维度数组为 `p = [50, 10, 40, 30, 5]`。


### 动态规划表格的构建过程

我们将使用两个表格：
1. **m 表**：用于记录从$A[i]$到$A[j]$的最小乘法次数。
2. **s 表**：用于记录最优的分割点，以便我们后续回溯构造最优的括号化顺序。

#### M 表（最小乘法次数表）

| $i \to j$ | 1   | 2         | 3         | 4         |
| --------- | --- | --------- | --------- | --------- |
| **1**     | 0   | $m[1][2]$ | $m[1][3]$ | $m[1][4]$ |
| **2**     |     | 0         | $m[2][3]$ | $m[2][4]$ |
| **3**     |     |           | 0         | $m[3][4]$ |
| **4**     |     |           |           | 0         |

$m[1][1]=A_1$  
$m[2][2]=A_2$
... ... 

 
#### S 表（最优分割点表）

|$i \to j$| 1    | 2     | 3     | 4     |
|-------------|------|-------|-------|-------|
| **1**       | -    |$s[1][2]$|$s[1][3]$|$s[1][4]$|
| **2**       |      | -     |$s[2][3]$|$s[2][4]$|
| **3**       |      |       | -     |$s[3][4]$|
| **4**       |      |       |       | -     |

初始化后，我们将逐步填充 `m` 和 `s` 表格。

---

### 详细计算过程

我们从子链长度$l = 2$开始，逐步增加到$l = 4$。

#### 1. 子链长度$l = 2$

- **计算$m[1][2]$**:
 $$
  M[1][2] = p[0] \times p[1] \times p[2] = 50 \times 10 \times 40 = 20000
 $$
  更新 `m[1][2] = 20000`，`s[1][2] = 1`（分割点在$k = 1$）。

- **计算$m[2][3]$**:
 $$
  M[2][3] = p[1] \times p[2] \times p[3] = 10 \times 40 \times 30 = 12000
 $$
  更新 `m[2][3] = 12000`，`s[2][3] = 2`（分割点在$k = 2$）。

- **计算$m[3][4]$**:
 $$
  M[3][4] = p[2] \times p[3] \times p[4] = 40 \times 30 \times 5 = 6000
 $$
  更新 `m[3][4] = 6000`，`s[3][4] = 3`（分割点在$k = 3$）。

填充完子链长度为 2 的结果后，表格如下：

#### 更新后的 m 表

|$i \to j$| 1      | 2      | 3      | 4      |
|-------------|--------|--------|--------|--------|
| **1**       | 0      | 20000  |        |        |
| **2**       |        | 0      | 12000  |        |
| **3**       |        |        | 0      | 6000   |
| **4**       |        |        |        | 0      |

#### 更新后的 s 表

|$i \to j$| 1    | 2     | 3     | 4     |
|-------------|------|-------|-------|-------|
| **1**       | -    | 1     |       |       |
| **2**       |      | -     | 2     |       |
| **3**       |      |       | -     | 3     |
| **4**       |      |       |       | -     |

---

#### 2. 子链长度$l = 3$

- **计算$m[1][3]$**:
  - 可能的分割点 $k = 1$: 
   $$
    M[1][3] = m[1][1] + m[2][3] + p[0] \times p[1] \times p[3] = 0 + 12000 + 50 \times 10 \times 30 = 27000
   $$
  - 可能的分割点$k = 2$:
   $$
    M[1][3] = m[1][2] + m[3][3] + p[0] \times p[2] \times p[3] = 20000 + 0 + 50 \times 40 \times 30 = 80000
   $$
  - 选择最小值，`m[1][3] = 27000`，`s[1][3] = 1`。

- **计算$m[2][4]$**:
  - 可能的分割点$k = 2$:
   $$
    M[2][4] = m[2][2] + m[3][4] + p[1] \times p[2] \times p[4] = 0 + 6000 + 10 \times 40 \times 5 = 8000
   $$
  - 可能的分割点$k = 3$:
   $$
    M[2][4] = m[2][3] + m[4][4] + p[1] \times p[3] \times p[4] = 12000 + 0 + 10 \times 30 \times 5 = 13500
   $$
  - 选择最小值，`m[2][4] = 8000`，`s[2][4] = 2`。

#### 更新后的 m 表

|$i \to j$| 1   | 2     | 3     | 4    |
| ----------- | --- | ----- | ----- | ---- |
| **1**       | 0   | 20000 | 27000 |      |
| **2**       |     | 0     | 12000 | 8000 |
| **3**       |     |       | 0     | 6000 |
| **4**       |     |       |       | 0    |

#### 更新后的 s 表

|$i \to j$| 1   | 2   | 3   | 4   |
| ---------- | --- | --- | --- | --- |
| **1**      | -   | 1   | 1   |     |
| **2**      |     | -   | 2   | 2   |
| **3**      |     |     | -   | 3   |
| **4**      |     |     |     | -   |

---

#### 3. 子链长度$l = 4$

- **计算$m[1][4]$**:
  - 可能的分割点$k = 1$:
   $$
    M[1][4] = m[1][1] + m[2][4] + p[0] \times p[1] \times p[4] = 0 + 8000 + 50 \times 10 \times 5 = 10500
   $$
  - 可能的分割点$k = 2$:
   $$
    M[1][4] = m[1][2] + m[3][4] + p[0] \times p[2] \times p[4] = 20000 + 6000 + 50 \times 40 \times 5 = 46000
   $$
  - 可能的分割点$k = 3$:
   $$
    M[1][4] = m[1][3] +

 M[4][4] + p[0] \times p[3] \times p[4] = 27000 + 0 + 50 \times 30 \times 5 = 34500
   $$
  - 选择最小值，`m[1][4] = 10500`，`s[1][4] = 1`。

#### 最终 m 表

|$i \to j$| 1      | 2      | 3      | 4      |
|-------------|--------|--------|--------|--------|
| **1**       | 0      | 20000  | 27000  | 10500  |
| **2**       |        | 0      | 12000  | 8000   |
| **3**       |        |        | 0      | 6000   |
| **4**       |        |        |        | 0      |

#### 最终 s 表

|$i \to j$| 1    | 2     | 3     | 4     |
|-------------|------|-------|-------|-------|
| **1**       | -    | 1     | 1     | 1     |
| **2**       |      | -     | 2     | 2     |
| **3**       |      |       | -     | 3     |
| **4**       |      |       |       | -     |
 
---

### 最优解构造

通过回溯 `s` 表，我们可以找到最优的括号化顺序：
- 最优括号化方式为：`((A1A2)A3)A4`

### 总结

通过以上步骤，我们完成了 `m` 和 `s` 表的填充，并找到了最小的乘法次数$10500$和最优的括号化顺序。

---
### 矩阵连乘问题分析与动态规划求解

矩阵连乘问题是经典的动态规划问题之一。给定一系列矩阵，我们要找到一种最优的矩阵乘法计算顺序，使得计算的总次数（乘法次数）最少。因为矩阵乘法满足结合律，不同的计算顺序会影响计算次数，所以我们的目标是找到一种最小化乘法次数的括号化方案。

---

### 1. 问题描述：什么是矩阵连乘问题？

假设我们有$n$个矩阵$A 1, A 2, ..., An$，其中矩阵$Ai$的维度为$p_{i-1} \times p_i$。要计算这些矩阵的连乘积$A 1 \cdot A 2 \cdot ... \cdot An$，我们可以采用不同的括号组合方式。

**示例**：
- 假设四个矩阵的维度如下：
  - $A 1$ 的维度是 $50 \times 10$
  - $A 2$ 的维度是 $10 \times 40$
  - $A 3$ 的维度是 $40 \times 30$
  - $A 4$ 的维度是 $30 \times 5$

矩阵的计算顺序会影响总的乘法次数。通过动态规划，我们可以找到最优的括号化方案。

---

### 2. 动态规划求解矩阵连乘的步骤

解决矩阵连乘问题的关键在于找到一种递归关系，并用动态规划来高效地存储和复用子问题的解。我们按照以下步骤来逐步求解这个问题：

### 步骤 1：定义子问题和状态

我们使用一个二维数组 `m[i][j]` 表示从矩阵$Ai$到$Aj$的最小乘法次数。这表示一个子问题，即在子矩阵链$A[i: j]$中找到最优的计算顺序。

**状态定义**：
- `m[i][j]` 表示计算矩阵$A[i: j]$的最小乘法次数。

### 步骤 2：初始化边界条件

对于单个矩阵的乘法次数，设定 `m[i][i] = 0`。因为单个矩阵不需要乘法，所以乘法次数为 0。

---

### 步骤 3：建立递归关系

通过分析，我们可以得到 `m[i][j]` 的计算公式：

$$
M[i][j] = \min_{i \leq k < j} \{ m[i][k] + m[k+1][j] + p[i-1] \times p[k] \times p[j] \}
$$

- 这里，`k` 表示分割点，将矩阵链$A[i: j]$分为两个子链：$A[i: k]$和$A[k+1: j]$。
- `m[i][k]` 和 `m[k+1][j]` 表示两个子链的最小乘法次数。
- `p[i-1] * p[k] * p[j]` 是将两个子链的结果相乘所需的乘法次数。

### 步骤 4：填充动态规划表格

我们使用一个自下而上的方法，逐步填充 `m[i][j]` 表。我们先计算较小的子链，再利用它们计算较大的子链。

- 外层循环是子链的长度 `l`，从 2 开始，逐步增长到 `n`。
- 每个子链$A[i: j]$的起点 `i` 和终点 `j` 由子链长度 `l` 决定。

---

### 5. 示例演示

以矩阵链 `A1, A2, A3, A4` 为例，维度数组 `p = [50, 10, 40, 30, 5]`。

1. 初始化二维数组 `m`，并将 `m[i][i]` 设为 0。
2. 填充表格，逐步增加子链的长度，最终找到 `m[1][4]` 的最小乘法次数。

---

### 6. Python 伪代码实现

```python
def matrix_chain_order(p):
    n = len(p) - 1  # 矩阵数量
    m = [[0] * (n + 1) for _ in range(n + 1)]  # 存储最小乘法次数
    s = [[0] * (n + 1) for _ in range(n + 1)]  # 存储分割位置

    # 计算从矩阵链长度为2开始，逐步扩展到n
    for l in range(2, n + 1):  # l 表示矩阵链的长度
        for i in range(1, n - l + 2):
            j = i + l - 1  # 结束矩阵
            m[i][j] = float('inf')  # 初始化为一个很大的数
            for k in range(i, j):  # 尝试不同的分割点
                q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]
                if q < m[i][j]:
                    m[i][j] = q  # 更新最小乘法次数
                    s[i][j] = k  # 记录分割点

    return m, s

# 回溯找到最优解的顺序
def traceback(s, i, j):
    if i == j:
        print(f"A{i}", end="")
    else:
        print("(", end="")
        traceback(s, i, s[i][j])
        traceback(s, s[i][j] + 1, j)
        print(")", end="")

# 示例
p = [50, 10, 40, 30, 5]
m, s = matrix_chain_order(p)
print("最少乘法次数为:", m[1][len(p) - 1])
print("最优加括号方式为:", end=" ")
traceback(s, 1, len(p) - 1)
```

### 7. 代码解读与运行示例

- **matrix_chain_order** 函数用于构建 `m` 表和 `s` 表。`m[i][j]` 记录从矩阵 `Ai` 到 `Aj` 的最小乘法次数，而 `s[i][j]` 记录最优分割位置。
- **traceback** 函数是递归的，使用分割位置表 `s`，逐步构建最优的括号化方案。

**输出结果**：
对于输入 `p = [50, 10, 40, 30, 5]`，代码输出如下：

```
最少乘法次数为: 10500
最优加括号方式为: ((A1A2)A3)A4
```

### 总结

通过动态规划，我们可以有效地求解矩阵连乘问题。其关键步骤包括定义子问题、构建状态转移方程、填充 DP 表格、以及使用回溯构造最优解。


---

好的，我们将详细分步骤分析 **矩阵连乘问题** 并使用 Python 伪代码来逐步实现。

### 矩阵连乘问题分析

假设我们有一系列矩阵$A 1, A 2, ..., An$，其中矩阵$Ai$的维度为$p_{i-1} \times p_i$。我们需要找到最优的矩阵乘法计算顺序，使得矩阵相乘的总运算次数最小化。

### 解决方案：动态规划

矩阵连乘问题适合用动态规划来解决。动态规划的核心思想是将问题分解成更小的子问题，通过存储这些子问题的解来避免重复计算，最终获得最优解。

---

### 分步骤解决方案

我们将这个问题分成几个步骤，每个步骤都包含了 Python 伪代码，并提供具体的解释。

---

### 步骤 1：定义问题与状态

我们首先定义一个二维数组 `m[i][j]`，表示从矩阵$Ai$到$Aj$的最小乘法次数。这表示一个子问题的解，即在子矩阵链$A[i: j]$中找到最优的计算顺序。

```python
def matrix_chain_order(p):
    n = len(p) - 1  # 矩阵数量
    m = [[0] * (n + 1) for _ in range(n + 1)]  # 初始化存储最小乘法次数的二维数组
    s = [[0] * (n + 1) for _ in range(n + 1)]  # 初始化存储分割点的二维数组
```

- `p` 是一个包含每个矩阵的维度信息的数组。例如，如果我们有三个矩阵 `A1` (10 x 20), `A2` (20 x 30), `A3` (30 x 40)，那么 `p = [10, 20, 30, 40]`。
- `n` 是矩阵的数量，等于 `len(p) - 1`。
- `m[i][j]` 将存储从矩阵 `Ai` 到 `Aj` 的最小乘法次数。
- `s[i][j]` 将记录矩阵链的分割点，帮助我们构建最优括号化方式。

---

### 步骤 2：初始化边界条件

当我们只包含一个矩阵时，不需要任何乘法，因此我们将 `m[i][i] = 0`，表示单个矩阵的乘法次数为 0。

```python
    for i in range(1, n + 1):
        m[i][i] = 0  # 单个矩阵的乘法次数为 0
```

---

### 步骤 3：建立递归关系

我们使用动态规划的递归关系来逐步填充 `m[i][j]` 表。递归关系为：

$$
M[i][j] = \min_{i \leq k < j} \{ m[i][k] + m[k+1][j] + p[i-1] \times p[k] \times p[j] \}
$$

这里：
- `k` 是当前子链的分割点，表示将矩阵链从 `A[i:j]` 分成两个部分 `A[i:k]` 和 `A[k+1:j]`。
- `m[i][k]` 和 `m[k+1][j]` 表示左、右子链的最小乘法次数。
- `p[i-1] * p[k] * p[j]` 是将两部分相乘所需的次数。

---

### 步骤 4：填充动态规划表格

我们从小到大（即较短子链到较长子链）填充 `m[i][j]` 表格。这样可以确保每个子问题在需要时已经被计算过。

```python
    for l in range(2, n + 1):  # l 表示子链的长度，从2开始到n
        for i in range(1, n - l + 2):  # i 是子链的起始位置
            j = i + l - 1  # j 是子链的结束位置
            m[i][j] = float('inf')  # 将 m[i][j] 初始化为一个很大的数
            for k in range(i, j):  # 尝试所有可能的分割点 k
                # 计算分割点 k 时的乘法次数
                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
                if q < m[i][j]:  # 如果找到更小的乘法次数，则更新 m[i][j]
                    m[i][j] = q
                    s[i][j] = k  # 记录分割点
```

- 外层循环控制子链的长度 `l`，从 2 到 `n`。
- 内层循环通过 `i` 和 `j` 控制子链的起止位置。
- 对每个可能的分割点 `k`，我们计算乘法次数 `q` 并更新 `m[i][j]`。
- 如果找到更小的乘法次数，我们更新 `m[i][j]` 并记录分割点 `k` 到 `s[i][j]`。

---

### 步骤 5：构造最优解（括号化顺序）

填充完 `m` 和 `s` 表后，我们可以通过回溯 `s` 表来构造最优的括号化方案。

```python
# 回溯找到最优解的括号化顺序
def traceback(s, i, j):
    if i == j:  # 单个矩阵，不需要括号
        print(f"A{i}", end="")
    else:
        print("(", end="")  # 左括号
        traceback(s, i, s[i][j])  # 递归处理左子链
        traceback(s, s[i][j] + 1, j)  # 递归处理右子链
        print(")", end="")  # 右括号
```

- **递归回溯**：`traceback` 函数递归地根据 `s[i][j]` 分割点来构建括号化顺序。
  - 如果 `i == j`，表示只有一个矩阵，直接输出矩阵编号。
  - 如果 `i < j`，则分割成两个部分，分别递归构造左右部分的最优括号化顺序。

---

### 完整代码示例

```python
def matrix_chain_order(p):
    n = len(p) - 1  # 矩阵数量
    m = [[0] * (n + 1) for _ in range(n + 1)]  # 存储最小乘法次数
    s = [[0] * (n + 1) for _ in range(n + 1)]  # 存储分割点

    # 初始化m[i][i] = 0
    for i in range(1, n + 1):
        m[i][i] = 0

    # 填充 m 表格和 s 表格
    for l in range(2, n + 1):  # 子链长度从2到n
        for i in range(1, n - l + 2):
            j = i + l - 1
            m[i][j] = float('inf')
            for k in range(i, j):
                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k

    return m, s

def traceback(s, i, j):
    if i == j:
        print(f"A{i}", end="")
    else:
        print("(", end="")
        traceback(s, i, s[i][j])
        traceback(s, s[i][j] + 1, j)
        print(")", end="")

# 示例
p = [50, 10, 40, 30, 5]
m, s = matrix_chain_order(p)
print("最少乘法次数为:", m[1][len(p) - 1])
print("最优加括号方式为:", end=" ")
traceback(s, 1, len(p) - 1)
```

### 运行示例解释

对于输入维度数组 `p = [50, 10, 40, 30, 5]`，代码会输出最小乘法次数以及最优的括号化顺序。

**输出**：
```
最少乘法次数为: 10500
最优加括号方式为: ((A1A2)A3)A4
```

- **最少乘法次数为 10500**：表示在最优括号化顺序下，总共需要 10500 次乘法。
- **最优加括号方式**：`((A1A2)A3)A4`，表示先计算 `(

A 1 A 2) `，再与 ` A 3 ` 相乘，最后与 ` A 4 ` 相乘。

---

### 总结

通过动态规划，我们能够将矩阵连乘问题分解为更小的子问题并构建出最优解。关键步骤包括：

1. **定义子问题和状态**：建立 `m[i][j]` 表来存储子问题的解。
2. **初始化边界条件**：设置单个矩阵的乘法次数为 0。
3. **递归关系填表**：逐步计算子问题的最优解，填充 `m` 表和 `s` 表。
4. **构造最优解**：通过回溯 `s` 表，构建最优括号化顺序。

这种方法极大地减少了重复计算，使得矩阵连乘问题能够在$O (n^3)$时间复杂度内解决。


---

### 计算

>[!question] 
>现在有一个线性代数的n=3，的连乘计算：我不明白数学公式的由来和如何计算其次数；就是我们现在讨论的题目，但是请你只回答，线性代数的计算说明。- **计算$m[1][3]$**:

- 可能的分割点 $k = 1$:

$$

M[1][3] = m[1][1] + m[2][3] + p[0] \times p[1] \times p[3] = 0 + 12000 + 50 \times 10 \times 30 = 27000

$$


---

在矩阵连乘问题中，我们的目标是找到一种最优的计算顺序，使得矩阵相乘的总乘法次数最少。让我们详细解析 **如何计算矩阵连乘的次数**，并解释公式的来源，特别是我们讨论中的例子：**计算 $m[1][3]$**。

### 问题描述与符号解释

假设我们有 3 个矩阵 $A 1, A 2, A 3$：
- 矩阵 $A 1$ 的维度是 $p[0] \times p[1] = 50 \times 10$
- 矩阵 $A 2$ 的维度是 $p[1] \times p[2] = 10 \times 40$
- 矩阵 $A 3$ 的维度是 $p[2] \times p[3] = 40 \times 30$

我们想计算矩阵链 $A 1 \cdot A 2 \cdot A 3$ 的最小乘法次数。每次矩阵相乘所需的计算次数与矩阵的维度有关，公式为：
$$
\text{乘法次数} = \text{行数} \times \text{公共维度} \times \text{列数}
$$

### 计算 $m[1][3]$：逐步解析

为了计算矩阵链 $A 1 \cdot A 2 \cdot A 3$ 的最小乘法次数，我们可以选择不同的分割方式。这里的 `m[i][j]` 表示从矩阵 $Ai$ 到 $Aj$ 的最小乘法次数。

#### 分割点 $k = 1$
将矩阵链 $A 1 \cdot A 2 \cdot A 3$ 分割为两个部分：
1. 左部分：矩阵 $A 1$ （单个矩阵，不需要乘法，因此 $m[1][1] = 0$）
2. 右部分：矩阵链 $A 2 \cdot A 3$，对应的最小乘法次数为 $m[2][3] = 12000$（已预先计算过）

**计算公式**：
$$
M[1][3] = m[1][1] + m[2][3] + p[0] \times p[1] \times p[3]
$$

- **解释每一项**：
  - $m[1][1] = 0$：这是左部分的乘法次数，只有一个矩阵 $A 1$，所以乘法次数为 0。
  - $m[2][3] = 12000$：这是右部分的乘法次数，即 $A 2 \cdot A 3$ 的最优乘法次数。
  - $p[0] \times p[1] \times p[3] = 50 \times 10 \times 30$：这是将左部分的结果（矩阵 $A 1$，维度为 $50 \times 10$）与右部分的结果（矩阵 $A 2 \cdot A 3$，维度为 $10 \times 30$）相乘所需的乘法次数。根据矩阵乘法规则，乘法次数为行数 $\times$ 公共维度 $\times$ 列数。

**代入计算**：
$$
M[1][3] = 0 + 12000 + 50 \times 10 \times 30 = 0 + 12000 + 15000 = 27000
$$

### 总结

- **公式来源**：我们将矩阵链 $A 1 \cdot A 2 \cdot A 3$ 分割为两个部分，分别计算每个部分的最小乘法次数，并加上它们合并时的乘法次数。
- **结果解释**：选择分割点 $k = 1$ 时，矩阵链 $A 1 \cdot A 2 \cdot A 3$ 的最小乘法次数为 27000。

请你出一道简单的矩阵连乘问题：需要帮我巩固知识，并且给出部分提示和步骤参考答案。

---

![](assets/Pasted%20image%2020241113151010.png)


---

