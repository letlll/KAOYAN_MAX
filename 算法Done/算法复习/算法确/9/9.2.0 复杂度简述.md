---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-08T20:33:00
description: 细讲
review-frequency: normal
reviewed: 2024年-11月-08日
---
---

- [x] 1. 01 背包问题 ✅ 2024-11-24
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [ ] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [ ] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [x] 9. O 的性质

---

>[!question] MathJax
>请在 markdown 编辑器中使用 MathJax 格式的数学公式和符号

在软件开发过程中，评估算法的优劣和运行效率至关重要。直观地，我们可能会用程序执行的“快”或“慢”来描述，但这只是宽泛的表述。由于不同的编程语言、编译器和硬件环境会影响程序的运行时间，单纯依靠运行时间并不能准确衡量算法的效率。此外，随着处理数据规模的增长，算法的基本操作次数也会增加，不同算法的增长速度各不相同。

为科学地描述算法运行时间的增长情况，我们引入了**大 O 表示法**（Big O Notation）。大 O 表示法并不直接表示算法运行所需的具体时间，而是描述算法运行时间随输入规模增长的趋势，即算法的**渐进时间复杂度**。通过大 O 表示法，我们可以更直观地理解和比较不同算法在处理大规模数据时的效率表现。

我们可以用下面的表达式来表示：

$$$$
   T (n) = O (f (n))
$$$$

通常主要有以下几种表达式来描述时间复杂度：

- O(1)：常量时间
- O(n)：线性时间
- O(log n)：对数时间
- O(n^2)：二次方时间
- O(2^n)：指数时间
- O(n!)：阶乘时间

![|425](../../../算法SSS/PPTTurnINFO/assets/屏幕截图%202024-11-01%20103439.png)

每种时间复杂度有所不同，下面我们一起来详细了解这几种时间复杂度。
![|625](assets/Pasted%20image%2020241109124233.png)


## O(1)

O(1)表示常量时间复杂度，当给定大小为n的输入，无论n为何值，最后算法执行的时间是个常量。举个例子：

```text
int func(int n)
{
    n++;
    return n*2;
}
```

上面的程序中，无论输入n的值如何变化，程序执行时间始终是个常量。我们简化处理一下，假如函数中每行语句的执行时间是1，则执行时间的数学表达式：

$$
   F (n) = 2
$$

无论n为多大，最后的执行时间都是2这个固定值。虽然是运行时间为2，但是这里我们也用`O(1)`来表示，这里的1代表是一个常数。

## O(n)

`O(n)`表示线性时间复杂度，算法的执行时间随着输入n的大小成线性变化。

```text
int func(int n)
{
    int sum = 0;
    for(int i=0; i<n; i++)
    {
        sum = sum + i;
    }

    return sum;
}
```

上面的这个程序中，函数的执行时间随着n的变化成线性的关系。

$$
   F (n) = n + 2
$$


对于这种可以用线性表达式表示的情况，我们用`O(n)`来表示。

> 为什么可以省略掉表达式中的其他系数呢？主要是当n趋近于无穷大时，系数相对于无穷大的n来说可以忽略不计。  

## O(n^2 )

`O(n^2)`表示二次方时间复杂度，一个算法的时间将会随着输入数据n的增长而呈现出二次关系增加。

```text
int func(int n)
{
    int sum = 0;
    for(int i=0; i<n; i++)
    {
        for(int j=0; j<n; j++)
        {
            sum = sum + i + j;
        }
    }

    return sum;
}
```

上面的程序中，是个两层循环的程序，函数的执行时间和n是二次方的关系：
$$
   F (n) = n^2 + 2
$$

对于这种类型的程序，我们可以用 `O(n^2)` 表示。不过，循环嵌套除了这种两层循环之外，还会有三层、四层...n层循环，对应的其复杂度就是 `O(n^3)` 、`O(n^4)`... `O(n^n)`。

## O(2^n)

`O(2^n)`表示指数复杂度，随着n的增加，算法的执行时间成倍增加，它是一种爆炸式增长的情况。

```text
int func(int n)
{
    if(n==0) return 1;

    return func(n) + func(n-1)
}

```

上面的代码中，有两次递归调用，函数的执行时间就会和输入n成指数的关系。

$$
   F (n) = 2^0 + 2^1 + 2^2 + \dots + 2^n = 2^{n+1}
$$

因此，这里我们可以用`O(2^n)`表示。

## O(log n)

`O(log n)`表示对数时间复杂度，算法执行时间和n是一种对数关系。这种类型的算法会在执行的过程中，随着程序的执行其完成某个功能的操作步骤越来越少。 其中，我们所熟知的二分查找法就是一个很好的例子。比如，下面这个代码在一个有序列表中查找某个值的位置，我们通过二分法进行查找。

```text
int func(int a[], int size, int num)
{
 int left = 0;
 int right = size-1;

 while(left <= right)
 {
  int mid = (left + right)/2;

        if(a[mid] > num)
        {
            right = mid - 1;
        }
        else if (a[mid] < num)
        {
            left = mid + 1;
        }
        else
        {
            return num;
        }
 }

 return -1;
}

```

在最糟糕的情况下，我们通过二分法拆分x次后，最后一个元素就是我们要找的元素。我们可以得到下面的等式：

$$
   \frac{n}{2^x} = 1 \Rightarrow x = \log_2 (n)
$$

函数运行时间可以表示为：

$$
   F (n) = \log_2 (n)
$$

因此，这里我们可以用`O(log n)`表示。

## O(n!)

对于阶乘关系的复杂度，最典型的例子就是旅行商问题。

> 假设有一个旅行商人要拜访n+1个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径长度为所有路径之中的最小值。  

这个问题最简单的方法是通过穷举法列出所有的排列组合。如果有n+1个城市，根据我们数学中学过的排列组合计算方法，可以算出所有组合数为n!，所以这种穷举法对应的时间复杂度也就是`O(n!)`了。

### 常见复杂性函数
![](../../../算法SSS/PPTTurnINFO/assets/屏幕截图%202024-11-01%20103439.png)

- **小规模数据复杂性增长图**

![](../../../算法SSS/PPTTurnINFO/assets/屏幕截图%202024-11-01%20103452.png)
- **中等规模数据复杂性增长图**
![](../../../算法SSS/PPTTurnINFO/assets/屏幕截图%202024-11-01%20103500.png)








