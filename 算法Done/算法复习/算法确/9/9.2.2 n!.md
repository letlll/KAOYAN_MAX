---
tags:
  - Algorithm
doc_type: 笔记卡片
aliases:
  - 数组位移
finished: true
creation: 2024-11-08T20:33:00
modification: 2024-11-08T22:24:00
description: O(n!)
review-frequency: normal
reviewed: 2024年-11月-08日
---
---

- [x] 1. 01 背包问题 ✅ 2024-11-24
- [ ] 2. 各算法的基本思想，求解问题的步骤。
- [ ] 3. 渐进阶的排序
- [ ] 4. 毕波那契
- [ ] 5. 流水作业调度
- [ ] 6. 矩阵连乘
- [ ] 7. 装载问题
- [ ] 8. 贪心算法的证明
- [x] 9. O 的性质

---
### 解释 `O(n!)` —— 阶乘时间复杂度

`O(n!)` 代表 **阶乘时间复杂度**，这是计算机科学中常见的一个极高复杂度类型，意味着随着输入规模 `n` 的增加，算法的执行时间会迅速暴涨。具体来说，`O(n!)` 表示一种算法，其中执行步骤的数量随着 `n` 的增加而呈阶乘增长。

这种复杂度通常出现在 **穷举所有可能的排列或组合** 的算法中。阶乘增长是非常快的，它远远超过了指数增长（`O(2^n)`）的速度。

### 阶乘的增长速度

首先，我们可以简单理解一下阶乘是如何增长的。阶乘的定义是：对于一个正整数 `n`，其阶乘 `n!` 等于 `1 × 2 × 3 × ... × n`。

例如：

- `3! = 1 × 2 × 3 = 6`
- `4! = 1 × 2 × 3 × 4 = 24`
- `5! = 1 × 2 × 3 × 4 × 5 = 120`
- `6! = 1 × 2 × 3 × 4 × 5 × 6 = 720`

你可以看到，阶乘的增长速度是非常快的。每增加一个数值，结果就会变得比上一次大得多。这种快速增长的特性使得 `O(n!)` 的算法在处理较大的 `n` 时非常低效。

### 旅行商问题（TSP）

让我们来具体看一下阶乘时间复杂度的应用—— **旅行商问题**（Traveling Salesman Problem，TSP）。这个问题的描述是这样的：

> 假设有一个旅行商要拜访 `n+1` 个城市。他必须选择走访的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。目标是找到一条路径，使得总路径长度最小。

这个问题的目标是找到最短的路径，但是我们需要 **穷举所有可能的路径**。由于每个城市只能拜访一次，并且最后要回到起始城市，这个问题实际上是在求 **一个完整的排列**，我们需要遍历所有城市的所有排列组合来寻找最短路径。

### 如何计算排列组合

对于 `n+1` 个城市，旅行商的路径实际上是一个 **排列问题**，即从 `n+1` 个城市中选择一个城市作为起点，然后选择其他城市的排列顺序。这个排列数是 `n!`，因为第一个城市有 `n` 种选择，第二个城市有 `n-1` 种选择，依此类推，直到最后剩下一个城市。

举个例子，假设有 4 个城市，旅行商需要遍历所有可能的路径。我们可以这样列举所有排列：

1. 从第一个城市出发，依次选择 3 个其他城市，排列的总数为 `4! = 24`。
2. 对于每一个排列，计算总路径长度并选择最短的一条路径。

### 时间复杂度的推导

假设我们有 `n+1` 个城市，每条路径的长度需要计算一次，因此我们要穷举所有的排列，并计算每个排列的路径长度。由于总共有 `n!` 种可能的路径，所以整个算法的时间复杂度是 `O(n!)`。

这个复杂度意味着，随着 `n` 增加，旅行商问题的求解时间将迅速增长。例如：

- 对于 `n = 5`（即 6 个城市），我们有 `5! = 120` 种路径需要遍历。
- 对于 `n = 10`（即 11 个城市），我们有 `10! = 3,628,800` 种路径需要遍历。
- 对于 `n = 20`（即 21 个城市），我们有 `20! ≈ 2.43 × 10^{18}` 种路径需要遍历。

随着 `n` 的增大，算法所需的时间几乎是无法接受的，尤其当 `n` 超过几十时。

### 为什么是 `O(n!)`？

`O(n!)` 之所以出现在旅行商问题中，是因为我们需要 **穷举所有城市的排列**。对于每一个排列，都需要计算路径的总长度，导致时间复杂度和排列的总数成正比。排列的总数正是 `n!`。

具体来说：
- 对于 `n+1` 个城市，排列的总数为 `n!`。
- 每个排列代表一条可能的路径，我们需要计算每一条路径的长度。
- 因此，总的计算量是 `O(n!)`。

### 比较其他复杂度

`O(n!)` 的增长速度非常快，远远超过了线性复杂度 `O(n)` 或者对数复杂度 `O(log n)`。因此，阶乘复杂度的算法通常是非常低效的，尤其在问题规模增大时。比如说，旅行商问题在 `n` 增大时，穷举法几乎不可能在合理的时间内解决。

### 更高效的算法

针对 `O(n!)` 这样的高复杂度问题，研究者们提出了一些近似算法和启发式算法，例如：

- **动态规划（DP）**：通过记录已经计算过的子问题的结果，减少冗余计算，尽管这样不能完全避免 `O(n!)` 的时间复杂度，但它可以显著减少实际运算的复杂度。
- **分支限界法**：通过提前剪枝，减少不必要的计算。

这些方法可以有效减少计算量，但对于大规模的旅行商问题，仍然是一个非常困难的挑战。

### 总结

- `O(n!)` 表示阶乘时间复杂度，表示随着输入规模 `n` 的增加，执行时间增长非常迅速。
- 旅行商问题是阶乘复杂度的典型例子，算法需要穷举所有可能的路径，即所有城市的排列，因此时间复杂度是 `O(n!)`。
- 阶乘复杂度通常是非常低效的，尤其在问题规模增大时，执行时间会迅速变得不可接受。

### 相关概念

- **排列与组合**：理解排列的定义和计算方法对于理解阶乘复杂度非常重要。
- **旅行商问题**：理解该问题的本质，以及为何其暴力求解方法会导致阶乘复杂度。
- **近似算法**：了解如何通过启发式方法和动态规划等手段减少 `O(n!)` 的计算负担。

你对这些概念的理解如何？如果有任何疑问或需要进一步探讨，我可以进一步解释每个相关概念的细节。